// Numbas version: finer_feedback_settings
{"name": "Moment Balance", "extensions": ["geogebra", "quantities"], "custom_part_types": [{"source": {"pk": 12, "author": {"name": "William Haynes", "pk": 2530}, "edit_page": "/part_type/12/edit"}, "name": "Angle quantity 2020", "short_name": "angle", "description": "<p>Adjusts all angles to 0 &lt; $\\theta$ &lt; 360.</p>\n<p>Accepts '&deg;' and 'deg' as units.</p>\n<p>Penalizes if not close enough or no units.</p>\n<p>90&deg; = -270&deg; = 450&deg;</p>", "help_url": "", "input_widget": "string", "input_options": {"correctAnswer": "plain_string(settings['expected_answer']) ", "hint": {"static": true, "value": ""}, "allowEmpty": {"static": true, "value": false}}, "can_be_gap": true, "can_be_step": true, "marking_script": "original_student_scalar:\nmatchnumber(studentAnswer,['plain','en'])[1]\n\nstudent_scalar:\nmod(original_student_scalar,360)\n\n\nstudent_unit:\nstudentAnswer[len(matchnumber(studentAnswer,['plain','en'])[0])..len(studentAnswer)]\n\ninterpreted_unit:\nif(trim(student_unit)='\u00b0','deg',student_unit)\n\ninterpreted_answer:\nqty(mod(student_scalar,360),'deg')\n\nclose:\nwithintolerance(student_scalar, correct_scalar,decimal(settings['close_tol']))\n\ncorrect_scalar:\nmod(scalar(settings['expected_answer']),360)\n\nright:\nwithintolerance(student_scalar, correct_scalar, decimal(settings['right_tol']))\n\ngood_unit:\nsame(qty(1,interpreted_unit),qty(1,'deg'))\n\nmark:\nassert(close,incorrect('Incorrect.');end());\nif(right,correct('Correct angle.'), set_credit(1 - settings['close_penalty'],'Angle is close.'));\nassert(good_unit,sub_credit(settings['unit_penalty'], 'Missing or incorrect units.'))", "marking_notes": [{"name": "original_student_scalar", "description": "<p>Retuns the scalar part of students answer (which is a quantity) as a number.</p>", "definition": "matchnumber(studentAnswer,['plain','en'])[1]"}, {"name": "student_scalar", "description": "<p>Normalize angle with mod 360</p>", "definition": "mod(original_student_scalar,360)\n"}, {"name": "student_unit", "description": "<p>matchnumber(studentAnswer,['plain','en'])[0] is a string \"12.34\"</p>", "definition": "studentAnswer[len(matchnumber(studentAnswer,['plain','en'])[0])..len(studentAnswer)]"}, {"name": "interpreted_unit", "description": "<p>Allows student to use degree symbol or 'deg' for units.</p>", "definition": "if(trim(student_unit)='\u00b0','deg',student_unit)"}, {"name": "interpreted_answer", "description": "A value representing the student's answer to this part.", "definition": "qty(mod(student_scalar,360),'deg')"}, {"name": "close", "description": "", "definition": "withintolerance(student_scalar, correct_scalar,decimal(settings['close_tol']))"}, {"name": "correct_scalar", "description": "<p>Normalize expected_answer with mod 360</p>", "definition": "mod(scalar(settings['expected_answer']),360)"}, {"name": "right", "description": "", "definition": "withintolerance(student_scalar, correct_scalar, decimal(settings['right_tol']))"}, {"name": "good_unit", "description": "", "definition": "same(qty(1,interpreted_unit),qty(1,'deg'))"}, {"name": "mark", "description": "This is the main marking note. It should award credit and provide feedback based on the student's answer.", "definition": "assert(close,incorrect('Incorrect.');end());\nif(right,correct('Correct angle.'), set_credit(1 - settings['close_penalty'],'Angle is close.'));\nassert(good_unit,sub_credit(settings['unit_penalty'], 'Missing or incorrect units.'))"}], "settings": [{"name": "expected_answer", "label": "Expected Answer", "help_url": "", "hint": "Expected angle as a quantity.", "input_type": "code", "default_value": "qty(30,'deg')", "evaluate": true}, {"name": "unit_penalty", "label": "Unit penalty", "help_url": "", "hint": "Penalty for not including degree sign or 'deg'.", "input_type": "percent", "default_value": "20"}, {"name": "close_penalty", "label": "Close Penalty", "help_url": "", "hint": "Penalty for close answer.", "input_type": "percent", "default_value": "20"}, {"name": "close_tol", "label": "Close", "help_url": "", "hint": "Angle must be $\\pm$ this many degrees to be marked close. &nbsp;&nbsp;", "input_type": "code", "default_value": "0.5", "evaluate": false}, {"name": "right_tol", "label": "Right ", "help_url": "", "hint": "Angle must be $\\pm$ this many degrees to be marked correct. &nbsp;", "input_type": "code", "default_value": "0.1", "evaluate": false}], "public_availability": "restricted", "published": false, "extensions": ["quantities"]}], "resources": [], "navigation": {"allowregen": true, "showfrontpage": false, "preventleave": false, "typeendtoleave": false}, "question_groups": [{"pickingStrategy": "all-ordered", "questions": [{"name": "Moment Balance", "tags": ["eqilibrium", "Mechanics", "mechanics", "Moments", "moments", "Statics", "statics"], "metadata": {"description": "<p>Two known forces, and a third with known magnitude act on a rigid body. &nbsp;Apply $\\Sigma M = 0$ about a pin restraint to determine the direction of the third force. &nbsp;The problem has two valid answers.</p>", "licence": "Creative Commons Attribution-NonCommercial 4.0 International"}, "statement": "<p>{applet}</p>\n<p>Three forces, $A = \\var{A F_units}$, $C = \\var{C F_units}$ and $D = \\var{F F_units}$, act on the rigid, bent bar which can pivot freely on a pin at $B$.</p>\n<p>The segment lengths are: $AB = \\var{ab D_units}$, $BC = \\var{bc D_units}$, and $CD= \\var{cd D_units}$.</p>", "advice": "<p>From the geometry of triangle $BCD$:</p>\n<p style=\"padding-left: 40px;\">$\\phi = \\tan^{-1}\\left( \\dfrac{BC}{CD}\\right) =\\var{precround(phi,1)}&deg;$<br/><br/>$d = \\sqrt{BC^2 +CD^2} &nbsp;= \\var{siground(abs(r_d),4) D_units}$</p>\n<p>From a moment balance around point $B$, the clockwise moment equals the counterclockwise moments:</p>\n<p style=\"padding-left: 40px;\">$\\begin{align}<br/>M_D &amp;= M_A + M_C \\\\<br/>&nbsp;&amp;= (\\var{AB})\\ A_y + (\\var{BC})\\ C_x\\\\<br/>&amp;= \\simplify[!collectNumbers]{({siground(M_A[2],4)} +{siground(M_C[2],4)})}\\\\<br/>&amp;= \\var{siground(-M D_units F_units,4)} \\text{ clockwise}<br/>\\end{align}$</p>\n<p>With the required moment $M_D$ and the magnitude of force $D$ known, the perpendicular distance and the angle between segment $BD$ and force $D$ are:</p>\n<p style=\"padding-left: 40px;\">$d_\\perp = M_D / D &nbsp;= \\dfrac{ \\var{siground(-M D_units F_units,4)}}{\\var{F F_units}} = \\var{siground(dperp,4) D_units}$<br/><br/>$\\alpha =\\sin^{-1}\\left( \\dfrac{d_\\perp}{d}\\right)=\\var{precround(alpha1,1)}&deg;$</p>\n<p>Since $\\sin \\alpha = \\sin (180&deg;-\\alpha)$ another possible angle is:</p>\n<p style=\"padding-left: 40px;\">$\\alpha' = (180&deg; - \\var{precround(alpha1,1)}) = \\var{precround(alpha2,1)}&deg;$</p>\n<p>Finally the angle from the positive $x$ axis to force $D$ can be determined. &nbsp;There are two possible solutions:</p>\n<p style=\"padding-left: 40px;\">$\\theta =180&deg; - \\alpha - \\phi = \\var{precround(-theta1,1)}&deg; $ or <br/>$\\theta = 180 - \\alpha' - \\phi = \\var{precround(-theta2,1)}$</p>\n<p>Note:<em> You can use the red slider on the diagram to switch between the two possible solutions.</em></p>", "rulesets": {}, "extensions": ["geogebra", "quantities"], "builtin_constants": {"e": true, "pi,\u03c0": true, "i": true}, "constants": [], "variables": {"applet": {"name": "applet", "group": "inputs", "definition": "geogebra_applet('qavc8kmn',params)", "description": "", "templateType": "anything", "can_override": false}, "params": {"name": "params", "group": "inputs", "definition": "[ ab: ab, bc: bc, cd: cd, \n  theta_A: radians(theta_A), theta_C: radians(theta_C), theta: radians(-40),\n  fbd: [visible: false, definition: \"false\"],\n  soln: [visible: false]\n ]", "description": "<p>Paramiters for applet</p>", "templateType": "anything", "can_override": false}, "ab": {"name": "ab", "group": "inputs", "definition": "random(1..3#0.25)", "description": "<p>Length of segment AB</p>", "templateType": "anything", "can_override": false}, "bc": {"name": "bc", "group": "inputs", "definition": "random(1..2#0.25)", "description": "<p>Length of segment BC</p>", "templateType": "anything", "can_override": false}, "cd": {"name": "cd", "group": "inputs", "definition": "random(1..3#0.25)", "description": "<p>Length of segment CD</p>", "templateType": "anything", "can_override": false}, "D_units": {"name": "D_units", "group": "inputs", "definition": "qty('ft')", "description": "", "templateType": "anything", "can_override": false}, "theta_C": {"name": "theta_C", "group": "inputs", "definition": "random(110..250#10 except 180)", "description": "<p>Angle of force C, chosen to make a CCW moment</p>", "templateType": "anything", "can_override": false}, "theta_A": {"name": "theta_A", "group": "inputs", "definition": "random(195..345#15)", "description": "<p>Angle of force A, chosen to make a CCW moment</p>", "templateType": "anything", "can_override": false}, "A": {"name": "A", "group": "inputs", "definition": "random(25..250#25)", "description": "<p>Magnitude of force A</p>", "templateType": "anything", "can_override": false}, "C": {"name": "C", "group": "inputs", "definition": "random(25..200#25)", "description": "<p>magnitude of force C</p>", "templateType": "anything", "can_override": false}, "r_a": {"name": "r_a", "group": "solution", "definition": "vector(-ab,0,0)", "description": "<p>positon vector</p>", "templateType": "anything", "can_override": false}, "r_c": {"name": "r_c", "group": "solution", "definition": "vector(0,bc,0)", "description": "<p>position vector</p>", "templateType": "anything", "can_override": false}, "r_d": {"name": "r_d", "group": "solution", "definition": "vector(cd,bc,0)", "description": "<p>position vector</p>", "templateType": "anything", "can_override": false}, "f_a": {"name": "f_a", "group": "solution", "definition": "A vector(cos(radians(theta_a)),sin(radians(theta_a)),0)", "description": "<p>force vector</p>", "templateType": "anything", "can_override": false}, "f_c": {"name": "f_c", "group": "solution", "definition": "C vector(cos(radians(theta_C)),sin(radians(theta_c)),0)", "description": "<p>force vector</p>", "templateType": "anything", "can_override": false}, "M_A": {"name": "M_A", "group": "solution", "definition": "cross(r_a,f_a)", "description": "<p>Moment vector</p>", "templateType": "anything", "can_override": false}, "M_C": {"name": "M_C", "group": "solution", "definition": "cross(r_C, f_C)", "description": "<p>Moment vector</p>", "templateType": "anything", "can_override": false}, "M_D": {"name": "M_D", "group": "solution", "definition": "-(M_A+M_C)", "description": "<p>Moment vector needed for equilibrium</p>", "templateType": "anything", "can_override": false}, "F": {"name": "F", "group": "inputs", "definition": "random(25..200#20)", "description": "<p>Magnitude of force D</p>", "templateType": "anything", "can_override": false}, "F_min": {"name": "F_min", "group": "method 1", "definition": "cross(M_D,r_d)/(abs(r_d)^2)", "description": "<p>Solve for force F, which is the minimum force required, i.e. the force perpendicuar to the moment arm.</p>", "templateType": "anything", "can_override": false}, "f_perp": {"name": "f_perp", "group": "method 1", "definition": "abs(F_min)", "description": "<p>Minimum magnitude of F, also the perpendicular component of force D</p>", "templateType": "anything", "can_override": false}, "alpha1": {"name": "alpha1", "group": "method 1", "definition": " degrees(abs(arcsin(f_perp/F)))", "description": "", "templateType": "anything", "can_override": false}, "phi": {"name": "phi", "group": "method 1", "definition": "degrees(arctan(r_d[1]/r_d[0]))", "description": "", "templateType": "anything", "can_override": false}, "dperp": {"name": "dperp", "group": "method 1", "definition": "abs(M/F)", "description": "<p>perpendicular distance</p>", "templateType": "anything", "can_override": false}, "M": {"name": "M", "group": "solution", "definition": "M_D[2]", "description": "<p>scalar component of M_D</p>", "templateType": "anything", "can_override": false}, "theta1": {"name": "theta1", "group": "method 1", "definition": "-(180-phi-alpha1)", "description": "", "templateType": "anything", "can_override": false}, "f_units": {"name": "f_units", "group": "inputs", "definition": "qty(\"lb\")", "description": "", "templateType": "anything", "can_override": false}, "alpha2": {"name": "alpha2", "group": "method 1", "definition": "180-alpha1", "description": "", "templateType": "anything", "can_override": false}, "theta2": {"name": "theta2", "group": "method 1", "definition": "-(180-phi-alpha2)", "description": "", "templateType": "anything", "can_override": false}}, "variablesTest": {"condition": "0.3 < sin(radians(alpha1)) < 0.95 and alpha1 < 180 - phi -20//  for diagram to show alpha in the triangle\nand dperp < abs(r_d)", "maxRuns": 100}, "ungrouped_variables": [], "variable_groups": [{"name": "solution", "variables": ["r_a", "r_c", "r_d", "f_a", "f_c", "M_A", "M_C", "M_D", "M"]}, {"name": "method 1", "variables": ["F_min", "f_perp", "dperp", "alpha1", "alpha2", "phi", "theta1", "theta2"]}, {"name": "inputs", "variables": ["applet", "params", "ab", "bc", "cd", "theta_A", "theta_C", "f_units", "D_units", "A", "C", "F"]}], "functions": {"hide_items": {"parameters": [["app", "ggbapplet"]], "type": "anything", "language": "javascript", "definition": "// See https://wiki.geogebra.org/en/Scripting_Commands and\n// https://wiki.geogebra.org/en/Reference:GeoGebra_Apps_API\nreturn;\napp.promise.then(function(d) {\n  d.app.setVisible('LOA', false);\n  d.app.setVisible('ref', false);\n  d.app.setVisible('t1', false);\n  d.app.setVisible('alpha', false);\n  d.app.setVisible('phi', false);\n});\nreturn new Numbas.jme.types.ggbapplet(app);\n"}}, "preamble": {"js": "question.signals.on('adviceDisplayed',function() {\n  \n  try{\n    //var app = question.applet.app;\n    var app = Numbas.exam.currentQuestion.scope.variables.applet.app;\n    var theta = - Numbas.exam.currentQuestion.scope.variables.theta1.value;\n    console.log(theta);\n    app.setVisible(\"fbd\",true);\n    app.setValue(\"fbd\",true);\n    app.setVisible(\"soln\",true);\n    app.setValue(\"soln\",1);\n    app.setValue(\"theta\", -theta * 3.14 /180 );\n    app.setLabelVisible(\"A\",false);\n    app.setLabelVisible(\"B\",false);\n    app.setLabelVisible(\"C\",false);\n    app.setLabelVisible(\"D\",false);\n  }\n  catch(err){}  \n})\n", "css": ""}, "parts": [{"type": "gapfill", "useCustomName": false, "customName": "", "marks": 0, "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": true, "showFeedbackIcon": true, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "prompt": "<p>Find an angle $\\theta$ that will make the sum of the moments about point $B=0$.</p>\n<p>$\\theta = $ [[0]]&nbsp; (Measure $\\theta$ CW from the positive $x$ axis.)</p>", "gaps": [{"type": "angle", "useCustomName": true, "customName": "$\\theta$", "marks": "20", "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": true, "showFeedbackIcon": true, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "alternatives": [{"type": "angle", "useCustomName": true, "customName": "$\\theta'$", "marks": "20", "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "alternativeFeedbackMessage": "", "useAlternativeFeedback": false, "settings": {"expected_answer": "precround(qty(-theta2,'deg'),2)", "unit_penalty": "20", "close_penalty": "20", "close_tol": "0.5", "right_tol": "0.1"}}], "settings": {"expected_answer": "precround(qty(-theta1,'deg'),2)", "unit_penalty": "20", "close_penalty": "20", "close_tol": "0.5", "right_tol": "0.1"}}], "sortAnswers": false}], "partsMode": "all", "maxMarks": 0, "objectives": [], "penalties": [], "objectiveVisibility": "always", "penaltyVisibility": "always", "type": "question", "contributors": [{"name": "William Haynes", "profile_url": "https://numbas.mathcentre.ac.uk/accounts/profile/2530/"}], "resources": []}]}], "contributors": [{"name": "William Haynes", "profile_url": "https://numbas.mathcentre.ac.uk/accounts/profile/2530/"}]}