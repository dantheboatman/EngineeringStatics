// Numbas version: finer_feedback_settings
{"name": "Centroid of a composite area: shape with hole", "extensions": ["geogebra", "sheets", "quantities"], "custom_part_types": [{"source": {"pk": 19, "author": {"name": "William Haynes", "pk": 2530}, "edit_page": "/part_type/19/edit"}, "name": "Engineering Accuracy with units", "short_name": "engineering-answer", "description": "<p>A value with units marked right if within an adjustable % error of the correct value. &nbsp;Marked close if within a wider margin of error.</p>", "help_url": "", "input_widget": "string", "input_options": {"correctAnswer": "siground(settings['correctAnswer'],4)", "hint": {"static": true, "value": ""}, "allowEmpty": {"static": true, "value": true}}, "can_be_gap": true, "can_be_step": true, "marking_script": "mark:\nswitch( \n  right and good_units and right_sign, add_credit(1.0,'Correct.'),\n  right and good_units and not right_sign, add_credit(settings['C2'],'Wrong sign.'),\n  right and right_sign and not good_units, add_credit(settings['C2'],'Correct value, but wrong or missing units.'),\n  close and good_units, add_credit(settings['C1'],'Close.'),\n  close and not good_units, add_credit(settings['C3'],'Answer is close, but wrong or missing units.'),\n  incorrect('Wrong answer.')\n)\n\ninterpreted_answer:\nqty(student_scalar, student_units)\n\n\n\ncorrect_quantity:\nsettings[\"correctAnswer\"]\n\n\n\ncorrect_units:\nunits(correct_quantity)\n\n\nallowed_notation_styles:\n[\"plain\",\"en\"]\n\nmatch_student_number:\nmatchnumber(studentAnswer,allowed_notation_styles)\n\nstudent_scalar:\nmatch_student_number[1]\n\nstudent_units:\nreplace_regex('ohms','ohm',\n  replace_regex('\u00b0', ' deg',\n    replace_regex('-', ' ' ,\n      studentAnswer[len(match_student_number[0])..len(studentAnswer)])),\"i\")\n\ngood_units:\ntry(\ncompatible(quantity(1, student_units),correct_units),\nmsg,\nfeedback(msg);false)\n\n\nstudent_quantity:\nswitch(not good_units, \n       student_scalar * correct_units, \n       not right_sign,\n       -quantity(student_scalar, student_units),\n       quantity(student_scalar,student_units)\n)\n  \n\n\npercent_error:\ntry(\nscalar(abs((correct_quantity - student_quantity)/correct_quantity))*100  \n,msg,\nif(student_quantity=correct_quantity,0,100))\n   \n\nright:\npercent_error <= settings['right']\n\n\nclose:\nright_sign and percent_error <= settings['close']\n\nright_sign:\nsign(student_scalar) = sign(correct_quantity)", "marking_notes": [{"name": "mark", "description": "This is the main marking note. It should award credit and provide feedback based on the student's answer.", "definition": "switch( \n  right and good_units and right_sign, add_credit(1.0,'Correct.'),\n  right and good_units and not right_sign, add_credit(settings['C2'],'Wrong sign.'),\n  right and right_sign and not good_units, add_credit(settings['C2'],'Correct value, but wrong or missing units.'),\n  close and good_units, add_credit(settings['C1'],'Close.'),\n  close and not good_units, add_credit(settings['C3'],'Answer is close, but wrong or missing units.'),\n  incorrect('Wrong answer.')\n)"}, {"name": "interpreted_answer", "description": "A value representing the student's answer to this part.", "definition": "qty(student_scalar, student_units)\n\n"}, {"name": "correct_quantity", "description": "", "definition": "settings[\"correctAnswer\"]\n\n"}, {"name": "correct_units", "description": "", "definition": "units(correct_quantity)\n"}, {"name": "allowed_notation_styles", "description": "", "definition": "[\"plain\",\"en\"]"}, {"name": "match_student_number", "description": "", "definition": "matchnumber(studentAnswer,allowed_notation_styles)"}, {"name": "student_scalar", "description": "", "definition": "match_student_number[1]"}, {"name": "student_units", "description": "<p>Modify&nbsp;the&nbsp;unit portion of&nbsp;the student's answer by</p>\n<p>1. replacing \"ohms\" with \"ohm\" &nbsp;case insensitive</p>\n<p>2.&nbsp;replacing '-'&nbsp;with ' '&nbsp;</p>\n<p>3. replacing '&deg;' with ' deg'&nbsp;</p>\n<p>to allow answers like 10 ft-lb and 30&deg;</p>", "definition": "replace_regex('ohms','ohm',\n  replace_regex('\u00b0', ' deg',\n    replace_regex('-', ' ' ,\n      studentAnswer[len(match_student_number[0])..len(studentAnswer)])),\"i\")"}, {"name": "good_units", "description": "", "definition": "try(\ncompatible(quantity(1, student_units),correct_units),\nmsg,\nfeedback(msg);false)\n"}, {"name": "student_quantity", "description": "<p>This fixes the student answer for two common errors. &nbsp;</p>\n<p>If student_units are wrong&nbsp;&nbsp;- replace with correct units</p>\n<p>If student_scalar has the wrong sign - replace with right sign</p>\n<p>If student makes both errors, only one gets fixed.</p>", "definition": "switch(not good_units, \n       student_scalar * correct_units, \n       not right_sign,\n       -quantity(student_scalar, student_units),\n       quantity(student_scalar,student_units)\n)\n  \n"}, {"name": "percent_error", "description": "", "definition": "try(\nscalar(abs((correct_quantity - student_quantity)/correct_quantity))*100  \n,msg,\nif(student_quantity=correct_quantity,0,100))\n   "}, {"name": "right", "description": "", "definition": "percent_error <= settings['right']\n"}, {"name": "close", "description": "<p>Only marked close if the student actually has the right sign.</p>", "definition": "right_sign and percent_error <= settings['close']"}, {"name": "right_sign", "description": "", "definition": "sign(student_scalar) = sign(correct_quantity) "}], "settings": [{"name": "correctAnswer", "label": "Correct Quantity.", "help_url": "", "hint": "The correct answer given as a JME quantity.", "input_type": "code", "default_value": "", "evaluate": true}, {"name": "right", "label": "% Accuracy for right.", "help_url": "", "hint": "Question will be considered correct if the scalar part of the student's answer is within this % of correct value.", "input_type": "code", "default_value": "0.2", "evaluate": true}, {"name": "close", "label": "% Accuracy for close.", "help_url": "", "hint": "Question will be considered close if the scalar part of the student's answer is within this % of correct value.", "input_type": "code", "default_value": "1.0", "evaluate": true}, {"name": "C1", "label": "Close with units.", "help_url": "", "hint": "Partial Credit for close value with appropriate units. &nbsp;if correct answer is 100 N and close is &plusmn;1%,<br />99 &nbsp;N is accepted.", "input_type": "percent", "default_value": "75"}, {"name": "C2", "label": "No units or wrong sign", "help_url": "", "hint": "Partial credit for forgetting units or using wrong sign.<br />If the correct answer is 100 N, both 100 and -100 N are accepted.", "input_type": "percent", "default_value": "50"}, {"name": "C3", "label": "Close, no units.", "help_url": "", "hint": "Partial Credit for close value but forgotten units.<br />This value would be close&nbsp;if the expected units were provided. &nbsp;If the correct answer is 100 N, and close is &plusmn;1%,<br />99 is accepted.", "input_type": "percent", "default_value": "25"}], "public_availability": "always", "published": true, "extensions": ["quantities"]}, {"source": {"pk": 242, "author": {"name": "Christian Lawson-Perfect", "pk": 7}, "edit_page": "/part_type/242/edit"}, "name": "Spreadsheet", "short_name": "spreadsheet", "description": "<p>An editable spreadsheet. Ranges of cells can be disabled, and you can specify ranges of cells to be marked. A cell is marked correct if its value is equal to the value in the expected answer spreadsheet.</p>", "help_url": "", "input_widget": "spread-sheet", "input_options": {"correctAnswer": "settings[\"correct_answer\"]", "hint": {"static": true, "value": ""}, "initial_sheet": {"static": false, "value": "disable_cells(settings[\"initial_sheet\"], settings[\"disable_ranges\"])"}}, "can_be_gap": true, "can_be_step": true, "marking_script": "mark:\nif(sum(mark_ranges)=0,\n  incorrect(),\n  apply(mark_ranges)\n)\n\ninterpreted_answer:\nstudentAnswer\n\nrange_cells:\nmap(parse_range(ref),ref,values(settings[\"mark_ranges\"]))\n\ntotal_cells:\nlen(flatten(range_cells))\n\nrange_weights:\nswitch(\n  settings[\"marking_method\"]=\"per_cell\",\n    map(len(r)/total_cells, r, range_cells),\n  // otherwise, mark per range\n    repeat(1/len(range_cells), len(range_cells))\n)\n\nmark_ranges:\nmap(\n  let(\n    range_credit,\n      sum(map(\n        let(\n          correctCellString, correctAnswer[c],\n          correctCellNumber, parsenumber(correctCellString, notation_styles),\n          studentCellString, studentAnswer[c],\n          studentCellNumber, parsenumber(studentCellString, notation_styles),\n          award(\n            1/len(cells), \n            switch(\n              correctCellString=\"\",\n                isnan(studentCellNumber) or studentCellString=\"\",\n              isnan(correctCellNumber),\n                lower(correctCellString) = lower(studentCellString)\n              ,\n                abs(studentCellNumber - if(isnan(correctCellNumber),0,correctCellNumber)) <= settings[\"tolerance\"]\n            )\n          )\n        ),\n        c,\n        cells\n      )),\n    message,\n      switch(\n        range_credit=0,\n          if(len(cells)=1, \"This entry is incorrect.\", \"All entries in this range are incorrect.\"),\n        range_credit=1,\n          if(len(cells)=1, \"This entry is correct.\", \"All entries in this range are correct.\"),\n        //otherwise\n          \"Some entries in this range are correct.\"\n      ),\n    assert(len(cells)=0, add_credit(range_credit*w, \"<strong>{name}:</strong> \"+message)); \n    range_credit\n  ),\n  [cells,w,name],\n  zip(range_cells, range_weights, keys(settings[\"mark_ranges\"]))\n)\n\nnotation_styles:\n[\"plain\",\"si-en\"]\n\ncorrectAnswer:\nsettings[\"correct_answer\"]", "marking_notes": [{"name": "mark", "description": "This is the main marking note. It should award credit and provide feedback based on the student's answer.", "definition": "if(sum(mark_ranges)=0,\n  incorrect(),\n  apply(mark_ranges)\n)"}, {"name": "interpreted_answer", "description": "A value representing the student's answer to this part.", "definition": "studentAnswer"}, {"name": "range_cells", "description": "<p>For each range to be marked, the addresses of the cells in that range.</p>", "definition": "map(parse_range(ref),ref,values(settings[\"mark_ranges\"]))"}, {"name": "total_cells", "description": "<p>The total number of cells to be marked. Cells in overlapping ranges will be counted once for each range they're in.</p>", "definition": "len(flatten(range_cells))"}, {"name": "range_weights", "description": "<p>The weight of each range, as a proportion of the available credit.</p>", "definition": "switch(\n  settings[\"marking_method\"]=\"per_cell\",\n    map(len(r)/total_cells, r, range_cells),\n  // otherwise, mark per range\n    repeat(1/len(range_cells), len(range_cells))\n)"}, {"name": "mark_ranges", "description": "<p>Mark each of the ranges specified by the question author.</p>", "definition": "map(\n  let(\n    range_credit,\n      sum(map(\n        let(\n          correctCellString, correctAnswer[c],\n          correctCellNumber, parsenumber(correctCellString, notation_styles),\n          studentCellString, studentAnswer[c],\n          studentCellNumber, parsenumber(studentCellString, notation_styles),\n          award(\n            1/len(cells), \n            switch(\n              correctCellString=\"\",\n                isnan(studentCellNumber) or studentCellString=\"\",\n              isnan(correctCellNumber),\n                lower(correctCellString) = lower(studentCellString)\n              ,\n                abs(studentCellNumber - if(isnan(correctCellNumber),0,correctCellNumber)) <= settings[\"tolerance\"]\n            )\n          )\n        ),\n        c,\n        cells\n      )),\n    message,\n      switch(\n        range_credit=0,\n          if(len(cells)=1, \"This entry is incorrect.\", \"All entries in this range are incorrect.\"),\n        range_credit=1,\n          if(len(cells)=1, \"This entry is correct.\", \"All entries in this range are correct.\"),\n        //otherwise\n          \"Some entries in this range are correct.\"\n      ),\n    assert(len(cells)=0, add_credit(range_credit*w, \"<strong>{name}:</strong> \"+message)); \n    range_credit\n  ),\n  [cells,w,name],\n  zip(range_cells, range_weights, keys(settings[\"mark_ranges\"]))\n)"}, {"name": "notation_styles", "description": "<p>Accepted number notation styles for a value in an individual cell.</p>", "definition": "[\"plain\",\"si-en\"]"}, {"name": "correctAnswer", "description": "", "definition": "settings[\"correct_answer\"]"}], "settings": [{"name": "initial_sheet", "label": "Initial sheet", "help_url": "", "hint": "A <code>spreadsheet</code> object giving the initial state of the sheet that the student should fill in.", "input_type": "code", "default_value": "", "evaluate": true}, {"name": "correct_answer", "label": "Correct answer", "help_url": "", "hint": "A <code>spreadsheet</code> object representing a correct answer to the part.", "input_type": "code", "default_value": "", "evaluate": true}, {"name": "disable_ranges", "label": "Ranges to disable", "help_url": "", "hint": "A list of cell or range references, denoting the cells that should not be editable.", "input_type": "code", "default_value": "[]", "evaluate": true}, {"name": "mark_ranges", "label": "Ranges to mark", "help_url": "", "hint": "A dictionary of cell or range references, mapping names to ranges of cells, denoting the cells that should be compared for equality with the expected answer.", "input_type": "code", "default_value": "dict()", "evaluate": true}, {"name": "marking_method", "label": "Marking method", "help_url": "", "hint": "", "input_type": "dropdown", "default_value": "per_cell", "choices": [{"value": "per_cell", "label": "Each cell has the same weight"}, {"value": "per_range", "label": "Each range has the same weight"}]}, {"name": "tolerance", "label": "Allowed margin of error", "help_url": "", "hint": "", "input_type": "code", "default_value": "0", "evaluate": true}], "public_availability": "always", "published": true, "extensions": ["sheets"]}], "resources": [], "navigation": {"allowregen": true, "showfrontpage": false, "preventleave": false, "typeendtoleave": false}, "question_groups": [{"pickingStrategy": "all-ordered", "questions": [{"name": "Centroid of a composite area: shape with hole", "tags": ["centroids", "composite area method", "mechanics", "Mechanics", "statics", "Statics"], "metadata": {"description": "<p>Find the centroid of&nbsp;a shape made from&nbsp;a rectangle, triangle, and circle.</p>", "licence": "Creative Commons Attribution-NonCommercial 4.0 International"}, "statement": "<p>Complete the table below and detemine the coordinates of the centroid of the composite shape shown.</p>\n<p>Consider the shape to be made up of a {if (m=1,'large','')} rectangle {if (m=0, 'plus a triangle', 'with a triangle removed')}, with a {if(random(true,false), &nbsp;radius + \" \" + units &nbsp;+ \" radius\" , &nbsp;2 * radius + \" \" &nbsp;+ units + \" diameter\")} circular hole centered at ({(center+A)[0]}, {(center+A)[1]}).</p>\n<table style=\"margin-left: auto; margin-right: auto;\">\n<tbody>\n<tr>\n<td>{geogebra_applet('fcfsjuv9',[ ['A',A],['b_1',b1],['h_1',h1],['h_t',ht],['n',n],['Center',center],['radius',radius]])}</td>\n</tr>\n</tbody>\n</table>\n<p><span data-jme-visible=\"debug\">{table_add_q}</span></p>", "advice": "<p>{geogebra_applet('fcfsjuv9',[ ['A',A],['b_1',b1],['h_1',h1],['h_t',ht],['n',n],['Center',center],['radius',radius],['visibility',m]])}</p>\n<p>1. Divide the shape into three subshapes as described in the problem statement.&nbsp;</p>\n<p>2. Know how to set up a table to collect the information, since it will not normally be provided.</p>\n<p>3. Determine and enter&nbsp;the area and centroidal coordinates for each subshape into the table</p>\n<p style=\"padding-left: 30px;\">$\\qquad A_i, \\bar{x}_i,\\bar{y}_i$</p>\n<p>4. Multiply area by the centroidal coordinates to&nbsp;get the moment of areas for the pieces.</p>\n<p style=\"padding-left: 30px;\">$\\qquad (Q_x)_i = A_i\\bar{y}_i ,\\quad(Q_y)_i=A_i\\bar{x}_i$.</p>\n<p>5. Sum columns 3, 6 and 7 to find the total area and moments of area: $ A, Q_x, Q_y$</p>\n<p>6. Find answers with &nbsp;</p>\n<p style=\"padding-left: 30px;\">$\\qquad &nbsp;\\bar{x} = \\dfrac{Q_y}{A} =\\dfrac{\\Sigma A_i \\bar{x}_i}{\\Sigma A_i} = \\dfrac{\\var{siground(Q_total[1],3)}}{\\var{siground(area_total,3)}} = &nbsp;\\var{siground(centroid[0],3)}\\, \\var{units}$</p>\n<p style=\"padding-left: 30px;\">$\\qquad &nbsp;\\bar{y} &nbsp;= \\dfrac{Q_x}{A} = \\dfrac{\\Sigma A_i \\bar{y}_i}{\\Sigma A_i}= \\dfrac{\\var{siground(Q_total[0],3)}}{\\var{siground(area_total,3)}}= \\var{siground(centroid[1],3)}\\, \\var{units} $</p>", "rulesets": {}, "extensions": ["geogebra", "quantities", "sheets"], "builtin_constants": {"e": true, "pi,\u03c0": true, "i": true, "j": false}, "constants": [], "variables": {"ht": {"name": "ht", "group": "Input values", "definition": "random(3..9#3)", "description": "<p>\"height\" of triangle &nbsp;</p>\n<p>horizontal for n = 4,5,6,10,11,12</p>\n<p>vertical for n = 1,2,3,7,8,9</p>", "templateType": "anything", "can_override": false}, "C_rect": {"name": "C_rect", "group": "centroids", "definition": "[vector(b1/2,h1/2) + A,\n if(n in [1,2,3], vector(b1/2,(h1-ht)/2)+A,\n if(n in [4,5,6], vector((b1+ht)/2,h1/2)+A,\n if(n in [7,8,9], vector(b1/2,(h1+ht)/2)+A,\n vector((b1-ht)/2,h1/2)+A)))] ", "description": "", "templateType": "anything", "can_override": false}, "C_circ": {"name": "C_circ", "group": "centroids", "definition": "[center +A ,center +A]", "description": "", "templateType": "anything", "can_override": false}, "units": {"name": "units", "group": "Input values", "definition": "random('in', 'cm', 'ft' )", "description": "<p>Offset of bottom right corner from originl</p>", "templateType": "anything", "can_override": false}, "area_circ": {"name": "area_circ", "group": "Calculated areas", "definition": "[- pi * radius^2, - pi* radius^2]", "description": "", "templateType": "anything", "can_override": false}, "area_total": {"name": "area_total", "group": "Calculated areas", "definition": "area_rect[0]+area_tri[0]+area_circ[0]", "description": "", "templateType": "anything", "can_override": false}, "area_tri": {"name": "area_tri", "group": "Calculated areas", "definition": "[if(n in [1,2,3,7,8,9], b1*ht/2,h1*ht/2),\n-if(n in [1,2,3,7,8,9], b1*ht/2,h1*ht/2)]", "description": "", "templateType": "anything", "can_override": false}, "center": {"name": "center", "group": "Input values", "definition": "vector(b1/2,h1/2) + random(0..3) *\nvector(if(n<=3,[0,-1],\nif(n<=6,[1,0],\nif(n<=9,[0,1],\n[-1,0]))))\n\n\n\n\n", "description": "<p>center of the circle measured from bottom left of the rectangle</p>", "templateType": "anything", "can_override": false}, "Q_circ": {"name": "Q_circ", "group": "moments of area", "definition": "area_circ[m] * vector(C_circ[m][1],C_circ[m][0])", "description": "", "templateType": "anything", "can_override": false}, "radius": {"name": "radius", "group": "Input values", "definition": "random(1..(min(h1-1,b1-1)/2)#0.5)", "description": "<p>radius of the circle</p>", "templateType": "anything", "can_override": false}, "A": {"name": "A", "group": "Input values", "definition": "-vector(random([0,0],[b1,0],[b1,h1],[0,h1],[b1/2,h1/2],[0,h1/2],[center[0],center[1]]))", "description": "<p>This offsets the shape to one of the corners of the rect, the center of the rect, or the center of the circle.</p>", "templateType": "anything", "can_override": false}, "h1": {"name": "h1", "group": "Input values", "definition": "random(4..12#2)", "description": "<p>vertical height of rectangle</p>", "templateType": "anything", "can_override": false}, "b1": {"name": "b1", "group": "Input values", "definition": "random(4..12#2)", "description": "<p>horizontal base of rectangle</p>", "templateType": "anything", "can_override": false}, "n": {"name": "n", "group": "Input values", "definition": "random(1 .. 12#1)", "description": "<p>Selects the position of the triangle, index gives vertex location</p>\n<table>\n<tbody>\n<tr>\n<td style=\"text-align: center;\"></td>\n<td style=\"text-align: center;\">9</td>\n<td style=\"text-align: center;\">8</td>\n<td style=\"text-align: center;\">7</td>\n<td style=\"text-align: center;\"></td>\n</tr>\n<tr>\n<td style=\"text-align: center;\">10</td>\n<td style=\"text-align: center;\"></td>\n<td style=\"text-align: center;\"></td>\n<td style=\"text-align: center;\"></td>\n<td style=\"text-align: center;\">6</td>\n</tr>\n<tr>\n<td style=\"text-align: center;\">11</td>\n<td style=\"text-align: center;\"></td>\n<td style=\"text-align: center;\">rectangle</td>\n<td style=\"text-align: center;\"></td>\n<td style=\"text-align: center;\">5</td>\n</tr>\n<tr>\n<td style=\"text-align: center;\">12</td>\n<td style=\"text-align: center;\"></td>\n<td style=\"text-align: center;\"></td>\n<td style=\"text-align: center;\"></td>\n<td style=\"text-align: center;\">4</td>\n</tr>\n<tr>\n<td style=\"text-align: center;\"></td>\n<td style=\"text-align: center;\">1</td>\n<td style=\"text-align: center;\">2</td>\n<td style=\"text-align: center;\">3</td>\n<td style=\"text-align: center;\"></td>\n</tr>\n</tbody>\n</table>", "templateType": "randrange", "can_override": false}, "C_tri": {"name": "C_tri", "group": "centroids", "definition": "// determines location of centroid\n// returns array of centroid coordinates, first term for m=0 \n[\nswitch(\n  n=1, vector(b1/3,-ht/3),\n  n=2, vector(b1/2,-ht/3),\n  n=3, vector(2*b1/3,-ht/3),\n  n=4, vector(b1+ht/3,h1/3),\n  n=5, vector(b1+ht/3,h1/2),\n  n=6, vector(b1+ht/3,2*h1/3),\n  n=7, vector(2 * b1/3, h1+ht/3),\n  n=8, vector(b1/2, h1+ht/3),\n  n=9, vector(b1/3, h1+ht/3),\n  n=10, vector(-ht/3,2*h1/3),\n  n=11, vector(-ht/3,h1/2),\n  n=12, vector(-ht/3,h1/3)\n  ) + A\n  ,\n  switch(\n  n=3, vector(b1/3,-2*ht/3),\n  n=2, vector(b1/2,-2*ht/3),\n  n=1, vector(2*b1/3,-2*ht/3),\n  n=6, vector(b1+2*ht/3,h1/3),\n  n=5, vector(b1+2*ht/3,h1/2),\n  n=4, vector(b1+2*ht/3,2*h1/3),\n  n=9, vector(2 * b1/3, h1+2*ht/3),\n  n=8, vector(b1/2, h1+2*ht/3),\n  n=7, vector(b1/3, h1+2*ht/3),\n  n=12, vector(-2*ht/3,2*h1/3),\n  n=11, vector(-2*ht/3,h1/2),\n  n=10, vector(-2*ht/3,h1/3)\n  ) + A\n  ]", "description": "<p>determines location of centroid of triangle based on location and method<br />returns array of centroid coordinates, first term for m=0 <br /><br /></p>", "templateType": "anything", "can_override": false}, "m": {"name": "m", "group": "Input values", "definition": "if(n in [2,5,8,11],0,random(0..1))\n", "description": "<p>This is the method used to solve the problem:&nbsp;</p>\n<p>m=0: small rectangle + triangle - circle</p>\n<p>m=1: big rectangle - triangle - circle</p>\n<p>when n is in [2,5,8,11], use method 0, becauses otherwise it would require 2 negative triangles.</p>", "templateType": "anything", "can_override": false}, "Q_rect": {"name": "Q_rect", "group": "moments of area", "definition": "area_rect[m] * vector(C_rect[m][1],C_rect[m][0])", "description": "<p>[Q_x,Q_y]</p>", "templateType": "anything", "can_override": false}, "area_rect": {"name": "area_rect", "group": "Calculated areas", "definition": "[b1*h1,if(n in [1,2,3,7,8,9],b1*(h1+ht),h1*(b1+ht))]", "description": "", "templateType": "anything", "can_override": false}, "centroid": {"name": "centroid", "group": "moments of area", "definition": "vector(Q_total[1]/area_total,Q_total[0]/area_total)", "description": "", "templateType": "anything", "can_override": false}, "Q_tri": {"name": "Q_tri", "group": "moments of area", "definition": "area_tri[m] * vector(C_tri[m][1],C_tri[m][0])", "description": "", "templateType": "anything", "can_override": false}, "Q_total": {"name": "Q_total", "group": "moments of area", "definition": "Q_rect+Q_tri+Q_circ", "description": "", "templateType": "anything", "can_override": false}, "blank_table": {"name": "blank_table", "group": "Ungrouped variables", "definition": "spreadsheet_from_base64_file(safe(\"centroid_table.xlsx\"), safe(\"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\"))", "description": "", "templateType": "spreadsheet", "can_override": false}, "params": {"name": "params", "group": "Ungrouped variables", "definition": "[ ['A',A],['b_1',b1],['h_1',h1],['h_t',ht],['n',n],['Center',center],['radius',radius]]", "description": "", "templateType": "anything", "can_override": false}, "applet": {"name": "applet", "group": "Ungrouped variables", "definition": "geogebra_applet('fcfsjuv9',params)", "description": "", "templateType": "anything", "can_override": false}, "table_add_centroids": {"name": "table_add_centroids", "group": "Ungrouped variables", "definition": "fill_range(table_add_areas, \"D2:E4\", map((x)->[siground(x[m][0],3),siground(x[m][1],3)], [C_rect,c_tri, c_circ]))", "description": "", "templateType": "anything", "can_override": false}, "table_add_areas": {"name": "table_add_areas", "group": "Ungrouped variables", "definition": "fill_range(blank_table,\"C2:C5\",map(v->siground(v[m],3), [area_rect,area_tri, area_circ])+ [precround(area_total,2)])\n", "description": "", "templateType": "anything", "can_override": false}, "table_add_q": {"name": "table_add_q", "group": "Ungrouped variables", "definition": "fill_range(table_add_centroids, \"F2:G5\",  map((x)->[siground(x[1],3),siground(x[0],3)],[Q_rect,Q_tri,Q_circ])+ [list(precround(q_total,1))])", "description": "", "templateType": "anything", "can_override": false}, "debug": {"name": "debug", "group": "Ungrouped variables", "definition": "false", "description": "", "templateType": "anything", "can_override": false}}, "variablesTest": {"condition": "// tries to prevent the circle from extending beyond the perimiter.\n\nif (n<=3,  center[1]-2*radius   > -(h1+ht/2),\nif (n<=6, (center[0]+2*radius) <  (b1+ht/2),\nif (n<=9, (center[1]+2*radius) <  (h1+ht/2),\n          (center[0]-2*radius) > -(b1-ht/2))))\n", "maxRuns": 100}, "ungrouped_variables": ["blank_table", "table_add_areas", "table_add_centroids", "table_add_q", "params", "applet", "debug"], "variable_groups": [{"name": "Input values", "variables": ["A", "b1", "h1", "ht", "center", "units", "radius", "n", "m"]}, {"name": "Calculated areas", "variables": ["area_rect", "area_tri", "area_circ", "area_total"]}, {"name": "centroids", "variables": ["C_rect", "C_circ", "C_tri"]}, {"name": "moments of area", "variables": ["Q_rect", "Q_tri", "Q_circ", "Q_total", "centroid"]}], "functions": {}, "preamble": {"js": "\n", "css": "table.centroid{margin:auto;}\n\ntable.centroid td {\n  width:6em; \n  vertical-align:center; \n  text-align:center;}\ntable.centroid *.underline {border-bottom: 2px solid black;}\n\n"}, "parts": [{"type": "spreadsheet", "useCustomName": true, "customName": "Centroid Table", "marks": "36", "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": true, "showFeedbackIcon": true, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "settings": {"initial_sheet": "blank_table", "correct_answer": "table_add_q", "disable_ranges": "[\"A1:B5\", \"A1:G1\", \"D5:E5\"]", "mark_ranges": "[\"$A_i$\": \"C2:C4\", \"$\\\\bar{x}_i$\": \"D2:D4\", \"$\\\\bar{y}_i$\": \"E2:E4\",\"$A_i\\\\bar{x}_i$\": \"F2:F4\", \"$A_i\\\\bar{y}_i$\": \"G2:G4\", \"$A$\": \"C5\", \"$Q_y$\": \"F5\",\"$Q_x$\": \"G5\"]", "marking_method": "per_cell", "tolerance": "0.05"}}, {"type": "gapfill", "useCustomName": true, "customName": "Centroid", "marks": 0, "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": true, "showFeedbackIcon": true, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "prompt": "<p style=\"padding-left: 40px;\">$\\bar{x} =\\dfrac{Q_y}{A} = $ [[0]]</p>\n<p style=\"padding-left: 40px;\">$\\bar{y} =\\dfrac{Q_x}{A} = $ [[1]]<br/><br/></p>", "gaps": [{"type": "engineering-answer", "useCustomName": true, "customName": "xbar", "marks": "2", "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": true, "showFeedbackIcon": true, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "settings": {"correctAnswer": "qty(siground(centroid[0],3),units)", "right": "0.2", "close": "1.0", "C1": "75", "C2": "50", "C3": "25"}}, {"type": "engineering-answer", "useCustomName": true, "customName": "ybar", "marks": "2", "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": true, "showFeedbackIcon": true, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "settings": {"correctAnswer": "siground(quantity(centroid[1],units),3)", "right": "0.2", "close": "1.0", "C1": "75", "C2": "50", "C3": "25"}}], "sortAnswers": false}], "partsMode": "all", "maxMarks": 0, "objectives": [], "penalties": [], "objectiveVisibility": "always", "penaltyVisibility": "always", "contributors": [{"name": "William Haynes", "profile_url": "https://numbas.mathcentre.ac.uk/accounts/profile/2530/"}], "resources": []}]}], "contributors": [{"name": "William Haynes", "profile_url": "https://numbas.mathcentre.ac.uk/accounts/profile/2530/"}]}