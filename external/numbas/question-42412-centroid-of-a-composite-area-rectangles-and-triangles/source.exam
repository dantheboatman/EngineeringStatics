// Numbas version: finer_feedback_settings
{"name": "Centroid of a composite area: rectangles and triangles", "extensions": ["geogebra", "sheets", "quantities"], "custom_part_types": [{"source": {"pk": 19, "author": {"name": "William Haynes", "pk": 2530}, "edit_page": "/part_type/19/edit"}, "name": "Engineering Accuracy with units", "short_name": "engineering-answer", "description": "<p>A value with units marked right if within an adjustable % error of the correct value. &nbsp;Marked close if within a wider margin of error.</p>", "help_url": "", "input_widget": "string", "input_options": {"correctAnswer": "siground(settings['correctAnswer'],4)", "hint": {"static": true, "value": ""}, "allowEmpty": {"static": true, "value": true}}, "can_be_gap": true, "can_be_step": true, "marking_script": "mark:\nswitch( \n  right and good_units and right_sign, add_credit(1.0,'Correct.'),\n  right and good_units and not right_sign, add_credit(settings['C2'],'Wrong sign.'),\n  right and right_sign and not good_units, add_credit(settings['C2'],'Correct value, but wrong or missing units.'),\n  close and good_units, add_credit(settings['C1'],'Close.'),\n  close and not good_units, add_credit(settings['C3'],'Answer is close, but wrong or missing units.'),\n  incorrect('Wrong answer.')\n)\n\ninterpreted_answer:\nqty(student_scalar, student_units)\n\n\n\ncorrect_quantity:\nsettings[\"correctAnswer\"]\n\n\n\ncorrect_units:\nunits(correct_quantity)\n\n\nallowed_notation_styles:\n[\"plain\",\"en\"]\n\nmatch_student_number:\nmatchnumber(studentAnswer,allowed_notation_styles)\n\nstudent_scalar:\nmatch_student_number[1]\n\nstudent_units:\nreplace_regex('ohms','ohm',\n  replace_regex('\u00b0', ' deg',\n    replace_regex('-', ' ' ,\n      studentAnswer[len(match_student_number[0])..len(studentAnswer)])),\"i\")\n\ngood_units:\ntry(\ncompatible(quantity(1, student_units),correct_units),\nmsg,\nfeedback(msg);false)\n\n\nstudent_quantity:\nswitch(not good_units, \n       student_scalar * correct_units, \n       not right_sign,\n       -quantity(student_scalar, student_units),\n       quantity(student_scalar,student_units)\n)\n  \n\n\npercent_error:\ntry(\nscalar(abs((correct_quantity - student_quantity)/correct_quantity))*100  \n,msg,\nif(student_quantity=correct_quantity,0,100))\n   \n\nright:\npercent_error <= settings['right']\n\n\nclose:\nright_sign and percent_error <= settings['close']\n\nright_sign:\nsign(student_scalar) = sign(correct_quantity)", "marking_notes": [{"name": "mark", "description": "This is the main marking note. It should award credit and provide feedback based on the student's answer.", "definition": "switch( \n  right and good_units and right_sign, add_credit(1.0,'Correct.'),\n  right and good_units and not right_sign, add_credit(settings['C2'],'Wrong sign.'),\n  right and right_sign and not good_units, add_credit(settings['C2'],'Correct value, but wrong or missing units.'),\n  close and good_units, add_credit(settings['C1'],'Close.'),\n  close and not good_units, add_credit(settings['C3'],'Answer is close, but wrong or missing units.'),\n  incorrect('Wrong answer.')\n)"}, {"name": "interpreted_answer", "description": "A value representing the student's answer to this part.", "definition": "qty(student_scalar, student_units)\n\n"}, {"name": "correct_quantity", "description": "", "definition": "settings[\"correctAnswer\"]\n\n"}, {"name": "correct_units", "description": "", "definition": "units(correct_quantity)\n"}, {"name": "allowed_notation_styles", "description": "", "definition": "[\"plain\",\"en\"]"}, {"name": "match_student_number", "description": "", "definition": "matchnumber(studentAnswer,allowed_notation_styles)"}, {"name": "student_scalar", "description": "", "definition": "match_student_number[1]"}, {"name": "student_units", "description": "<p>Modify&nbsp;the&nbsp;unit portion of&nbsp;the student's answer by</p>\n<p>1. replacing \"ohms\" with \"ohm\" &nbsp;case insensitive</p>\n<p>2.&nbsp;replacing '-'&nbsp;with ' '&nbsp;</p>\n<p>3. replacing '&deg;' with ' deg'&nbsp;</p>\n<p>to allow answers like 10 ft-lb and 30&deg;</p>", "definition": "replace_regex('ohms','ohm',\n  replace_regex('\u00b0', ' deg',\n    replace_regex('-', ' ' ,\n      studentAnswer[len(match_student_number[0])..len(studentAnswer)])),\"i\")"}, {"name": "good_units", "description": "", "definition": "try(\ncompatible(quantity(1, student_units),correct_units),\nmsg,\nfeedback(msg);false)\n"}, {"name": "student_quantity", "description": "<p>This fixes the student answer for two common errors. &nbsp;</p>\n<p>If student_units are wrong&nbsp;&nbsp;- replace with correct units</p>\n<p>If student_scalar has the wrong sign - replace with right sign</p>\n<p>If student makes both errors, only one gets fixed.</p>", "definition": "switch(not good_units, \n       student_scalar * correct_units, \n       not right_sign,\n       -quantity(student_scalar, student_units),\n       quantity(student_scalar,student_units)\n)\n  \n"}, {"name": "percent_error", "description": "", "definition": "try(\nscalar(abs((correct_quantity - student_quantity)/correct_quantity))*100  \n,msg,\nif(student_quantity=correct_quantity,0,100))\n   "}, {"name": "right", "description": "", "definition": "percent_error <= settings['right']\n"}, {"name": "close", "description": "<p>Only marked close if the student actually has the right sign.</p>", "definition": "right_sign and percent_error <= settings['close']"}, {"name": "right_sign", "description": "", "definition": "sign(student_scalar) = sign(correct_quantity) "}], "settings": [{"name": "correctAnswer", "label": "Correct Quantity.", "help_url": "", "hint": "The correct answer given as a JME quantity.", "input_type": "code", "default_value": "", "evaluate": true}, {"name": "right", "label": "% Accuracy for right.", "help_url": "", "hint": "Question will be considered correct if the scalar part of the student's answer is within this % of correct value.", "input_type": "code", "default_value": "0.2", "evaluate": true}, {"name": "close", "label": "% Accuracy for close.", "help_url": "", "hint": "Question will be considered close if the scalar part of the student's answer is within this % of correct value.", "input_type": "code", "default_value": "1.0", "evaluate": true}, {"name": "C1", "label": "Close with units.", "help_url": "", "hint": "Partial Credit for close value with appropriate units. &nbsp;if correct answer is 100 N and close is &plusmn;1%,<br />99 &nbsp;N is accepted.", "input_type": "percent", "default_value": "75"}, {"name": "C2", "label": "No units or wrong sign", "help_url": "", "hint": "Partial credit for forgetting units or using wrong sign.<br />If the correct answer is 100 N, both 100 and -100 N are accepted.", "input_type": "percent", "default_value": "50"}, {"name": "C3", "label": "Close, no units.", "help_url": "", "hint": "Partial Credit for close value but forgotten units.<br />This value would be close&nbsp;if the expected units were provided. &nbsp;If the correct answer is 100 N, and close is &plusmn;1%,<br />99 is accepted.", "input_type": "percent", "default_value": "25"}], "public_availability": "always", "published": true, "extensions": ["quantities"]}, {"source": {"pk": 242, "author": {"name": "Christian Lawson-Perfect", "pk": 7}, "edit_page": "/part_type/242/edit"}, "name": "Spreadsheet", "short_name": "spreadsheet", "description": "<p>An editable spreadsheet. Ranges of cells can be disabled, and you can specify ranges of cells to be marked. A cell is marked correct if its value is equal to the value in the expected answer spreadsheet.</p>", "help_url": "", "input_widget": "spread-sheet", "input_options": {"correctAnswer": "settings[\"correct_answer\"]", "hint": {"static": true, "value": ""}, "initial_sheet": {"static": false, "value": "disable_cells(settings[\"initial_sheet\"], settings[\"disable_ranges\"])"}}, "can_be_gap": true, "can_be_step": true, "marking_script": "mark:\nif(sum(mark_ranges)=0,\n  incorrect(),\n  apply(mark_ranges)\n)\n\ninterpreted_answer:\nstudentAnswer\n\nrange_cells:\nmap(parse_range(ref),ref,values(settings[\"mark_ranges\"]))\n\ntotal_cells:\nlen(flatten(range_cells))\n\nrange_weights:\nswitch(\n  settings[\"marking_method\"]=\"per_cell\",\n    map(len(r)/total_cells, r, range_cells),\n  // otherwise, mark per range\n    repeat(1/len(range_cells), len(range_cells))\n)\n\nmark_ranges:\nmap(\n  let(\n    range_credit,\n      sum(map(\n        let(\n          correctCellString, correctAnswer[c],\n          correctCellNumber, parsenumber(correctCellString, notation_styles),\n          studentCellString, studentAnswer[c],\n          studentCellNumber, parsenumber(studentCellString, notation_styles),\n          award(\n            1/len(cells), \n            switch(\n              correctCellString=\"\",\n                isnan(studentCellNumber) or studentCellString=\"\",\n              isnan(correctCellNumber),\n                lower(correctCellString) = lower(studentCellString)\n              ,\n                abs(studentCellNumber - if(isnan(correctCellNumber),0,correctCellNumber)) <= settings[\"tolerance\"]\n            )\n          )\n        ),\n        c,\n        cells\n      )),\n    message,\n      switch(\n        range_credit=0,\n          if(len(cells)=1, \"This entry is incorrect.\", \"All entries in this range are incorrect.\"),\n        range_credit=1,\n          if(len(cells)=1, \"This entry is correct.\", \"All entries in this range are correct.\"),\n        //otherwise\n          \"Some entries in this range are correct.\"\n      ),\n    assert(len(cells)=0, add_credit(range_credit*w, \"<strong>{name}:</strong> \"+message)); \n    range_credit\n  ),\n  [cells,w,name],\n  zip(range_cells, range_weights, keys(settings[\"mark_ranges\"]))\n)\n\nnotation_styles:\n[\"plain\",\"si-en\"]\n\ncorrectAnswer:\nsettings[\"correct_answer\"]", "marking_notes": [{"name": "mark", "description": "This is the main marking note. It should award credit and provide feedback based on the student's answer.", "definition": "if(sum(mark_ranges)=0,\n  incorrect(),\n  apply(mark_ranges)\n)"}, {"name": "interpreted_answer", "description": "A value representing the student's answer to this part.", "definition": "studentAnswer"}, {"name": "range_cells", "description": "<p>For each range to be marked, the addresses of the cells in that range.</p>", "definition": "map(parse_range(ref),ref,values(settings[\"mark_ranges\"]))"}, {"name": "total_cells", "description": "<p>The total number of cells to be marked. Cells in overlapping ranges will be counted once for each range they're in.</p>", "definition": "len(flatten(range_cells))"}, {"name": "range_weights", "description": "<p>The weight of each range, as a proportion of the available credit.</p>", "definition": "switch(\n  settings[\"marking_method\"]=\"per_cell\",\n    map(len(r)/total_cells, r, range_cells),\n  // otherwise, mark per range\n    repeat(1/len(range_cells), len(range_cells))\n)"}, {"name": "mark_ranges", "description": "<p>Mark each of the ranges specified by the question author.</p>", "definition": "map(\n  let(\n    range_credit,\n      sum(map(\n        let(\n          correctCellString, correctAnswer[c],\n          correctCellNumber, parsenumber(correctCellString, notation_styles),\n          studentCellString, studentAnswer[c],\n          studentCellNumber, parsenumber(studentCellString, notation_styles),\n          award(\n            1/len(cells), \n            switch(\n              correctCellString=\"\",\n                isnan(studentCellNumber) or studentCellString=\"\",\n              isnan(correctCellNumber),\n                lower(correctCellString) = lower(studentCellString)\n              ,\n                abs(studentCellNumber - if(isnan(correctCellNumber),0,correctCellNumber)) <= settings[\"tolerance\"]\n            )\n          )\n        ),\n        c,\n        cells\n      )),\n    message,\n      switch(\n        range_credit=0,\n          if(len(cells)=1, \"This entry is incorrect.\", \"All entries in this range are incorrect.\"),\n        range_credit=1,\n          if(len(cells)=1, \"This entry is correct.\", \"All entries in this range are correct.\"),\n        //otherwise\n          \"Some entries in this range are correct.\"\n      ),\n    assert(len(cells)=0, add_credit(range_credit*w, \"<strong>{name}:</strong> \"+message)); \n    range_credit\n  ),\n  [cells,w,name],\n  zip(range_cells, range_weights, keys(settings[\"mark_ranges\"]))\n)"}, {"name": "notation_styles", "description": "<p>Accepted number notation styles for a value in an individual cell.</p>", "definition": "[\"plain\",\"si-en\"]"}, {"name": "correctAnswer", "description": "", "definition": "settings[\"correct_answer\"]"}], "settings": [{"name": "initial_sheet", "label": "Initial sheet", "help_url": "", "hint": "A <code>spreadsheet</code> object giving the initial state of the sheet that the student should fill in.", "input_type": "code", "default_value": "", "evaluate": true}, {"name": "correct_answer", "label": "Correct answer", "help_url": "", "hint": "A <code>spreadsheet</code> object representing a correct answer to the part.", "input_type": "code", "default_value": "", "evaluate": true}, {"name": "disable_ranges", "label": "Ranges to disable", "help_url": "", "hint": "A list of cell or range references, denoting the cells that should not be editable.", "input_type": "code", "default_value": "[]", "evaluate": true}, {"name": "mark_ranges", "label": "Ranges to mark", "help_url": "", "hint": "A dictionary of cell or range references, mapping names to ranges of cells, denoting the cells that should be compared for equality with the expected answer.", "input_type": "code", "default_value": "dict()", "evaluate": true}, {"name": "marking_method", "label": "Marking method", "help_url": "", "hint": "", "input_type": "dropdown", "default_value": "per_cell", "choices": [{"value": "per_cell", "label": "Each cell has the same weight"}, {"value": "per_range", "label": "Each range has the same weight"}]}, {"name": "tolerance", "label": "Allowed margin of error", "help_url": "", "hint": "", "input_type": "code", "default_value": "0", "evaluate": true}], "public_availability": "always", "published": true, "extensions": ["sheets"]}], "resources": [["question-resources/centroid-t-r.ggb", "centroid-t-r.ggb"]], "navigation": {"allowregen": true, "showfrontpage": false, "preventleave": false, "typeendtoleave": false}, "question_groups": [{"pickingStrategy": "all-ordered", "questions": [{"name": "Centroid of a composite area: rectangles and triangles", "tags": ["centroids", "first moment of area", "mechanics", "Mechanics", "statics", "Statics"], "metadata": {"description": "<p>Find the centroid of a shape made up of a rectangle and two triangles.</p>", "licence": "Creative Commons Attribution-NonCommercial 4.0 International"}, "statement": "<p>Determine the coordinates of the centroid of a polygon made up of a ({b0} $\\times$ {h0}) rectangle, {if(sign1='+', 'plus', 'minus')} a ({b1} $\\times$ {h1}) triangle, {if(sign2='+', 'plus', 'minus')} a ({b2} $\\times$ {h2}) triangle. &nbsp;Length units are [{units}].</p>\n<table style=\"margin-left: auto; margin-right: auto;\">\n<tbody>\n<tr>\n<td>{applet()}</td>\n</tr>\n</tbody>\n</table>\n<p><span data-jme-visible=\"debug\">{answer_sheet}</span></p>", "advice": "<div>\n<p>$\\qquad\\bar{x} = \\dfrac{Q_y}{A} = &nbsp;\\dfrac{\\Sigma A_i\\bar{x}_i}{\\Sigma A_i}= &nbsp; \\dfrac{\\var{siground(QT[0],4)}}{\\var{AT}} &nbsp;=\\var{display(xbar)}$</p>\n<p>$\\qquad \\bar{y} = \\dfrac{Q_x}{A} = &nbsp;\\dfrac{\\Sigma A_i \\bar{y}_i}{\\Sigma A_i}= &nbsp;\\dfrac{\\var{siground(QT[1],4)}}{\\var{AT}} &nbsp;=\\var{display(ybar)}$</p>\n</div>", "rulesets": {}, "extensions": ["geogebra", "quantities", "sheets"], "builtin_constants": {"e": true, "pi,\u03c0": true, "i": true, "j": false}, "constants": [], "variables": {"A": {"name": "A", "group": "Ungrouped variables", "definition": "vector(0,random(2..12))", "description": "", "templateType": "anything", "can_override": false}, "C2": {"name": "C2", "group": "geometry", "definition": "vector(A[0],B[1])+(vector(B[0],A[1])-vector(A[0],B[1]))/3  ", "description": "", "templateType": "anything", "can_override": false}, "A0": {"name": "A0", "group": "geometry", "definition": "b0 h0", "description": "", "templateType": "anything", "can_override": false}, "A2": {"name": "A2", "group": "geometry", "definition": "b2 h2/2 if(sign2='+',1,-1)", "description": "", "templateType": "anything", "can_override": false}, "b0": {"name": "b0", "group": "geometry", "definition": "B[0]", "description": "", "templateType": "anything", "can_override": false}, "C": {"name": "C", "group": "Ungrouped variables", "definition": "vector(random(2..12),0)", "description": "", "templateType": "anything", "can_override": false}, "b2": {"name": "b2", "group": "geometry", "definition": "b0", "description": "", "templateType": "anything", "can_override": false}, "C1": {"name": "C1", "group": "geometry", "definition": "vector(B[0],C[1])+(vector(C[0],B[1])-vector(B[0],C[1]))/3  ", "description": "", "templateType": "anything", "can_override": false}, "A1": {"name": "A1", "group": "geometry", "definition": "b1 h1 /2 if(sign1='+',1,-1)", "description": "", "templateType": "anything", "can_override": false}, "ybar": {"name": "ybar", "group": "Unnamed group", "definition": "(a0 c0[1] + a1 c1[1] + a2 c2[1])/AT qty(1,units)", "description": "", "templateType": "anything", "can_override": false}, "h1": {"name": "h1", "group": "geometry", "definition": "h0", "description": "", "templateType": "anything", "can_override": false}, "B": {"name": "B", "group": "Ungrouped variables", "definition": "vector(random(2..12),random(2..12))", "description": "", "templateType": "anything", "can_override": false}, "h0": {"name": "h0", "group": "geometry", "definition": "B[1]", "description": "", "templateType": "anything", "can_override": false}, "sign2": {"name": "sign2", "group": "geometry", "definition": "if(b[1]<a[1],'+','-')", "description": "", "templateType": "anything", "can_override": false}, "C0": {"name": "C0", "group": "geometry", "definition": "(B/2)", "description": "", "templateType": "anything", "can_override": false}, "AT": {"name": "AT", "group": "geometry", "definition": "A0+A1+A2", "description": "", "templateType": "anything", "can_override": false}, "h2": {"name": "h2", "group": "geometry", "definition": "abs(b[1]-A[1])", "description": "", "templateType": "anything", "can_override": false}, "xbar": {"name": "xbar", "group": "Unnamed group", "definition": "(a0 c0[0] + a1 c1[0] + a2 c2[0])/AT qty(1,units)", "description": "", "templateType": "anything", "can_override": false}, "b1": {"name": "b1", "group": "geometry", "definition": "abs(b[0]-c[0])", "description": "", "templateType": "anything", "can_override": false}, "units": {"name": "units", "group": "Ungrouped variables", "definition": "random('in','cm','ft','m')", "description": "", "templateType": "anything", "can_override": false}, "sign1": {"name": "sign1", "group": "geometry", "definition": "if(b[0]<c[0],'+','-')", "description": "", "templateType": "anything", "can_override": false}, "debug": {"name": "debug", "group": "Ungrouped variables", "definition": "false", "description": "", "templateType": "anything", "can_override": false}, "D": {"name": "D", "group": "Ungrouped variables", "definition": "vector(0,0)", "description": "", "templateType": "anything", "can_override": false}, "blank_sheet": {"name": "blank_sheet", "group": "Ungrouped variables", "definition": "spreadsheet_from_base64_file(safe(\"centroid_table.xlsx\"), safe(\"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\"))", "description": "", "templateType": "spreadsheet", "can_override": false}, "areas_sheet": {"name": "areas_sheet", "group": "Ungrouped variables", "definition": "fill_range(blank_sheet,\"B2:B5\", [a0,a1,a2,at])", "description": "", "templateType": "anything", "can_override": false}, "centroids_sheet": {"name": "centroids_sheet", "group": "Ungrouped variables", "definition": "fill_range(areas_sheet, \"C2:D4\", map(v-> [siground(v[0],4), siground(v[1],4)], [C0,C1,C2]))", "description": "", "templateType": "anything", "can_override": false}, "Q0": {"name": "Q0", "group": "geometry", "definition": "a0 c0", "description": "<p>[ai xbari, ai ybari]</p>", "templateType": "anything", "can_override": false}, "Q1": {"name": "Q1", "group": "geometry", "definition": "a1 c1", "description": "", "templateType": "anything", "can_override": false}, "Q2": {"name": "Q2", "group": "geometry", "definition": "a2 c2", "description": "", "templateType": "anything", "can_override": false}, "QT": {"name": "QT", "group": "geometry", "definition": "Q0+Q1+Q2", "description": "", "templateType": "anything", "can_override": false}, "answer_sheet": {"name": "answer_sheet", "group": "Ungrouped variables", "definition": "fill_range(centroids_sheet,\"E2:F5\",map(v->[siground(v[0],4),siground(v[1],4)],[Q0,Q1,Q2,QT]))", "description": "", "templateType": "anything", "can_override": false}, "xbar2": {"name": "xbar2", "group": "Unnamed group", "definition": "Qt[0]/(At)", "description": "", "templateType": "anything", "can_override": false}}, "variablesTest": {"condition": "B[1]<>A[1] and B[0]<>C[0]", "maxRuns": "100"}, "ungrouped_variables": ["A", "B", "C", "D", "units", "debug", "blank_sheet", "areas_sheet", "centroids_sheet", "answer_sheet"], "variable_groups": [{"name": "geometry", "variables": ["b0", "h0", "b2", "h1", "b1", "h2", "sign1", "sign2", "A0", "A1", "A2", "AT", "C0", "C2", "C1", "Q0", "Q1", "Q2", "QT"]}, {"name": "Unnamed group", "variables": ["xbar", "ybar", "xbar2"]}], "functions": {"Q": {"parameters": [["area", "?"], ["distance", "?"]], "type": "quantity", "language": "jme", "definition": "display(area*distance*qty(1,units)*qty(1,units)*qty(1,units))"}, "display": {"parameters": [["q", "quantity"]], "type": "quantity", "language": "jme", "definition": "string(siground(q,4))"}, "bar": {"parameters": [["coord", "number"]], "type": "quantity", "language": "jme", "definition": "display(quantity(coord,units))"}, "applet": {"parameters": [], "type": "ggbapplet", "language": "javascript", "definition": "\n// Create the worksheet. \n// This function returns an object with a container `element` and a `promise` resolving to a GeoGebra applet.\nvar params = {\n  material_id: 'ftkm8mfx',\n  //alternate method, load from file.\n  //filename: \"resources/question-resources/centroid-t-r.ggb\",\n  //width:400,\n  //height:300\n  // was geogebra_applet('ftkm8mfx',[['A',A],['B',B],['C',C]])\n}\n\nvar result = Numbas.extensions.geogebra.createGeogebraApplet(params);\n\n// Once the applet has loaded, run some commands to manipulate the worksheet.\nresult.promise.then(function(d) {\n  var app = d.app;\n  question.applet = d;\n  \n  \nfunction setGGBPoint(name) {\n    // moves point in GGB to location of Numbas Vector Variable\n    var pt = question.scope.evaluate(name).value\n    app.setFixed(name,false,false);\n    app.setCoords(name, pt[0], pt[1]);\n    app.setFixed(name,true,true);\n  }\n\n  setGGBPoint(\"A\");\n  setGGBPoint(\"B\");\n  setGGBPoint(\"C\");\n  setGGBPoint(\"D\");\n  app.setVisible(\"Centroid\",false);\n  \n});\n\n// This function returns the result of `createGeogebraApplet` as an object \n// with the JME data type 'ggbapplet', which can be substituted into the question's content.\nreturn new Numbas.jme.types.ggbapplet(result);"}}, "preamble": {"js": "question.signals.on('adviceDisplayed',function() {\n   try{\n    var app = question.applet.app;\n \n  app.setVisible(\"Centroid\",true);\n  \n  }\n  catch(err){}  \n})\n\n\n\n", "css": "table.centroid{margin-left:0;}\n\ntable.centroid td {\n  width:6em; \n  vertical-align:center; \n  text-align:center;}\ntable.centroid *.underline {border-bottom: 2px solid black;}\n\n"}, "parts": [{"type": "spreadsheet", "useCustomName": true, "customName": "Centroid Table", "marks": "36", "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": true, "showFeedbackIcon": true, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "settings": {"initial_sheet": "blank_sheet", "correct_answer": "answer_sheet", "disable_ranges": "[\"A1:F1\", \"A1:A5\", \"C5:D5\"]", "mark_ranges": "[\"$A_i$\": \"B2:B4\", \"$\\\\bar{x}$\": \"C2:C4\", \"$\\\\bar{y}$\": \"D2:D4\", \"$A_i\\\\bar{x}_i$\": \"E2:E4\", \"$A_i\\\\bar{y}_i$\": \"F2:F4\",\"$A$\":\"B5\", \"$Q_y$\": \"E5\", \"$Q_x$\":\"F5\"]", "marking_method": "per_cell", "tolerance": "0.05"}}, {"type": "gapfill", "useCustomName": true, "customName": "Results", "marks": 0, "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": true, "showFeedbackIcon": true, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "prompt": "<p>$\\bar{x} =\\dfrac{Q_y}{A} = $&nbsp;[[0]]&nbsp;</p>\n<p>$\\bar{y} =\\dfrac{Q_x}{A} = $ [[1]]</p>", "gaps": [{"type": "engineering-answer", "useCustomName": true, "customName": "$\\bar{x}$", "marks": "2", "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": true, "showFeedbackIcon": true, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "settings": {"correctAnswer": "xbar", "right": "0.2", "close": "1.0", "C1": "75", "C2": "50", "C3": "25"}}, {"type": "engineering-answer", "useCustomName": true, "customName": "$\\bar{y}$", "marks": "2", "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": true, "showFeedbackIcon": true, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "settings": {"correctAnswer": "ybar", "right": "0.2", "close": "1.0", "C1": "75", "C2": "50", "C3": "25"}}], "sortAnswers": false}], "partsMode": "all", "maxMarks": 0, "objectives": [], "penalties": [], "objectiveVisibility": "always", "penaltyVisibility": "always", "contributors": [{"name": "Christian Lawson-Perfect", "profile_url": "https://numbas.mathcentre.ac.uk/accounts/profile/7/"}, {"name": "William Haynes", "profile_url": "https://numbas.mathcentre.ac.uk/accounts/profile/2530/"}], "resources": ["question-resources/centroid-t-r.ggb"]}]}], "contributors": [{"name": "Christian Lawson-Perfect", "profile_url": "https://numbas.mathcentre.ac.uk/accounts/profile/7/"}, {"name": "William Haynes", "profile_url": "https://numbas.mathcentre.ac.uk/accounts/profile/2530/"}]}