// Numbas version: finer_feedback_settings
{"name": "Chapter 8 Exercises", "metadata": {"description": "<p>End of chapter exercises for <a href=\"http://engineeringstatics.org\"><em>Engineering Statics: Open and Interactive</em></a>&nbsp;</p>", "licence": "Creative Commons Attribution-NonCommercial 4.0 International"}, "duration": 0, "percentPass": 0, "showQuestionGroupNames": true, "shuffleQuestionGroups": false, "showstudentname": true, "question_groups": [{"name": "Internal Forces", "pickingStrategy": "all-ordered", "pickQuestions": 1, "questionNames": ["Distributed load V, M", "Distributed load V, P, M"], "variable_overrides": [[], []], "questions": [{"name": "Internal force: Overhanging beam", "extensions": ["geogebra", "jsxgraph", "quantities", "shear-and-bending-moment-diagrams"], "custom_part_types": [{"source": {"pk": 19, "author": {"name": "William Haynes", "pk": 2530}, "edit_page": "/part_type/19/edit"}, "name": "Engineering Accuracy with units", "short_name": "engineering-answer", "description": "<p>A value with units marked right if within an adjustable % error of the correct value. &nbsp;Marked close if within a wider margin of error.</p>", "help_url": "", "input_widget": "string", "input_options": {"correctAnswer": "siground(settings['correctAnswer'],4)", "hint": {"static": true, "value": ""}, "allowEmpty": {"static": true, "value": true}}, "can_be_gap": true, "can_be_step": true, "marking_script": "mark:\nswitch( \n  right and good_units and right_sign, add_credit(1.0,'Correct.'),\n  right and good_units and not right_sign, add_credit(settings['C2'],'Wrong sign.'),\n  right and right_sign and not good_units, add_credit(settings['C2'],'Correct value, but wrong or missing units.'),\n  close and good_units, add_credit(settings['C1'],'Close.'),\n  close and not good_units, add_credit(settings['C3'],'Answer is close, but wrong or missing units.'),\n  incorrect('Wrong answer.')\n)\n\ninterpreted_answer:\nqty(student_scalar, student_units)\n\n\n\ncorrect_quantity:\nsettings[\"correctAnswer\"]\n\n\n\ncorrect_units:\nunits(correct_quantity)\n\n\nallowed_notation_styles:\n[\"plain\",\"en\"]\n\nmatch_student_number:\nmatchnumber(studentAnswer,allowed_notation_styles)\n\nstudent_scalar:\nmatch_student_number[1]\n\nstudent_units:\nreplace_regex('ohms','ohm',\n  replace_regex('\u00b0', ' deg',\n    replace_regex('-', ' ' ,\n      studentAnswer[len(match_student_number[0])..len(studentAnswer)])),\"i\")\n\ngood_units:\ntry(\ncompatible(quantity(1, student_units),correct_units),\nmsg,\nfeedback(msg);false)\n\n\nstudent_quantity:\nswitch(not good_units, \n       student_scalar * correct_units, \n       not right_sign,\n       -quantity(student_scalar, student_units),\n       quantity(student_scalar,student_units)\n)\n  \n\n\npercent_error:\ntry(\nscalar(abs((correct_quantity - student_quantity)/correct_quantity))*100  \n,msg,\nif(student_quantity=correct_quantity,0,100))\n   \n\nright:\npercent_error <= settings['right']\n\n\nclose:\nright_sign and percent_error <= settings['close']\n\nright_sign:\nsign(student_scalar) = sign(correct_quantity)", "marking_notes": [{"name": "mark", "description": "This is the main marking note. It should award credit and provide feedback based on the student's answer.", "definition": "switch( \n  right and good_units and right_sign, add_credit(1.0,'Correct.'),\n  right and good_units and not right_sign, add_credit(settings['C2'],'Wrong sign.'),\n  right and right_sign and not good_units, add_credit(settings['C2'],'Correct value, but wrong or missing units.'),\n  close and good_units, add_credit(settings['C1'],'Close.'),\n  close and not good_units, add_credit(settings['C3'],'Answer is close, but wrong or missing units.'),\n  incorrect('Wrong answer.')\n)"}, {"name": "interpreted_answer", "description": "A value representing the student's answer to this part.", "definition": "qty(student_scalar, student_units)\n\n"}, {"name": "correct_quantity", "description": "", "definition": "settings[\"correctAnswer\"]\n\n"}, {"name": "correct_units", "description": "", "definition": "units(correct_quantity)\n"}, {"name": "allowed_notation_styles", "description": "", "definition": "[\"plain\",\"en\"]"}, {"name": "match_student_number", "description": "", "definition": "matchnumber(studentAnswer,allowed_notation_styles)"}, {"name": "student_scalar", "description": "", "definition": "match_student_number[1]"}, {"name": "student_units", "description": "<p>Modify&nbsp;the&nbsp;unit portion of&nbsp;the student's answer by</p>\n<p>1. replacing \"ohms\" with \"ohm\" &nbsp;case insensitive</p>\n<p>2.&nbsp;replacing '-'&nbsp;with ' '&nbsp;</p>\n<p>3. replacing '&deg;' with ' deg'&nbsp;</p>\n<p>to allow answers like 10 ft-lb and 30&deg;</p>", "definition": "replace_regex('ohms','ohm',\n  replace_regex('\u00b0', ' deg',\n    replace_regex('-', ' ' ,\n      studentAnswer[len(match_student_number[0])..len(studentAnswer)])),\"i\")"}, {"name": "good_units", "description": "", "definition": "try(\ncompatible(quantity(1, student_units),correct_units),\nmsg,\nfeedback(msg);false)\n"}, {"name": "student_quantity", "description": "<p>This fixes the student answer for two common errors. &nbsp;</p>\n<p>If student_units are wrong&nbsp;&nbsp;- replace with correct units</p>\n<p>If student_scalar has the wrong sign - replace with right sign</p>\n<p>If student makes both errors, only one gets fixed.</p>", "definition": "switch(not good_units, \n       student_scalar * correct_units, \n       not right_sign,\n       -quantity(student_scalar, student_units),\n       quantity(student_scalar,student_units)\n)\n  \n"}, {"name": "percent_error", "description": "", "definition": "try(\nscalar(abs((correct_quantity - student_quantity)/correct_quantity))*100  \n,msg,\nif(student_quantity=correct_quantity,0,100))\n   "}, {"name": "right", "description": "", "definition": "percent_error <= settings['right']\n"}, {"name": "close", "description": "<p>Only marked close if the student actually has the right sign.</p>", "definition": "right_sign and percent_error <= settings['close']"}, {"name": "right_sign", "description": "", "definition": "sign(student_scalar) = sign(correct_quantity) "}], "settings": [{"name": "correctAnswer", "label": "Correct Quantity.", "help_url": "", "hint": "The correct answer given as a JME quantity.", "input_type": "code", "default_value": "", "evaluate": true}, {"name": "right", "label": "% Accuracy for right.", "help_url": "", "hint": "Question will be considered correct if the scalar part of the student's answer is within this % of correct value.", "input_type": "code", "default_value": "0.2", "evaluate": true}, {"name": "close", "label": "% Accuracy for close.", "help_url": "", "hint": "Question will be considered close if the scalar part of the student's answer is within this % of correct value.", "input_type": "code", "default_value": "1.0", "evaluate": true}, {"name": "C1", "label": "Close with units.", "help_url": "", "hint": "Partial Credit for close value with appropriate units. &nbsp;if correct answer is 100 N and close is &plusmn;1%,<br />99 &nbsp;N is accepted.", "input_type": "percent", "default_value": "75"}, {"name": "C2", "label": "No units or wrong sign", "help_url": "", "hint": "Partial credit for forgetting units or using wrong sign.<br />If the correct answer is 100 N, both 100 and -100 N are accepted.", "input_type": "percent", "default_value": "50"}, {"name": "C3", "label": "Close, no units.", "help_url": "", "hint": "Partial Credit for close value but forgotten units.<br />This value would be close&nbsp;if the expected units were provided. &nbsp;If the correct answer is 100 N, and close is &plusmn;1%,<br />99 is accepted.", "input_type": "percent", "default_value": "25"}], "public_availability": "always", "published": true, "extensions": ["quantities"]}], "resources": [], "navigation": {"allowregen": true, "showfrontpage": false, "preventleave": false, "typeendtoleave": false}, "contributors": [{"name": "William Haynes", "profile_url": "https://numbas.mathcentre.ac.uk/accounts/profile/2530/"}], "tags": ["bending moment", "distributed load", "internal forces", "Mechanics", "mechanics", "shear", "Statics", "statics"], "metadata": {"description": "<p>Calculate reactions and shear and bending moment at a point for&nbsp;an overhanging beam with a constant&nbsp;or uniformly varying distributed load.</p>", "licence": "Creative Commons Attribution-NonCommercial 4.0 International"}, "statement": "<p>{loadDiagram}</p>\n<p style=\"padding: 3px;\">The $\\var{distance(L)}$ beam shown supports a load that varies uniformly from $\\var{load(Wa)}$ at the left end to $\\var{load(Wb)}$ at the right end. Point $C$ is located at $x =\\var{distance(C)}$.</p>\n<ul></ul>", "advice": "<p><strong>1. &nbsp;Replace the distributed load with an equivalent concentrated load and draw a free-body diagram of the entire beam.</strong></p>\n<p>{fbd1}</p>\n<p>Recall that the equivalent force of a distributed load is the 'area' and it acts at the centroid of the shaded area above.</p>\n<p>\\[ W = \\var{force(W)},\\qquad &nbsp; &nbsp; &nbsp;\\bar{x}=\\var{distance(xbarW)}\\]</p>\n<p><strong>2. &nbsp;Apply equilibrium equations to find the reactions at $A$ and $B$.</strong></p>\n<p>\\[\\begin{align} \\Sigma M_A &amp;= 0 &amp; &nbsp;\\Sigma F_y &amp;=0 \\\\<br/>R_B\\cdot \\var{distance(B)} &amp;= &nbsp;W \\cdot \\bar{x} &amp; &nbsp;R_A + R_B &amp;= \\var{W}\\\\<br/>R_B &amp;= \\var{force(R_B)} \\uparrow &amp; R_A &amp;= \\var{force(abs(R_A))} &nbsp;\\var{if(R_A&gt;0,latex('\\\\uparrow'),latex('\\\\downarrow'))}\\end{align}\\]</p>\n<p><strong>3. Take an imaginary cut at point $C$, and draw a FBD of the portion of the beam &nbsp;to the left of $C$ and use it to find the shear and bending moment at the cut.</strong></p>\n<p>{fbd2}</p>\n<p style=\"padding-left: 30px;\"><strong>a. &nbsp;Use similar triangles to find $w_C$, &nbsp;the distributed load at point $C$.</strong></p>\n<p style=\"padding-left: 60px;\">Knowing $w_A = \\var{load(wA)} $, $w_B = \\var{load(wB)} $.</p>\n<p style=\"padding-left: 60px;\">\\[ \\begin{align}<br/>\\dfrac{w_C -w_A}{\\var{distance(C)}} &amp;= \\dfrac{w_B-w_A}{\\var{distance(L)}}\\\\<br/>&nbsp;w_C &amp;= w_A + \\left(\\var{siground(c/L,4)} \\right)\\left( w_B - w_A \\right) \\\\<br/>&amp;= \\var{load(WC)}<br/>\\end{align}\\]</p>\n<p style=\"padding-left: 20px;\"><strong>b. &nbsp;Find the equivalent force due to the distributed load.</strong></p>\n<p style=\"padding-left: 20px;\">&nbsp;\\[ \\begin{align}<br/>&nbsp; W' &amp;= (\\var{distance(C)}) \\left(\\dfrac{W_A + W_C}{2}\\right) \\\\<br/>&nbsp; &nbsp; &nbsp; &amp; = \\var{force(W')}<br/>\\end{align} \\]</p>\n<p style=\"padding-left: 20px;\"><strong>c. &nbsp;Locate the centroid of the equivalent concentrated load.</strong></p>\n<p style=\"padding-left: 60px;\">\\[ \\bar{x} = \\var{force(xbarW')}\\]</p>\n<p style=\"padding-left: 20px;\"><strong>d. Apply equilibrium equations to solve for the shear and moment at $C$.</strong></p>\n<p style=\"padding-left: 60px;\">\\[\\begin{align} \\Sigma F_y &amp;=0\\\\ <br/>V_C &amp;= \\var{force(FV)} \\end{align}\\]</p>\n<p style=\"padding-left: 60px;\">\\[\\begin{align} <br/>\\Sigma M_C &amp;= 0 \\\\ <br/>M_C &nbsp;&amp; = R_A \\cdot \\var{distance(C)} - W' &nbsp;\\cdot (\\var{distance(C)} -\\bar{x}) &nbsp;\\var{if(B&lt;C,latex('+R_B \\\\cdot d_\\\\perp') ,'')} \\\\<br/>&amp;= \\left( \\var{force(R_A)}\\right) &nbsp;\\left(\\var{distance(C)}\\right) - \\left(\\var{force(W')}\\right) \\left(\\var{distance(d)}\\right) \\var{if(B&lt;C,latex('+\\\\left(\\\\var{force(R_B)}\\\\right) \\\\left(\\\\var{distance(C-B)}\\\\right)') ,'')} &nbsp; \\\\<br/>M_C &amp;= \\var{moment(M_C)} &nbsp;\\end{align}\\]</p>\n<p style=\"padding-left: 60px;\"></p>", "rulesets": {}, "builtin_constants": {"e": true, "pi,\u03c0": true, "i": true, "j": false}, "constants": [], "variables": {"L": {"name": "L", "group": "Quantities", "definition": "random(12..20#2)", "description": "<p>overall length of the beam.</p>", "templateType": "anything", "can_override": false}, "units": {"name": "units", "group": "functions", "definition": "random(['N','m', 'N*m', 'N/m'],['lb','ft', 'ft*lb', 'lb/ft'])", "description": "", "templateType": "anything", "can_override": false}, "debug": {"name": "debug", "group": "Ungrouped variables", "definition": "false", "description": "", "templateType": "anything", "can_override": false}, "FV": {"name": "FV", "group": "Unnamed group", "definition": "siground(R_A + if(B<C,R_B,0)  - W',5)", "description": "<p>shear force at C, Signed</p>", "templateType": "anything", "can_override": false}, "M_C": {"name": "M_C", "group": "Unnamed group", "definition": "siground(R_A * C - W' *(C - xbarW') + if(B<C, R_B * (C-B), 0),4) ", "description": "<p>moment at D, signed</p>\n<p>&minus;\ud835\udc34\u2113&minus;\ud835\udc4a&prime;\ud835\udc51&perp;&minus;\ud835\udc36\ud835\udc512</p>", "templateType": "anything", "can_override": false}, "C": {"name": "C", "group": "Quantities", "definition": "random(2..L#2 except[L,B])", "description": "<p>position of cut</p>", "templateType": "anything", "can_override": false}, "size": {"name": "size", "group": "Quantities", "definition": "random(50,100,200)", "description": "<p>Random load value used to make actual loads Wa and Wb.</p>", "templateType": "anything", "can_override": false}, "WC": {"name": "WC", "group": "Quantities", "definition": "WA +  (WB-WA) C / L ", "description": "<p>distributed load value at point C</p>", "templateType": "anything", "can_override": false}, "WB": {"name": "WB", "group": "Quantities", "definition": "size random(0..2#0.5)", "description": "<p>distributed load value at point A, right end.</p>", "templateType": "anything", "can_override": false}, "WA": {"name": "WA", "group": "Quantities", "definition": "size random(0..2#0.5)", "description": "<p>distributed load value at point A, left end</p>", "templateType": "anything", "can_override": false}, "d": {"name": "d", "group": "Unnamed group", "definition": "c-xbarw'", "description": "<p>distance from cut to equivalent load</p>", "templateType": "anything", "can_override": false}, "force": {"name": "force", "group": "functions", "definition": "(f)-> siground(qty(f, units[0]),4)", "description": "", "templateType": "anything", "can_override": false}, "distance": {"name": "distance", "group": "functions", "definition": "(d)->siground(qty(d,units[1]),4)", "description": "", "templateType": "anything", "can_override": false}, "load": {"name": "load", "group": "functions", "definition": "(l)->siground(qty(l,units[3]),4)", "description": "", "templateType": "anything", "can_override": false}, "properties": {"name": "properties", "group": "jsxgraph", "definition": "[beamLength: L, loads: [w1], forces: [], moments: [], reactions: [hide(RA),hide(RB)], symbols: symbols]", "description": "", "templateType": "anything", "can_override": false}, "W1": {"name": "W1", "group": "jsxgraph", "definition": "[[x: 0, value: wA, label: WA+if(WA<>WB, \" to \" + string(load(WB)) , ''), visible: true],[x: L, value: WB, label: \"D\", visible: true],]", "description": "", "templateType": "anything", "can_override": false}, "LoadDiagram": {"name": "LoadDiagram", "group": "jsxgraph", "definition": "vmloaddiagram(properties)", "description": "", "templateType": "anything", "can_override": false}, "symbols": {"name": "symbols", "group": "jsxgraph", "definition": "[[x: C, type: \"dot\", visible: true, label: \"$C$\"],[x: B, type: \"roller\", visible: true , label: \"$B$\"], [x: 0, type: 'pin', visible: true, label: \"$A$\"]]", "description": "", "templateType": "anything", "can_override": false}, "moment": {"name": "moment", "group": "functions", "definition": "(m)-> siground(qty(m, units[2]),4)", "description": "", "templateType": "anything", "can_override": false}, "B": {"name": "B", "group": "Quantities", "definition": "round(random(L/2..L))", "description": "", "templateType": "anything", "can_override": false}, "xbar": {"name": "xbar", "group": "functions", "definition": "(w) -> let (xa, w[0][\"x\"], xb, w[1][\"x\"], ya, w[0][\"value\"], yb, w[1][\"value\"] , if(xa+xb=0, 0, xa+(xb - xa)*(ya + 2 yb)/3/(ya + yb)))", "description": "", "templateType": "anything", "can_override": false}, "xbarW": {"name": "xbarW", "group": "jsxgraph", "definition": "xbar(W1)", "description": "", "templateType": "anything", "can_override": false}, "area": {"name": "area", "group": "functions", "definition": "w -> let (xa, w[0][\"x\"], xb, w[1][\"x\"], ya, w[0][\"value\"], yb, w[1][\"value\"] ,(xb-xa)(ya+yb)/2)", "description": "", "templateType": "anything", "can_override": false}, "W": {"name": "W", "group": "jsxgraph", "definition": "area(W1)", "description": "<p>equivalent force of entire load</p>", "templateType": "anything", "can_override": false}, "W1'": {"name": "W1'", "group": "Unnamed group", "definition": "[[x: 0, value: wA, label: '', visible: true],[x: C, value: WC, label: \"C\", visible: true],]", "description": "", "templateType": "anything", "can_override": false}, "xbarW'": {"name": "xbarW'", "group": "Unnamed group", "definition": "xbar(w1')", "description": "", "templateType": "anything", "can_override": false}, "W'": {"name": "W'", "group": "Unnamed group", "definition": "area(W1')", "description": "<p>equivalent force of part load</p>", "templateType": "anything", "can_override": false}, "EqW": {"name": "EqW", "group": "diagrams", "definition": "[x: xbar(w1), value: area(W1), label: \"$W$\", visible: true]", "description": "", "templateType": "anything", "can_override": false}, "EqW'": {"name": "EqW'", "group": "Unnamed group", "definition": "[x: xbarW', value: W', label: \"$W'$\", visible: true]", "description": "", "templateType": "anything", "can_override": false}, "R_A": {"name": "R_A", "group": "Quantities", "definition": "let(equivalent_loads, eqw,(sum(map(f->cross( vector(B-f[\"x\"],0,0),vector(0,-f[\"value\"],0))[2],forces+equivalent_loads))\n- sum(map(m->m['value'], moments)))/(A-B))\n", "description": "<p>Reaction at A</p>", "templateType": "anything", "can_override": false}, "check": {"name": "check", "group": "Quantities", "definition": "R_A + R_B = EqW[\"value\"]", "description": "", "templateType": "anything", "can_override": false}, "shearDiagram": {"name": "shearDiagram", "group": "jsxgraph", "definition": "vmsheardiagram(properties,debug)", "description": "", "templateType": "anything", "can_override": false}, "momentDiagram": {"name": "momentDiagram", "group": "jsxgraph", "definition": "vmmomentdiagram(properties,debug)", "description": "", "templateType": "anything", "can_override": false}, "reactions": {"name": "reactions", "group": "jsxgraph", "definition": "[[x: 0, value: R_A, label: \"$R_A$\", visible: false],[x: B, value: R_B, label: \"$R_B$\", visible: false]]", "description": "", "templateType": "anything", "can_override": false}, "forces": {"name": "forces", "group": "Ungrouped variables", "definition": "[]", "description": "", "templateType": "anything", "can_override": false}, "moments": {"name": "moments", "group": "Ungrouped variables", "definition": "[]", "description": "", "templateType": "anything", "can_override": false}, "properties_fbd1": {"name": "properties_fbd1", "group": "diagrams", "definition": "[beamLength: L, loads: [[hide(relabel(w1[0], \"\")),w1[1]]], forces: [eqw], reactions: [[x: 0, value: abs(R_A), label: \"$R_A$\", visible: true],RB], moments: [], symbols: [[x: C, type: \"dot\", visible: true, label: \"$C$\"],[x: xbarw, type: \"dot\", label: \"$\\\\bar{x}$\", visible: true]]]", "description": "", "templateType": "anything", "can_override": false}, "fbd1": {"name": "fbd1", "group": "diagrams", "definition": "vmloaddiagram(properties_fbd1)", "description": "", "templateType": "anything", "can_override": false}, "relabel": {"name": "relabel", "group": "functions", "definition": "(dict, label) -> merge(dict, [label: label])", "description": "", "templateType": "anything", "can_override": false}, "hide": {"name": "hide", "group": "functions", "definition": "(dict) -> merge(dict, [visible: false])", "description": "", "templateType": "anything", "can_override": false}, "A": {"name": "A", "group": "Quantities", "definition": "0", "description": "", "templateType": "anything", "can_override": false}, "RA": {"name": "RA", "group": "jsxgraph", "definition": "[x: 0, value: R_A, label: \"$R_A$\", visible: true]", "description": "", "templateType": "anything", "can_override": false}, "RB": {"name": "RB", "group": "jsxgraph", "definition": "[x: B, value: R_B, label: \"$R_B$\", visible: true]", "description": "", "templateType": "anything", "can_override": false}, "properties_fbd2": {"name": "properties_fbd2", "group": "Unnamed group", "definition": "[beamLength: C, loads: [[hide(w1'[0]),w1'[1]]], forces: [eqw'], reactions: [relabel(RA, string(force(abs(RA[\"value\"])))),V, relabel(RB, string(force(abs(RB[\"value\"]))))], moments: [M], symbols: [[x: xbarw', type: \"dot\", label: \"$\\\\bar{x}$\", visible: true], [x: B, type: \"dot\", label: \"$B$\", visible: true]]]", "description": "", "templateType": "anything", "can_override": false}, "fbd2": {"name": "fbd2", "group": "Unnamed group", "definition": "vmloaddiagram(properties_fbd2)", "description": "", "templateType": "anything", "can_override": false}, "V": {"name": "V", "group": "Unnamed group", "definition": "[x: C, value: -abs(fv), label: \"$V_C$\", visible: true]", "description": "<p>shear force points down on fbd</p>", "templateType": "anything", "can_override": false}, "M": {"name": "M", "group": "Unnamed group", "definition": "[x: C, value: 1, label: \"$M_C$\", visible: true]", "description": "", "templateType": "anything", "can_override": false}, "R_B": {"name": "R_B", "group": "Quantities", "definition": "-map(f->cross( vector(A-f[\"x\"],0,0),vector(0,-f[\"value\"],0))[2],forces+eqw)[0]/(A-B)\n", "description": "", "templateType": "anything", "can_override": false}}, "variablesTest": {"condition": "WA<>WB //always trapezoidal", "maxRuns": 100}, "ungrouped_variables": ["debug", "forces", "moments"], "variable_groups": [{"name": "Quantities", "variables": ["L", "A", "B", "C", "size", "WA", "WB", "WC", "R_A", "R_B", "check"]}, {"name": "vectors", "variables": []}, {"name": "jsxgraph", "variables": ["properties", "LoadDiagram", "shearDiagram", "momentDiagram", "W1", "symbols", "xbarW", "reactions", "W", "RA", "RB"]}, {"name": "functions", "variables": ["units", "force", "distance", "load", "moment", "area", "xbar", "relabel", "hide"]}, {"name": "diagrams", "variables": ["EqW", "properties_fbd1", "fbd1"]}, {"name": "Unnamed group", "variables": ["properties_fbd2", "fbd2", "W1'", "W'", "xbarW'", "EqW'", "FV", "M_C", "d", "V", "M"]}], "functions": {"display": {"parameters": [["q", "quantity"]], "type": "string", "language": "jme", "definition": "string(siground(q,4))"}, "applet": {"parameters": [["app_width", "number"], ["app_height", "number"], ["show_fbd", "boolean"]], "type": "ggbapplet", "language": "javascript", "definition": "// Create the worksheet. \n// This function returns an object with a container `element` and a `promise` resolving to a GeoGebra applet.\nvar params = {\n  material_id: 'susdzdmr',\n  width: app_width,\n  height: app_height\n};\n//geogebra_applet('susdzdmr') old ggb file\n\nvar result = Numbas.extensions.geogebra.createGeogebraApplet(params);\n\n// Once the applet has loaded, run some commands to manipulate the worksheet.\nresult.promise.then(function(d) {\n  var app = d.app;\n  question.applet = d;\n  app.setGridVisible(false);\n  \n  function setGGBPoint(name) {\n    // moves point in GGB to location of Numbas Vector Variable\n    var pt = question.scope.evaluate(name).value\n    app.setFixed(name,false,false);\n    app.setCoords(name, pt[0], pt[1]);\n    app.setFixed(name,true,true);\n  }\n\n function setGGBNumber(name) {\n    // Sets number in GGB to a Numbas Variable\n    var n = question.scope.evaluate(name).value;\n    app.setValue(name,n);\n  }\n  \n  setGGBPoint(\"C\");\n  setGGBPoint(\"D\");\n  app.setValue('fbd',show_fbd);\n  app.setAxesVisible(false,false);\n  app.enableShiftDragZoom(false);\n  setGGBNumber(\"w_A\");\n  setGGBNumber(\"w_B\");\n  \n \n  \n  \n});\n\n// This function returns the result of `createGeogebraApplet` as an object \n// with the JME data type 'ggbapplet', which can be substituted into the question's content.\nreturn new Numbas.jme.types.ggbapplet(result);"}, "showfbds": {"parameters": [], "type": "ggbapplet", "language": "javascript", "definition": "// Create the worksheet. \n// This function returns an object with a container `element` and a `promise` resolving to a GeoGebra applet.\nvar params = {\n  material_id: 'susdzdmr',\n  width: 500,\n  height: 500\n};\n//geogebra_applet('susdzdmr') old ggb file\n\nvar result = Numbas.extensions.geogebra.createGeogebraApplet(params);\n\n// Once the applet has loaded, run some commands to manipulate the worksheet.\nresult.promise.then(function(d) {\n  var app = d.app;\n  question.applet = d;\n  app.setGridVisible(false);\n  \n  function setGGBPoint(name) {\n    // moves point in GGB to location of Numbas Vector Variable\n    var pt = question.scope.evaluate(name).value\n    app.setFixed(name,false,false);\n    app.setCoords(name, pt[0], pt[1]);\n    app.setFixed(name,true,true);\n  }\n\n function setGGBNumber(name) {\n    // Sets number in GGB to a Numbas Variable\n    var n = question.scope.evaluate(name).value;\n    app.setValue(name,n);\n  }\n  \n  setGGBPoint(\"C\");\n  setGGBPoint(\"D\");\n  app.setValue('fbd',true);\n  app.setAxesVisible(false,false);\n  app.enableShiftDragZoom(false);\n  setGGBNumber(\"w_A\");\n  setGGBNumber(\"w_B\");\n  \n \n  \n  \n});\n\n// This function returns the result of `createGeogebraApplet` as an object \n// with the JME data type 'ggbapplet', which can be substituted into the question's content.\nreturn new Numbas.jme.types.ggbapplet(result);"}, "trapezoid": {"parameters": [["a", "number"], ["b", "number"], ["w", "number"]], "type": "vector", "language": "jme", "definition": "[(a+b)/2 * w, (w/3)*(a + 2b)/(a+b)] // a = left height, b = right height, w = width.... returns area and xbar"}}, "preamble": {"js": "", "css": ""}, "parts": [{"type": "gapfill", "useCustomName": true, "customName": "Reactions", "marks": 0, "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": true, "showFeedbackIcon": true, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "prompt": "<p>Determine the reactions at pin $A$ and roller $B$. &nbsp;Let positive values indicate upward forces.</p>\n<p>$A$ =&nbsp;[[0]]&nbsp; &nbsp;<span data-jme-visible=\"debug\"> $\\var{force(R_A)}$</span></p>\n<p>$B$ = [[1]]&nbsp; &nbsp;<span data-jme-visible=\"debug\">$\\var{force(R_B)}$</span></p>", "gaps": [{"type": "engineering-answer", "useCustomName": true, "customName": "$R_A$", "marks": "10", "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": true, "showFeedbackIcon": true, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "settings": {"correctAnswer": "force(R_A)", "right": "0.2", "close": "1.0", "C1": "75", "C2": "50", "C3": "25"}}, {"type": "engineering-answer", "useCustomName": true, "customName": "$R_B$", "marks": "10", "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": true, "showFeedbackIcon": true, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "settings": {"correctAnswer": "Force(R_B)", "right": "0.2", "close": "1.0", "C1": "75", "C2": "50", "C3": "25"}}], "sortAnswers": false}, {"type": "gapfill", "useCustomName": true, "customName": "Internal Load", "marks": 0, "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": true, "showFeedbackIcon": true, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "prompt": "<p>Determine the internal shear and bending moment at a section passing through point $C$. Use the standard convention for the meaning of positive shears and bending moments.&nbsp;</p>\n<p>$V_C$ &nbsp;= [[0]]&nbsp; &nbsp; <span data-jme-visible=\"debug\">$\\var{force(FV)}$</span></p>\n<p>$M_C$ = [[1]] &nbsp;&nbsp; <span data-jme-visible=\"debug\">$\\var{moment(M_C)}$</span></p>", "gaps": [{"type": "engineering-answer", "useCustomName": true, "customName": "$V_C$", "marks": "15", "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": true, "showFeedbackIcon": true, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "settings": {"correctAnswer": "force(FV)", "right": "0.2", "close": "1.0", "C1": "75", "C2": "50", "C3": "25"}}, {"type": "engineering-answer", "useCustomName": true, "customName": "$M_C$", "marks": "15", "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": true, "showFeedbackIcon": true, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "settings": {"correctAnswer": "moment(M_C)", "right": "0.2", "close": "1.0", "C1": "75", "C2": "50", "C3": "25"}}], "sortAnswers": false}], "partsMode": "all", "maxMarks": 0, "objectives": [], "penalties": [], "objectiveVisibility": "always", "penaltyVisibility": "always"}, {"name": "Internal Force: distributed load", "extensions": ["geogebra", "quantities"], "custom_part_types": [{"source": {"pk": 19, "author": {"name": "William Haynes", "pk": 2530}, "edit_page": "/part_type/19/edit"}, "name": "Engineering Accuracy with units", "short_name": "engineering-answer", "description": "<p>A value with units marked right if within an adjustable % error of the correct value. &nbsp;Marked close if within a wider margin of error.</p>", "help_url": "", "input_widget": "string", "input_options": {"correctAnswer": "siground(settings['correctAnswer'],4)", "hint": {"static": true, "value": ""}, "allowEmpty": {"static": true, "value": true}}, "can_be_gap": true, "can_be_step": true, "marking_script": "mark:\nswitch( \n  right and good_units and right_sign, add_credit(1.0,'Correct.'),\n  right and good_units and not right_sign, add_credit(settings['C2'],'Wrong sign.'),\n  right and right_sign and not good_units, add_credit(settings['C2'],'Correct value, but wrong or missing units.'),\n  close and good_units, add_credit(settings['C1'],'Close.'),\n  close and not good_units, add_credit(settings['C3'],'Answer is close, but wrong or missing units.'),\n  incorrect('Wrong answer.')\n)\n\ninterpreted_answer:\nqty(student_scalar, student_units)\n\n\n\ncorrect_quantity:\nsettings[\"correctAnswer\"]\n\n\n\ncorrect_units:\nunits(correct_quantity)\n\n\nallowed_notation_styles:\n[\"plain\",\"en\"]\n\nmatch_student_number:\nmatchnumber(studentAnswer,allowed_notation_styles)\n\nstudent_scalar:\nmatch_student_number[1]\n\nstudent_units:\nreplace_regex('ohms','ohm',\n  replace_regex('\u00b0', ' deg',\n    replace_regex('-', ' ' ,\n      studentAnswer[len(match_student_number[0])..len(studentAnswer)])),\"i\")\n\ngood_units:\ntry(\ncompatible(quantity(1, student_units),correct_units),\nmsg,\nfeedback(msg);false)\n\n\nstudent_quantity:\nswitch(not good_units, \n       student_scalar * correct_units, \n       not right_sign,\n       -quantity(student_scalar, student_units),\n       quantity(student_scalar,student_units)\n)\n  \n\n\npercent_error:\ntry(\nscalar(abs((correct_quantity - student_quantity)/correct_quantity))*100  \n,msg,\nif(student_quantity=correct_quantity,0,100))\n   \n\nright:\npercent_error <= settings['right']\n\n\nclose:\nright_sign and percent_error <= settings['close']\n\nright_sign:\nsign(student_scalar) = sign(correct_quantity)", "marking_notes": [{"name": "mark", "description": "This is the main marking note. It should award credit and provide feedback based on the student's answer.", "definition": "switch( \n  right and good_units and right_sign, add_credit(1.0,'Correct.'),\n  right and good_units and not right_sign, add_credit(settings['C2'],'Wrong sign.'),\n  right and right_sign and not good_units, add_credit(settings['C2'],'Correct value, but wrong or missing units.'),\n  close and good_units, add_credit(settings['C1'],'Close.'),\n  close and not good_units, add_credit(settings['C3'],'Answer is close, but wrong or missing units.'),\n  incorrect('Wrong answer.')\n)"}, {"name": "interpreted_answer", "description": "A value representing the student's answer to this part.", "definition": "qty(student_scalar, student_units)\n\n"}, {"name": "correct_quantity", "description": "", "definition": "settings[\"correctAnswer\"]\n\n"}, {"name": "correct_units", "description": "", "definition": "units(correct_quantity)\n"}, {"name": "allowed_notation_styles", "description": "", "definition": "[\"plain\",\"en\"]"}, {"name": "match_student_number", "description": "", "definition": "matchnumber(studentAnswer,allowed_notation_styles)"}, {"name": "student_scalar", "description": "", "definition": "match_student_number[1]"}, {"name": "student_units", "description": "<p>Modify&nbsp;the&nbsp;unit portion of&nbsp;the student's answer by</p>\n<p>1. replacing \"ohms\" with \"ohm\" &nbsp;case insensitive</p>\n<p>2.&nbsp;replacing '-'&nbsp;with ' '&nbsp;</p>\n<p>3. replacing '&deg;' with ' deg'&nbsp;</p>\n<p>to allow answers like 10 ft-lb and 30&deg;</p>", "definition": "replace_regex('ohms','ohm',\n  replace_regex('\u00b0', ' deg',\n    replace_regex('-', ' ' ,\n      studentAnswer[len(match_student_number[0])..len(studentAnswer)])),\"i\")"}, {"name": "good_units", "description": "", "definition": "try(\ncompatible(quantity(1, student_units),correct_units),\nmsg,\nfeedback(msg);false)\n"}, {"name": "student_quantity", "description": "<p>This fixes the student answer for two common errors. &nbsp;</p>\n<p>If student_units are wrong&nbsp;&nbsp;- replace with correct units</p>\n<p>If student_scalar has the wrong sign - replace with right sign</p>\n<p>If student makes both errors, only one gets fixed.</p>", "definition": "switch(not good_units, \n       student_scalar * correct_units, \n       not right_sign,\n       -quantity(student_scalar, student_units),\n       quantity(student_scalar,student_units)\n)\n  \n"}, {"name": "percent_error", "description": "", "definition": "try(\nscalar(abs((correct_quantity - student_quantity)/correct_quantity))*100  \n,msg,\nif(student_quantity=correct_quantity,0,100))\n   "}, {"name": "right", "description": "", "definition": "percent_error <= settings['right']\n"}, {"name": "close", "description": "<p>Only marked close if the student actually has the right sign.</p>", "definition": "right_sign and percent_error <= settings['close']"}, {"name": "right_sign", "description": "", "definition": "sign(student_scalar) = sign(correct_quantity) "}], "settings": [{"name": "correctAnswer", "label": "Correct Quantity.", "help_url": "", "hint": "The correct answer given as a JME quantity.", "input_type": "code", "default_value": "", "evaluate": true}, {"name": "right", "label": "% Accuracy for right.", "help_url": "", "hint": "Question will be considered correct if the scalar part of the student's answer is within this % of correct value.", "input_type": "code", "default_value": "0.2", "evaluate": true}, {"name": "close", "label": "% Accuracy for close.", "help_url": "", "hint": "Question will be considered close if the scalar part of the student's answer is within this % of correct value.", "input_type": "code", "default_value": "1.0", "evaluate": true}, {"name": "C1", "label": "Close with units.", "help_url": "", "hint": "Partial Credit for close value with appropriate units. &nbsp;if correct answer is 100 N and close is &plusmn;1%,<br />99 &nbsp;N is accepted.", "input_type": "percent", "default_value": "75"}, {"name": "C2", "label": "No units or wrong sign", "help_url": "", "hint": "Partial credit for forgetting units or using wrong sign.<br />If the correct answer is 100 N, both 100 and -100 N are accepted.", "input_type": "percent", "default_value": "50"}, {"name": "C3", "label": "Close, no units.", "help_url": "", "hint": "Partial Credit for close value but forgotten units.<br />This value would be close&nbsp;if the expected units were provided. &nbsp;If the correct answer is 100 N, and close is &plusmn;1%,<br />99 is accepted.", "input_type": "percent", "default_value": "25"}], "public_availability": "always", "published": true, "extensions": ["quantities"]}], "resources": [], "navigation": {"allowregen": true, "showfrontpage": false, "preventleave": false, "typeendtoleave": false}, "contributors": [{"name": "William Haynes", "profile_url": "https://numbas.mathcentre.ac.uk/accounts/profile/2530/"}], "tags": [], "metadata": {"description": "<p>Find the shear, normal force and bending moment at a point in a beam supporting a uniformly distributed load.</p>", "licence": "Creative Commons Attribution-NonCommercial 4.0 International"}, "statement": "<p>The frame shown supports a uniformly distributed load $w = \\var{load}$. &nbsp;Member $BC$&nbsp;is {BC} long. &nbsp;</p>\n<p>Determine the internal forces at point $D$&nbsp;which is located {BD} to the right of point $B$.</p>\n<p>{geogebra_applet( 'pt6wrf9n', params)}</p>", "advice": "<p><strong>Find the reactions <em>B</em> and&nbsp;<em>C</em>.&nbsp;</strong></p>\n<p style=\"padding-left: 40px;\">Draw a Free body diagram of beam $BC$. &nbsp;</p>\n<p>{fbd1}</p>\n<p style=\"padding-left: 30px;\">Note that member&nbsp;$AB$&nbsp;is a two-force member, so force $AB$ acts along its axis.</p>\n<p style=\"padding-left: 30px;\">Replace the distributed load with an equivalent concentrated. The equivalent load acts at the center of member $BC$ with magnitude:</p>\n<p style=\"padding-left: 30px;\">$W = w \\cdot \\overline{BC} = (\\var{load}) (\\var{BC}) = \\var{Q_W}$.</p>\n<p></p>\n<p style=\"padding-left: 30px;\">Let the length of member &nbsp;$BC = \\ell = \\var{BC}$, then solve the equilibrium equations to find the reactions at $B$ and $C$.</p>\n<p style=\"padding-left: 30px;\">$\\begin{align}\\Sigma M_C &amp; = 0 &amp;\\Sigma F_x&nbsp;&amp;= 0 &amp;\\Sigma F_y &amp;= 0\\\\AB_y &nbsp;\\cdot \\ell&nbsp;&amp;= W \\cdot \\dfrac {\\ell}{2} &nbsp;&amp; &nbsp; C_x &amp;=AB_x &nbsp;&amp; C_y &amp;= W -AB_y&nbsp;\\\\AB \\sin \\var{abs(alpha)}&deg;&amp; = \\dfrac{ W }{2}&amp; C_x &amp;= AB \\cos \\var{abs(alpha)}&deg; &amp;&nbsp;C_y &amp;= W - AB&nbsp;\\sin \\var{abs(alpha)}&deg; \\\\ AB &amp;= \\var{display(Q_AB)}&nbsp;&amp; C_x &amp;= \\var{display(abs(Q_cx))}\\var{if(F_AB[0]&gt;0,latex('\\\\leftarrow'),latex('\\\\rightarrow'))} &amp; C_y &amp;= \\var{display(Q_Cy)} \\var{if(F_AB[1]&gt;0,latex('\\\\uparrow'),latex('\\\\downarrow'))}\\end{align}$</p>\n<p style=\"padding-left: 30px;\"></p>\n<p><strong>Take an imaginary cut through member <em>BC</em> at point&nbsp;<em>D</em> and draw a free body diagram of the right (or left) portion. </strong></p>\n<p>{fbd2}&nbsp;</p>\n<p style=\"padding-left: 40px;\">The length of segment $DC$ is $\\var{CD}$. There will be unknown internal shear ($V$), bending moment ($M_D$) and normal force&nbsp;($P$)&nbsp;at the cut. Assume that they act&nbsp;in the 'positive' directions established by the sign convention for shear and bending moments. &nbsp;</p>\n<p style=\"padding-left: 40px;\">Note that the downward force on this section of the beam&nbsp;($W'$) is&nbsp;due to the distributed force acting on this portion of the beam only and acts at the centroid of the loading.</p>\n<p style=\"padding-left: 40px;\">$W' = w \\cdot \\overline{DC} = (\\var{load}) (\\var{BC-BD}) = \\var{display(Q_W')}$</p>\n<p><strong>Solve for the internal forces at <em>D</em>.</strong></p>\n<p style=\"padding-left: 30px;\">$\\begin{align}\\Sigma M_D &amp; = 0 &amp;\\Sigma F_x &amp;= 0 &amp;\\Sigma F_y &amp;= 0\\\\ M_D&nbsp; &amp;= C_y (\\var{CD}) - W'(\\var{CD/2})&amp; &nbsp; P &amp;= \\var{if(F_AB[0]&gt;0,latex('-'),'')} C_x &nbsp;&amp; V&nbsp;&amp;= W'-C_y\\\\ &amp;= \\var{display(Q_MD)} &amp; &amp;= \\var{display(-Q_Cx)} &amp; &amp;= \\var{display(Q_V)}&nbsp;\\end{align}$</p>\n<p>&nbsp;&nbsp;</p>", "rulesets": {}, "builtin_constants": {"e": true, "pi,\u03c0": true, "i": true, "j": false}, "constants": [], "variables": {"BC": {"name": "BC", "group": "Inputs", "definition": "qty(random(4..12#2),units[1])", "description": "", "templateType": "anything", "can_override": false}, "units": {"name": "units", "group": "Ungrouped variables", "definition": "['lb','ft']", "description": "", "templateType": "anything", "can_override": false}, "load": {"name": "load", "group": "Inputs", "definition": "qty(random(10..50#5), units[0\n  ]+\"/\"+units[1])", "description": "", "templateType": "anything", "can_override": false}, "Q_W'": {"name": "Q_W'", "group": "soon", "definition": "CD Load\n", "description": "", "templateType": "anything", "can_override": false}, "Q_V": {"name": "Q_V", "group": "soon", "definition": "Q_W'-Q_Cy", "description": "", "templateType": "anything", "can_override": false}, "Q_Cy": {"name": "Q_Cy", "group": "soon", "definition": "Q_W - qty(F_AB[1], units[0])", "description": "", "templateType": "anything", "can_override": false}, "Q_AB": {"name": "Q_AB", "group": "soon", "definition": "qty(abs(F_AB), units[0])", "description": "", "templateType": "anything", "can_override": false}, "params": {"name": "params", "group": "Ungrouped variables", "definition": "[alpha: [definition: radians(alpha), visible: false],\nn: [definition: n, visible: false],\nshow: [definition: 0, visible: false],\n]", "description": "<p>n = 1..10 &nbsp;</p>", "templateType": "anything", "can_override": false}, "F_AB": {"name": "F_AB", "group": "soon", "definition": "precround(scalar(Q_W)/2 * vector(1/tan(radians(alpha+180)), 1),4)", "description": "<p>alpha is defined from negative x axis,&nbsp;</p>", "templateType": "anything", "can_override": false}, "BD": {"name": "BD", "group": "Inputs", "definition": "n/10 BC\n", "description": "<p>n/10 is fraction of length BC</p>", "templateType": "anything", "can_override": false}, "Q_W": {"name": "Q_W", "group": "soon", "definition": "load * bc", "description": "<p>W</p>", "templateType": "anything", "can_override": false}, "alpha": {"name": "alpha", "group": "Inputs", "definition": "random(20..60#5) random(-1,1)", "description": "", "templateType": "anything", "can_override": false}, "sum": {"name": "sum", "group": "soon", "definition": "precround(F_AB+F_C+F_W,3)", "description": "<p>check</p>", "templateType": "anything", "can_override": false}, "Q_Cx": {"name": "Q_Cx", "group": "soon", "definition": "qty((F_AB[0]), units[0])", "description": "", "templateType": "anything", "can_override": false}, "F_W": {"name": "F_W", "group": "soon", "definition": "vector(-scalar(Q_W),0)", "description": "", "templateType": "anything", "can_override": false}, "CD": {"name": "CD", "group": "Inputs", "definition": "BC-BD", "description": "", "templateType": "anything", "can_override": false}, "Q_MD": {"name": "Q_MD", "group": "soon", "definition": "(CD Q_Cy - CD Q_W'/2)", "description": "<p>Q</p>", "templateType": "anything", "can_override": false}, "F_C": {"name": "F_C", "group": "soon", "definition": "precround(-(F_AB+F_W),4)", "description": "", "templateType": "anything", "can_override": false}, "applet": {"name": "applet", "group": "Ungrouped variables", "definition": "geogebra_applet( 'pt6wrf9n', params)", "description": "", "templateType": "anything", "can_override": false}, "n": {"name": "n", "group": "Inputs", "definition": "random(2..8# 0.5)", "description": "<p>Position of cut as ratio of BC</p>", "templateType": "anything", "can_override": false}, "fbd1": {"name": "fbd1", "group": "Ungrouped variables", "definition": "geogebra_applet('pt6wrf9n', params + [show: [definition: 1, visible: false]])", "description": "", "templateType": "anything", "can_override": false}, "fbd2": {"name": "fbd2", "group": "Ungrouped variables", "definition": "geogebra_applet('pt6wrf9n', params + \n[show: [definition: 2, visible: false],\n n: [definition: min(5,n), visible: false]\n])", "description": "<p>just setting n=5 to make the diagram larger</p>", "templateType": "anything", "can_override": false}}, "variablesTest": {"condition": "", "maxRuns": 100}, "ungrouped_variables": ["units", "applet", "params", "fbd1", "fbd2"], "variable_groups": [{"name": "soon", "variables": ["Q_W", "F_AB", "F_W", "F_C", "sum", "Q_AB", "Q_Cx", "Q_Cy", "Q_MD", "Q_W'", "Q_V"]}, {"name": "Inputs", "variables": ["BC", "alpha", "load", "n", "BD", "CD"]}], "functions": {"display": {"parameters": [["q", "quantity"]], "type": "string", "language": "jme", "definition": "string(siground(q,4))"}}, "preamble": {"js": "question.signals.on('adviceDisplayed',function() {\n try{\n    var app = question.scope.variables.applet.app;  \n    app.setVisible(\"fbd\", true,false);\n    app.setValue(\"fbd\", 1);\n  }\n  catch(err){}  \n})\n", "css": ""}, "parts": [{"type": "gapfill", "useCustomName": false, "customName": "", "marks": 0, "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": true, "showFeedbackIcon": true, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "prompt": "<table style=\"height: 98px; width: 411px;\">\n<tbody>\n<tr style=\"height: 23px;\">\n<td style=\"width: 157.375px; height: 17px;\">Shear force:</td>\n<td style=\"width: 220.640625px; height: 17px;\">\n<p>$V_D &nbsp;= $ [[1]]</p>\n</td>\n</tr>\n<tr style=\"height: 23px;\">\n<td style=\"width: 157.375px; height: 39px;\">Normal force:</td>\n<td style=\"width: 220.640625px; height: 39px;\">\n<p>$P_D = $ [[0]]</p>\n</td>\n</tr>\n<tr style=\"height: 23px;\">\n<td style=\"width: 157.375px; height: 42px;\">Bending moment:&nbsp;</td>\n<td style=\"width: 220.640625px; height: 42px;\">$M_D =$ [[2]]</td>\n</tr>\n</tbody>\n</table>\n<p></p>\n<p></p>", "gaps": [{"type": "engineering-answer", "useCustomName": true, "customName": "$P_D$", "marks": "10", "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": true, "showFeedbackIcon": true, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "settings": {"correctAnswer": "-Q_Cx", "right": "0.2", "close": "1.0", "C1": "75", "C2": "50", "C3": "25"}}, {"type": "engineering-answer", "useCustomName": true, "customName": "$V_D$", "marks": "10", "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": true, "showFeedbackIcon": true, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "settings": {"correctAnswer": "Q_V", "right": "0.2", "close": "1.0", "C1": "75", "C2": "50", "C3": "25"}}, {"type": "engineering-answer", "useCustomName": true, "customName": "$M_D$", "marks": "10", "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": true, "showFeedbackIcon": true, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "settings": {"correctAnswer": "Q_MD", "right": "0.2", "close": "1.0", "C1": "75", "C2": "50", "C3": "25"}}], "sortAnswers": false}], "partsMode": "all", "maxMarks": 0, "objectives": [], "penalties": [], "objectiveVisibility": "always", "penaltyVisibility": "always"}]}, {"name": "Shear and Bending Moment Diagrams", "pickingStrategy": "all-ordered", "pickQuestions": 1, "questionNames": ["V&M Diagrams: Section Cut Method", "V&M Diagrams:  Concentrated Forces", "V&M Diagrams:  Concentrated Moment", "V&M Diagrams: Distributed Loads", "V&M Diagrams:  Combined Loads", "V&M Diagrams: Ground Beam", "V&M Diagrams: Triangular Loading", "V&M Diagrams:  Symmetric parabolic loading", "V&M Diagrams: Arbitrary loading function"], "variable_overrides": [[], [], [], [], [], [], [], [], []], "questions": [{"name": "VM0: Section Cut Method", "extensions": ["jsxgraph", "quantities", "shear-and-bending-moment-diagrams"], "custom_part_types": [], "resources": ["question-resources/FBDS.svg"], "navigation": {"allowregen": true, "showfrontpage": false, "preventleave": false, "typeendtoleave": false}, "contributors": [{"name": "William Haynes", "profile_url": "https://numbas.mathcentre.ac.uk/accounts/profile/2530/"}], "tags": ["bending moment", "Mechanics", "mechanics", "shear", "Statics", "statics"], "metadata": {"description": "<p>Determine expressions for internal shear and bending moment as a function of $x$ for a beam with two vertical loads.</p>", "licence": "Creative Commons Attribution-NonCommercial 4.0 International"}, "statement": "<p style=\"text-align: left;\">{diagram}</p>\n<p style=\"text-align: left;\">The $\\var{qty(12, 'm')}$ long beam is loaded with $\\var{qty(B, 'kN')}$ force $B$ and $\\var{qty(C, 'kN')}$ force $C$, as shown.</p>", "advice": "<p>1. &nbsp;Draw a FBD of the whole beam and take moments at $D$ to find $A = \\var{A'}$.</p>\n<p>2. &nbsp;Take cuts in each of the three segments, and draw three free-body diagrams. &nbsp;Show internal shear and moment at the cut with the standard sign convention.</p>\n<p>3. &nbsp;For each FBD, apply $\\Sigma F_y = 0$ and $\\Sigma M_\\text{cut}=0$ to determine expressions for $V(x)$ and $M(x)$ as &nbsp;functions of the forces and $x$.</p>\n<p><img src=\"resources/question-resources/FBDS.svg\" width=\"450\" height=\"517\"/></p>\n<p style=\"text-align: left;\"></p>", "rulesets": {}, "builtin_constants": {"e": true, "pi,\u03c0": true, "i": true, "j": false}, "constants": [], "variables": {"B": {"name": "B", "group": "Unnamed group", "definition": "random(100..1200#50)", "description": "", "templateType": "anything", "can_override": false}, "C": {"name": "C", "group": "Unnamed group", "definition": "random(100..1000#50)", "description": "", "templateType": "anything", "can_override": false}, "d1": {"name": "d1", "group": "Unnamed group", "definition": "random(2..8)", "description": "", "templateType": "anything", "can_override": false}, "d2": {"name": "d2", "group": "Unnamed group", "definition": "random(d1+2..10)\n", "description": "", "templateType": "anything", "can_override": false}, "D": {"name": "D", "group": "Unnamed group", "definition": "siground((b  d1 + c  *d2)/12,4)", "description": "", "templateType": "anything", "can_override": false}, "A": {"name": "A", "group": "Unnamed group", "definition": "B+C-D", "description": "", "templateType": "anything", "can_override": false}, "V1": {"name": "V1", "group": "Unnamed group", "definition": "A", "description": "", "templateType": "anything", "can_override": false}, "V2": {"name": "V2", "group": "Unnamed group", "definition": "A-B", "description": "", "templateType": "anything", "can_override": false}, "V3": {"name": "V3", "group": "Unnamed group", "definition": "A-B-C", "description": "", "templateType": "anything", "can_override": false}, "M1": {"name": "M1", "group": "Unnamed group", "definition": "substitute([\"A\": A], expression(\"A x\"))", "description": "", "templateType": "anything", "can_override": false}, "M2": {"name": "M2", "group": "Unnamed group", "definition": "substitute([\"A\": A, \"B\": b, \"d1\": d1], expression(\"A x - B*(x-d1)\"))", "description": "", "templateType": "anything", "can_override": false}, "M3": {"name": "M3", "group": "Unnamed group", "definition": "substitute([\"A\":A, \"B\": B, \"C\":C, \"d1\": d1, \"d2\":d2],\n  expression(\"A x - B*(x-d1) - c*(x- d2)\" )) ", "description": "", "templateType": "anything", "can_override": false}, "A'": {"name": "A'", "group": "Unnamed group", "definition": "qty(trunc(A),'kN')", "description": "", "templateType": "anything", "can_override": false}, "L": {"name": "L", "group": "Unnamed group", "definition": "12", "description": "", "templateType": "anything", "can_override": false}, "diagram": {"name": "diagram", "group": "Ungrouped variables", "definition": "vmloaddiagram(properties)", "description": "", "templateType": "anything", "can_override": false}, "properties": {"name": "properties", "group": "Ungrouped variables", "definition": "[beamLength: L, reactions: [], forces: forces,  moments: [], loads: [], symbols: symbols]", "description": "", "templateType": "anything", "can_override": false}, "forces": {"name": "forces", "group": "Ungrouped variables", "definition": "[[x: d1, value: 1, label: \"$B$\" , visible: true], [x: d2, value: 1, label: \"$C$\", visible: true]]", "description": "", "templateType": "anything", "can_override": false}, "symbols": {"name": "symbols", "group": "Ungrouped variables", "definition": "[[x: 0, type: \"pin\", label: \"$A$\", visible: true],[x: L, type: \"roller\", label: \"$D$\", visible: true], ]", "description": "", "templateType": "anything", "can_override": false}}, "variablesTest": {"condition": "c-b > 2", "maxRuns": 100}, "ungrouped_variables": ["diagram", "properties", "forces", "symbols"], "variable_groups": [{"name": "Unnamed group", "variables": ["D", "A", "V1", "V2", "V3", "M1", "M2", "M3", "A'", "L", "B", "C", "d1", "d2"]}], "functions": {}, "preamble": {"js": "", "css": ""}, "parts": [{"type": "gapfill", "useCustomName": true, "customName": "$0 < x < d_1$", "marks": 0, "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": true, "showFeedbackIcon": true, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "prompt": "<p>Find the shear and bending moment as functions of $x$ on the range: &nbsp;$0 \\text{ m}&lt; x &lt; \\var{d1}$ m</p>\n<p>$V_1(x)$ = [[0]] kN<br/><br/><br/>$M_1(x)$ = [[1]]&nbsp; kN-m&nbsp;</p>\n<p></p>", "gaps": [{"type": "jme", "useCustomName": true, "customName": "$V_1$", "marks": "10", "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": true, "showFeedbackIcon": true, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "answer": "{V1}", "showPreview": true, "checkingType": "sigfig", "checkingAccuracy": 3, "failureRate": 1, "vsetRangePoints": 5, "vsetRange": [0, 1], "checkVariableNames": false, "singleLetterVariables": false, "allowUnknownFunctions": true, "implicitFunctionComposition": false, "caseSensitive": false, "valuegenerators": []}, {"type": "jme", "useCustomName": true, "customName": "$M_1$", "marks": "10", "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": true, "showFeedbackIcon": true, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "answer": "{M1}", "showPreview": true, "checkingType": "sigfig", "checkingAccuracy": 3, "failureRate": 1, "vsetRangePoints": 5, "vsetRange": [0, 1], "checkVariableNames": false, "singleLetterVariables": false, "allowUnknownFunctions": true, "implicitFunctionComposition": false, "caseSensitive": false, "valuegenerators": []}], "sortAnswers": false}, {"type": "gapfill", "useCustomName": true, "customName": "$d_1 < x < d_2$", "marks": 0, "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": true, "showFeedbackIcon": true, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "prompt": "<p>Find the shear and bending moment as functions of $x$ on the range: $\\var{d1}\\text{ m} &lt; x &lt; \\var{d2}$ m</p>\n<p>$V_2(x)$ = [[1]] kN</p>\n<p></p>\n<p>$M_2(x)$ = [[0]] kN-m</p>\n<p></p>", "gaps": [{"type": "jme", "useCustomName": true, "customName": "$M_2$", "marks": "10", "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": true, "showFeedbackIcon": true, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "answer": "{M2}", "showPreview": true, "checkingType": "sigfig", "checkingAccuracy": 3, "failureRate": 1, "vsetRangePoints": 5, "vsetRange": ["0", "1"], "checkVariableNames": false, "singleLetterVariables": false, "allowUnknownFunctions": true, "implicitFunctionComposition": false, "caseSensitive": false, "valuegenerators": []}, {"type": "jme", "useCustomName": true, "customName": "$V_2$", "marks": "10", "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": true, "showFeedbackIcon": true, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "answer": "{V2}", "showPreview": true, "checkingType": "sigfig", "checkingAccuracy": 3, "failureRate": 1, "vsetRangePoints": 5, "vsetRange": [0, 1], "checkVariableNames": false, "singleLetterVariables": false, "allowUnknownFunctions": true, "implicitFunctionComposition": false, "caseSensitive": false, "valuegenerators": []}], "sortAnswers": false}, {"type": "gapfill", "useCustomName": true, "customName": "$d_2 < x < L$", "marks": 0, "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": true, "showFeedbackIcon": true, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "prompt": "<p>Find the shear and bending moment as functions of $x$ on the range: &nbsp;$\\var{d2}\\text{ m} &lt; x &lt; 12$ m</p>\n<p>$V_3(x)$ = [[0]] kN <br/><br/>$ M_3(x)$ =[[1]]kN-m</p>", "gaps": [{"type": "jme", "useCustomName": true, "customName": "$V_3$", "marks": "10", "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": true, "showFeedbackIcon": true, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "answer": "{V3}", "showPreview": true, "checkingType": "sigfig", "checkingAccuracy": 3, "failureRate": 1, "vsetRangePoints": 5, "vsetRange": [0, 1], "checkVariableNames": false, "singleLetterVariables": false, "allowUnknownFunctions": true, "implicitFunctionComposition": false, "caseSensitive": false, "valuegenerators": []}, {"type": "jme", "useCustomName": true, "customName": "$M_3$", "marks": "10", "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": true, "showFeedbackIcon": true, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "answer": "{M3}", "showPreview": true, "checkingType": "sigfig", "checkingAccuracy": 3, "failureRate": 1, "vsetRangePoints": 5, "vsetRange": [0, 1], "checkVariableNames": false, "singleLetterVariables": false, "allowUnknownFunctions": true, "implicitFunctionComposition": false, "caseSensitive": false, "valuegenerators": []}], "sortAnswers": false}], "partsMode": "all", "maxMarks": 0, "objectives": [], "penalties": [], "objectiveVisibility": "always", "penaltyVisibility": "always"}, {"name": "VM1: Concentrated Forces", "extensions": ["jsxgraph", "quantities", "shear-and-bending-moment-diagrams"], "custom_part_types": [{"source": {"pk": 19, "author": {"name": "William Haynes", "pk": 2530}, "edit_page": "/part_type/19/edit"}, "name": "Engineering Accuracy with units", "short_name": "engineering-answer", "description": "<p>A value with units marked right if within an adjustable % error of the correct value. &nbsp;Marked close if within a wider margin of error.</p>", "help_url": "", "input_widget": "string", "input_options": {"correctAnswer": "siground(settings['correctAnswer'],4)", "hint": {"static": true, "value": ""}, "allowEmpty": {"static": true, "value": true}}, "can_be_gap": true, "can_be_step": true, "marking_script": "mark:\nswitch( \n  right and good_units and right_sign, add_credit(1.0,'Correct.'),\n  right and good_units and not right_sign, add_credit(settings['C2'],'Wrong sign.'),\n  right and right_sign and not good_units, add_credit(settings['C2'],'Correct value, but wrong or missing units.'),\n  close and good_units, add_credit(settings['C1'],'Close.'),\n  close and not good_units, add_credit(settings['C3'],'Answer is close, but wrong or missing units.'),\n  incorrect('Wrong answer.')\n)\n\ninterpreted_answer:\nqty(student_scalar, student_units)\n\n\n\ncorrect_quantity:\nsettings[\"correctAnswer\"]\n\n\n\ncorrect_units:\nunits(correct_quantity)\n\n\nallowed_notation_styles:\n[\"plain\",\"en\"]\n\nmatch_student_number:\nmatchnumber(studentAnswer,allowed_notation_styles)\n\nstudent_scalar:\nmatch_student_number[1]\n\nstudent_units:\nreplace_regex('ohms','ohm',\n  replace_regex('\u00b0', ' deg',\n    replace_regex('-', ' ' ,\n      studentAnswer[len(match_student_number[0])..len(studentAnswer)])),\"i\")\n\ngood_units:\ntry(\ncompatible(quantity(1, student_units),correct_units),\nmsg,\nfeedback(msg);false)\n\n\nstudent_quantity:\nswitch(not good_units, \n       student_scalar * correct_units, \n       not right_sign,\n       -quantity(student_scalar, student_units),\n       quantity(student_scalar,student_units)\n)\n  \n\n\npercent_error:\ntry(\nscalar(abs((correct_quantity - student_quantity)/correct_quantity))*100  \n,msg,\nif(student_quantity=correct_quantity,0,100))\n   \n\nright:\npercent_error <= settings['right']\n\n\nclose:\nright_sign and percent_error <= settings['close']\n\nright_sign:\nsign(student_scalar) = sign(correct_quantity)", "marking_notes": [{"name": "mark", "description": "This is the main marking note. It should award credit and provide feedback based on the student's answer.", "definition": "switch( \n  right and good_units and right_sign, add_credit(1.0,'Correct.'),\n  right and good_units and not right_sign, add_credit(settings['C2'],'Wrong sign.'),\n  right and right_sign and not good_units, add_credit(settings['C2'],'Correct value, but wrong or missing units.'),\n  close and good_units, add_credit(settings['C1'],'Close.'),\n  close and not good_units, add_credit(settings['C3'],'Answer is close, but wrong or missing units.'),\n  incorrect('Wrong answer.')\n)"}, {"name": "interpreted_answer", "description": "A value representing the student's answer to this part.", "definition": "qty(student_scalar, student_units)\n\n"}, {"name": "correct_quantity", "description": "", "definition": "settings[\"correctAnswer\"]\n\n"}, {"name": "correct_units", "description": "", "definition": "units(correct_quantity)\n"}, {"name": "allowed_notation_styles", "description": "", "definition": "[\"plain\",\"en\"]"}, {"name": "match_student_number", "description": "", "definition": "matchnumber(studentAnswer,allowed_notation_styles)"}, {"name": "student_scalar", "description": "", "definition": "match_student_number[1]"}, {"name": "student_units", "description": "<p>Modify&nbsp;the&nbsp;unit portion of&nbsp;the student's answer by</p>\n<p>1. replacing \"ohms\" with \"ohm\" &nbsp;case insensitive</p>\n<p>2.&nbsp;replacing '-'&nbsp;with ' '&nbsp;</p>\n<p>3. replacing '&deg;' with ' deg'&nbsp;</p>\n<p>to allow answers like 10 ft-lb and 30&deg;</p>", "definition": "replace_regex('ohms','ohm',\n  replace_regex('\u00b0', ' deg',\n    replace_regex('-', ' ' ,\n      studentAnswer[len(match_student_number[0])..len(studentAnswer)])),\"i\")"}, {"name": "good_units", "description": "", "definition": "try(\ncompatible(quantity(1, student_units),correct_units),\nmsg,\nfeedback(msg);false)\n"}, {"name": "student_quantity", "description": "<p>This fixes the student answer for two common errors. &nbsp;</p>\n<p>If student_units are wrong&nbsp;&nbsp;- replace with correct units</p>\n<p>If student_scalar has the wrong sign - replace with right sign</p>\n<p>If student makes both errors, only one gets fixed.</p>", "definition": "switch(not good_units, \n       student_scalar * correct_units, \n       not right_sign,\n       -quantity(student_scalar, student_units),\n       quantity(student_scalar,student_units)\n)\n  \n"}, {"name": "percent_error", "description": "", "definition": "try(\nscalar(abs((correct_quantity - student_quantity)/correct_quantity))*100  \n,msg,\nif(student_quantity=correct_quantity,0,100))\n   "}, {"name": "right", "description": "", "definition": "percent_error <= settings['right']\n"}, {"name": "close", "description": "<p>Only marked close if the student actually has the right sign.</p>", "definition": "right_sign and percent_error <= settings['close']"}, {"name": "right_sign", "description": "", "definition": "sign(student_scalar) = sign(correct_quantity) "}], "settings": [{"name": "correctAnswer", "label": "Correct Quantity.", "help_url": "", "hint": "The correct answer given as a JME quantity.", "input_type": "code", "default_value": "", "evaluate": true}, {"name": "right", "label": "% Accuracy for right.", "help_url": "", "hint": "Question will be considered correct if the scalar part of the student's answer is within this % of correct value.", "input_type": "code", "default_value": "0.2", "evaluate": true}, {"name": "close", "label": "% Accuracy for close.", "help_url": "", "hint": "Question will be considered close if the scalar part of the student's answer is within this % of correct value.", "input_type": "code", "default_value": "1.0", "evaluate": true}, {"name": "C1", "label": "Close with units.", "help_url": "", "hint": "Partial Credit for close value with appropriate units. &nbsp;if correct answer is 100 N and close is &plusmn;1%,<br />99 &nbsp;N is accepted.", "input_type": "percent", "default_value": "75"}, {"name": "C2", "label": "No units or wrong sign", "help_url": "", "hint": "Partial credit for forgetting units or using wrong sign.<br />If the correct answer is 100 N, both 100 and -100 N are accepted.", "input_type": "percent", "default_value": "50"}, {"name": "C3", "label": "Close, no units.", "help_url": "", "hint": "Partial Credit for close value but forgotten units.<br />This value would be close&nbsp;if the expected units were provided. &nbsp;If the correct answer is 100 N, and close is &plusmn;1%,<br />99 is accepted.", "input_type": "percent", "default_value": "25"}], "public_availability": "always", "published": true, "extensions": ["quantities"]}], "resources": [], "navigation": {"allowregen": true, "showfrontpage": false, "preventleave": false, "typeendtoleave": false}, "contributors": [{"name": "William Haynes", "profile_url": "https://numbas.mathcentre.ac.uk/accounts/profile/2530/"}], "tags": [], "metadata": {"description": "<p>Draw Shear and Bending Moment Diagrams for a simply supported or overhanging beam loaded with one or two concentrated forces.</p>", "licence": "Creative Commons Attribution-NonCommercial 4.0 International"}, "statement": "<p>{beam}</p>\n<p>{shear}</p>\n<p>{moment}</p>", "advice": "", "rulesets": {}, "builtin_constants": {"e": true, "pi,\u03c0": true, "i": true, "j": false}, "constants": [], "variables": {"properties": {"name": "properties", "group": "lists", "definition": "[beamLength: L, reactions: reactions, forces: forces,  moments: moments, loads: loads, symbols: symbols]", "description": "<p>Leave this variable the way it is, and adjust the loads using the reactions, forces, moments, loads Lists.</p>", "templateType": "anything", "can_override": false}, "F1": {"name": "F1", "group": "properties", "definition": "let(v, random_force(), \n  [x: unique_points[0], value: v, label:  abs(v) + \" \" + units[1], visible: true])", "description": "", "templateType": "anything", "can_override": false}, "F2": {"name": "F2", "group": "properties", "definition": "let(v, random_force(), \n  [x: unique_points[1], value: v, label:  abs(v) + \" \" + units[1] ,visible: true])", "description": "", "templateType": "anything", "can_override": false}, "F3": {"name": "F3", "group": "properties", "definition": "let(v, random_force(), \n  [x: 0, value: v, label: abs(v) + \" \" + units[1], visible: true])", "description": "", "templateType": "anything", "can_override": false}, "l": {"name": "l", "group": "properties", "definition": "random(10,15,20)", "description": "", "templateType": "anything", "can_override": false}, "m1": {"name": "m1", "group": "properties", "definition": "let(v, random_force(), \n  [x: 0, value: v, label: abs(v) + \" \" + units[2], visible: true])", "description": "", "templateType": "anything", "can_override": false}, "m2": {"name": "m2", "group": "properties", "definition": "let(v, random_force(), [x: 0, value: v, label: abs(v) + \" \" + units[2], visible: true])", "description": "", "templateType": "anything", "can_override": false}, "reactions": {"name": "reactions", "group": "lists", "definition": "[[x: xa, value: ra, label: \"A\", visible: false],[x: xb, value: rb, label: \"B\", visible: false]]", "description": "<p>pin, roller, fixed, dot</p>", "templateType": "anything", "can_override": false}, "w1": {"name": "w1", "group": "properties", "definition": "let(w, [dec(random(0,0.5,1) size/10) , dec(random(0,0.5,1) size/10)],\n    [[x: random(0,2,4), value: w[0] ,  label: w[0] + \" \" + units[3]], \n     [x: random(L-4,L-2,L), value: w[0] , label: w[0] + \" \" + units[3]]])", "description": "", "templateType": "anything", "can_override": false}, "beam": {"name": "beam", "group": "Ungrouped variables", "definition": "vmloaddiagram(properties)", "description": "", "templateType": "anything", "can_override": false}, "shear": {"name": "shear", "group": "Ungrouped variables", "definition": "vmsheardiagram(properties, debug)", "description": "", "templateType": "anything", "can_override": false}, "forces": {"name": "forces", "group": "lists", "definition": "weighted_random([[[F1,F2],4], [[F1],1]])", "description": "<p>single force 20% of the time</p>", "templateType": "anything", "can_override": false}, "rB": {"name": "rB", "group": "reactions", "definition": "(sum(map(f->cross( vector(xa-f[\"x\"],0,0),vector(0,f[\"value\"],0))[2],forces))\n+sum(map(f->cross( vector(xa-f[\"x\"],0,0),vector(0,f[\"value\"],0))[2],equivalent_loads))\n+ sum(map(m->m['value'], moments)))/(xa-xb)", "description": "", "templateType": "anything", "can_override": false}, "rA": {"name": "rA", "group": "reactions", "definition": "(sum(map(f->cross( vector(xb-f[\"x\"],0,0),vector(0,-f[\"value\"],0))[2],forces+equivalent_loads))\n- sum(map(m->m['value'], moments)))/(xa-xb)\n", "description": "", "templateType": "anything", "can_override": false}, "sigmaF_check": {"name": "sigmaF_check", "group": "reactions", "definition": "[foldl((total, f) -> total + f[\"value\"], 0, forces+equivalent_loads),ra+rb]\n", "description": "", "templateType": "anything", "can_override": false}, "xa": {"name": "xa", "group": "reactions", "definition": "if(F1[\"x\"]=0,2,0)", "description": "", "templateType": "anything", "can_override": false}, "xb": {"name": "xb", "group": "reactions", "definition": "if(F2[\"x\"]=L,L-4,L)", "description": "", "templateType": "anything", "can_override": false}, "moments": {"name": "moments", "group": "lists", "definition": "[]", "description": "", "templateType": "anything", "can_override": false}, "area": {"name": "area", "group": "lists", "definition": "w -> let (xa, w[0][\"x\"], xb, w[1][\"x\"], ya, w[0][\"value\"], yb, w[1][\"value\"] ,(xb-xa)(ya+yb)/2)", "description": "", "templateType": "anything", "can_override": false}, "xbar": {"name": "xbar", "group": "lists", "definition": "(w) -> let (xa, w[0][\"x\"], xb, w[1][\"x\"], ya, w[0][\"value\"], yb, w[1][\"value\"] , if(xa+xb=0, 0, xa+(xb - xa)*(ya + 2 yb)/3/(ya + yb)))", "description": "<p>gives horizontal location of centroid of distributed load w</p>", "templateType": "anything", "can_override": false}, "equivalent_loads": {"name": "equivalent_loads", "group": "lists", "definition": "map((w)->let( f , area(w), [x:  xbar(w), value: f, label: f + \" lb\"]),loads)", "description": "", "templateType": "anything", "can_override": false}, "loads": {"name": "loads", "group": "lists", "definition": "[]", "description": "", "templateType": "anything", "can_override": false}, "w2": {"name": "w2", "group": "properties", "definition": "let(w, [dec(random(0,0.5,1) size/10) , dec(random(0,0.5,1) size/10)],\n    [[x: random(0,2,4), value: w[0] ,  label: w[0] + \" \" + units[3]], \n     [x: random(L-4,L-2,L), value: w[1] , label: w[1] + \" \" + units[3]]])", "description": "", "templateType": "anything", "can_override": false}, "moment": {"name": "moment", "group": "Ungrouped variables", "definition": "vmmomentdiagram(properties, debug)", "description": "", "templateType": "anything", "can_override": false}, "symbols": {"name": "symbols", "group": "lists", "definition": "[[type: \"pin\", x: xa, label: \"$R_A$\", visible: true], [type: \"roller\", x: xb, label: \"$R_B$\", visible: true]]", "description": "<p>legal types: pin, roller, dot, fixed</p>", "templateType": "anything", "can_override": false}, "InterestingShearPoints": {"name": "InterestingShearPoints", "group": "Ungrouped variables", "definition": "vmshearpoints(properties)", "description": "", "templateType": "anything", "can_override": false}, "InterestingMomentPoints": {"name": "InterestingMomentPoints", "group": "Ungrouped variables", "definition": "vmmomentpoints(properties)", "description": "", "templateType": "anything", "can_override": false}, "vmax": {"name": "vmax", "group": "Ungrouped variables", "definition": "let( max, max(map(p ->p[1], interestingshearpoints)),\n  min, min(map(p ->p[1], interestingshearpoints)),\n  if(abs(max)>abs(min), max, min))", "description": "", "templateType": "anything", "can_override": false}, "mmax": {"name": "mmax", "group": "Ungrouped variables", "definition": "let( max, max(map(p ->p[1], interestingmomentpoints)),\n  min, min(map(p ->p[1], interestingmomentpoints)),\n  if(abs(max)>abs(min), max, min))", "description": "", "templateType": "anything", "can_override": false}, "unique_points": {"name": "unique_points", "group": "properties", "definition": "sort(shuffle(0..L)[0..2])", "description": "", "templateType": "anything", "can_override": false}, "MomentCheck": {"name": "MomentCheck", "group": "reactions", "definition": "siground((\n  sum(map(f->cross( vector(L-f[\"x\"],0,0),vector(0,-f[\"value\"],0))[2],forces+equivalent_loads))\n- sum(map(f->cross(vector(L-f[\"x\"],0,0),vector(0,-f[\"value\"],0))[2],reactions))\n- sum(map(m->m['value'], moments))),6)", "description": "", "templateType": "anything", "can_override": false}, "units": {"name": "units", "group": "Ungrouped variables", "definition": "random(['ft','lb', 'ft*lb', 'lb/ft'],['m','kN', 'kN*m', 'kN/m'])", "description": "", "templateType": "anything", "can_override": false}, "size": {"name": "size", "group": "reactions", "definition": "random(10,50,100,150,200)", "description": "", "templateType": "anything", "can_override": false}, "random_force": {"name": "random_force", "group": "reactions", "definition": "() -> round(size * random(-1..1.5#0.1 except 0))", "description": "<p>gives values of about the same order of magnitude.</p>", "templateType": "anything", "can_override": false}, "debug": {"name": "debug", "group": "Ungrouped variables", "definition": "false", "description": "", "templateType": "anything", "can_override": false}}, "variablesTest": {"condition": "unique_points[1]-unique_points[0] > 4 and// make sure the forces aren't to close to each other\nrb > 1  // roller force is positive", "maxRuns": 100}, "ungrouped_variables": ["beam", "shear", "moment", "InterestingShearPoints", "InterestingMomentPoints", "vmax", "mmax", "units", "debug"], "variable_groups": [{"name": "reactions", "variables": ["xa", "xb", "rB", "rA", "sigmaF_check", "MomentCheck", "size", "random_force"]}, {"name": "properties", "variables": ["l", "F1", "F2", "F3", "m1", "m2", "w1", "w2", "unique_points"]}, {"name": "lists", "variables": ["properties", "reactions", "forces", "loads", "moments", "equivalent_loads", "symbols", "area", "xbar"]}], "functions": {}, "preamble": {"js": "question.signals.on('adviceDisplayed', () => {\n  ['moment','shear'].forEach((board) => {\n  var objects = question.scope.getVariable(board).board.objects;\n  objects.Curve.setAttribute({visible: true});\n  Object.keys(objects).filter(k => k.startsWith('Point-')).forEach((k) => objects[k].setAttribute({visible: true}));\n  Object.keys(objects).filter(k => k.startsWith('Jump-')).forEach((k) => objects[k].setAttribute({visible: true}));\n});\n});\n", "css": ""}, "parts": [{"type": "gapfill", "useCustomName": false, "customName": "", "marks": 0, "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": true, "showFeedbackIcon": true, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "prompt": "<p>Draw the shear and bending moment diagrams and determine:</p>\n<p><strong>Reactions: </strong>Upward forces positive, downward negative.</p>\n<p>$A = $ [[0]]</p>\n<p>$B = $ [[1]]</p>\n<p><strong>Maximum Shear and Bending Moment: </strong>Positive or negative using the standard sign convention</p>\n<p>$V_\\text{max} = $ [[2]]</p>\n<p>$M_\\text{max} = $ [[3]]</p>", "gaps": [{"type": "engineering-answer", "useCustomName": true, "customName": "$A$", "marks": "5", "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": true, "showFeedbackIcon": true, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "settings": {"correctAnswer": "qty(ra,units[1])", "right": "0.2", "close": "1.0", "C1": "75", "C2": "50", "C3": "25"}}, {"type": "engineering-answer", "useCustomName": true, "customName": "$B$", "marks": "5", "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": true, "showFeedbackIcon": true, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "settings": {"correctAnswer": "qty(rb,units[1])", "right": "0.2", "close": "1.0", "C1": "75", "C2": "50", "C3": "25"}}, {"type": "engineering-answer", "useCustomName": true, "customName": "$V_\\text{max}$", "marks": "5", "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": true, "showFeedbackIcon": true, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "settings": {"correctAnswer": "qty(vmax, units[1])", "right": "0.2", "close": "1.0", "C1": "75", "C2": "50", "C3": "25"}}, {"type": "engineering-answer", "useCustomName": true, "customName": "$M_\\text{max}$", "marks": "5", "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": true, "showFeedbackIcon": true, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "settings": {"correctAnswer": "qty(mmax, units[1])", "right": "0.2", "close": "1.0", "C1": "75", "C2": "50", "C3": "25"}}], "sortAnswers": false}], "partsMode": "all", "maxMarks": 0, "objectives": [], "penalties": [], "objectiveVisibility": "always", "penaltyVisibility": "always"}, {"name": "VM2: Concentrated Moment", "extensions": ["jsxgraph", "quantities", "shear-and-bending-moment-diagrams"], "custom_part_types": [{"source": {"pk": 19, "author": {"name": "William Haynes", "pk": 2530}, "edit_page": "/part_type/19/edit"}, "name": "Engineering Accuracy with units", "short_name": "engineering-answer", "description": "<p>A value with units marked right if within an adjustable % error of the correct value. &nbsp;Marked close if within a wider margin of error.</p>", "help_url": "", "input_widget": "string", "input_options": {"correctAnswer": "siground(settings['correctAnswer'],4)", "hint": {"static": true, "value": ""}, "allowEmpty": {"static": true, "value": true}}, "can_be_gap": true, "can_be_step": true, "marking_script": "mark:\nswitch( \n  right and good_units and right_sign, add_credit(1.0,'Correct.'),\n  right and good_units and not right_sign, add_credit(settings['C2'],'Wrong sign.'),\n  right and right_sign and not good_units, add_credit(settings['C2'],'Correct value, but wrong or missing units.'),\n  close and good_units, add_credit(settings['C1'],'Close.'),\n  close and not good_units, add_credit(settings['C3'],'Answer is close, but wrong or missing units.'),\n  incorrect('Wrong answer.')\n)\n\ninterpreted_answer:\nqty(student_scalar, student_units)\n\n\n\ncorrect_quantity:\nsettings[\"correctAnswer\"]\n\n\n\ncorrect_units:\nunits(correct_quantity)\n\n\nallowed_notation_styles:\n[\"plain\",\"en\"]\n\nmatch_student_number:\nmatchnumber(studentAnswer,allowed_notation_styles)\n\nstudent_scalar:\nmatch_student_number[1]\n\nstudent_units:\nreplace_regex('ohms','ohm',\n  replace_regex('\u00b0', ' deg',\n    replace_regex('-', ' ' ,\n      studentAnswer[len(match_student_number[0])..len(studentAnswer)])),\"i\")\n\ngood_units:\ntry(\ncompatible(quantity(1, student_units),correct_units),\nmsg,\nfeedback(msg);false)\n\n\nstudent_quantity:\nswitch(not good_units, \n       student_scalar * correct_units, \n       not right_sign,\n       -quantity(student_scalar, student_units),\n       quantity(student_scalar,student_units)\n)\n  \n\n\npercent_error:\ntry(\nscalar(abs((correct_quantity - student_quantity)/correct_quantity))*100  \n,msg,\nif(student_quantity=correct_quantity,0,100))\n   \n\nright:\npercent_error <= settings['right']\n\n\nclose:\nright_sign and percent_error <= settings['close']\n\nright_sign:\nsign(student_scalar) = sign(correct_quantity)", "marking_notes": [{"name": "mark", "description": "This is the main marking note. It should award credit and provide feedback based on the student's answer.", "definition": "switch( \n  right and good_units and right_sign, add_credit(1.0,'Correct.'),\n  right and good_units and not right_sign, add_credit(settings['C2'],'Wrong sign.'),\n  right and right_sign and not good_units, add_credit(settings['C2'],'Correct value, but wrong or missing units.'),\n  close and good_units, add_credit(settings['C1'],'Close.'),\n  close and not good_units, add_credit(settings['C3'],'Answer is close, but wrong or missing units.'),\n  incorrect('Wrong answer.')\n)"}, {"name": "interpreted_answer", "description": "A value representing the student's answer to this part.", "definition": "qty(student_scalar, student_units)\n\n"}, {"name": "correct_quantity", "description": "", "definition": "settings[\"correctAnswer\"]\n\n"}, {"name": "correct_units", "description": "", "definition": "units(correct_quantity)\n"}, {"name": "allowed_notation_styles", "description": "", "definition": "[\"plain\",\"en\"]"}, {"name": "match_student_number", "description": "", "definition": "matchnumber(studentAnswer,allowed_notation_styles)"}, {"name": "student_scalar", "description": "", "definition": "match_student_number[1]"}, {"name": "student_units", "description": "<p>Modify&nbsp;the&nbsp;unit portion of&nbsp;the student's answer by</p>\n<p>1. replacing \"ohms\" with \"ohm\" &nbsp;case insensitive</p>\n<p>2.&nbsp;replacing '-'&nbsp;with ' '&nbsp;</p>\n<p>3. replacing '&deg;' with ' deg'&nbsp;</p>\n<p>to allow answers like 10 ft-lb and 30&deg;</p>", "definition": "replace_regex('ohms','ohm',\n  replace_regex('\u00b0', ' deg',\n    replace_regex('-', ' ' ,\n      studentAnswer[len(match_student_number[0])..len(studentAnswer)])),\"i\")"}, {"name": "good_units", "description": "", "definition": "try(\ncompatible(quantity(1, student_units),correct_units),\nmsg,\nfeedback(msg);false)\n"}, {"name": "student_quantity", "description": "<p>This fixes the student answer for two common errors. &nbsp;</p>\n<p>If student_units are wrong&nbsp;&nbsp;- replace with correct units</p>\n<p>If student_scalar has the wrong sign - replace with right sign</p>\n<p>If student makes both errors, only one gets fixed.</p>", "definition": "switch(not good_units, \n       student_scalar * correct_units, \n       not right_sign,\n       -quantity(student_scalar, student_units),\n       quantity(student_scalar,student_units)\n)\n  \n"}, {"name": "percent_error", "description": "", "definition": "try(\nscalar(abs((correct_quantity - student_quantity)/correct_quantity))*100  \n,msg,\nif(student_quantity=correct_quantity,0,100))\n   "}, {"name": "right", "description": "", "definition": "percent_error <= settings['right']\n"}, {"name": "close", "description": "<p>Only marked close if the student actually has the right sign.</p>", "definition": "right_sign and percent_error <= settings['close']"}, {"name": "right_sign", "description": "", "definition": "sign(student_scalar) = sign(correct_quantity) "}], "settings": [{"name": "correctAnswer", "label": "Correct Quantity.", "help_url": "", "hint": "The correct answer given as a JME quantity.", "input_type": "code", "default_value": "", "evaluate": true}, {"name": "right", "label": "% Accuracy for right.", "help_url": "", "hint": "Question will be considered correct if the scalar part of the student's answer is within this % of correct value.", "input_type": "code", "default_value": "0.2", "evaluate": true}, {"name": "close", "label": "% Accuracy for close.", "help_url": "", "hint": "Question will be considered close if the scalar part of the student's answer is within this % of correct value.", "input_type": "code", "default_value": "1.0", "evaluate": true}, {"name": "C1", "label": "Close with units.", "help_url": "", "hint": "Partial Credit for close value with appropriate units. &nbsp;if correct answer is 100 N and close is &plusmn;1%,<br />99 &nbsp;N is accepted.", "input_type": "percent", "default_value": "75"}, {"name": "C2", "label": "No units or wrong sign", "help_url": "", "hint": "Partial credit for forgetting units or using wrong sign.<br />If the correct answer is 100 N, both 100 and -100 N are accepted.", "input_type": "percent", "default_value": "50"}, {"name": "C3", "label": "Close, no units.", "help_url": "", "hint": "Partial Credit for close value but forgotten units.<br />This value would be close&nbsp;if the expected units were provided. &nbsp;If the correct answer is 100 N, and close is &plusmn;1%,<br />99 is accepted.", "input_type": "percent", "default_value": "25"}], "public_availability": "always", "published": true, "extensions": ["quantities"]}], "resources": [], "navigation": {"allowregen": true, "showfrontpage": false, "preventleave": false, "typeendtoleave": false}, "contributors": [{"name": "William Haynes", "profile_url": "https://numbas.mathcentre.ac.uk/accounts/profile/2530/"}], "tags": [], "metadata": {"description": "<p>Draw Shear and Bending Moment Diagrams for a cantilever beam with two forces and a concentrated moment load.</p>", "licence": "Creative Commons Attribution-NonCommercial 4.0 International"}, "statement": "<p>For the beam and loading shown, determine the reactions, draw the shear and bending moment diagram, and find the maximum shear and bending moment.</p>\n<p></p>\n<p></p>\n<p>{beam}</p>\n<p>{shear}</p>\n<p>{moment}</p>\n<p></p>", "advice": "", "rulesets": {}, "builtin_constants": {"e": true, "pi,\u03c0": true, "i": true, "j": false}, "constants": [], "variables": {"properties": {"name": "properties", "group": "lists", "definition": "[beamLength: L, reactions: reactions, forces: forces,  moments: moments, loads: loads, symbols: symbols]", "description": "<p>Leave this variable the way it is, and adjust the loads using the reactions, forces, moments, loads Lists.</p>", "templateType": "anything", "can_override": false}, "F1": {"name": "F1", "group": "properties", "definition": "let(v, random_force(), \n  [x: unique_points[0], value: v, label:  abs(v) + \" \" + units[1], visible: true])", "description": "", "templateType": "anything", "can_override": false}, "F2": {"name": "F2", "group": "properties", "definition": "let(v, random_force(), \n  [x: unique_points[1], value: v, label:  abs(v) + \" \" + units[1] ,visible: true])", "description": "", "templateType": "anything", "can_override": false}, "F3": {"name": "F3", "group": "properties", "definition": "let(v, random_force(), \n  [x: 0, value: v, label: abs(v) + \" \" + units[1], visible: true])", "description": "", "templateType": "anything", "can_override": false}, "l": {"name": "l", "group": "properties", "definition": "random(6,8,10,12)", "description": "", "templateType": "anything", "can_override": false}, "m1": {"name": "m1", "group": "properties", "definition": "let(v, random_force() 1.5 L, \n  [x: unique_points[2], value: v, label: abs(v) + \" \" + units[2], visible: true])", "description": "", "templateType": "anything", "can_override": false}, "m2": {"name": "m2", "group": "properties", "definition": "let(v, rb, [x: 0, value: v, label: abs(v) + \" \" + units[2], visible: false])", "description": "", "templateType": "anything", "can_override": false}, "reactions": {"name": "reactions", "group": "lists", "definition": "[[x: xa, value: ra, label: \"A\", visible: false]]", "description": "<p>pin, roller, fixed, dot</p>", "templateType": "anything", "can_override": false}, "w1": {"name": "w1", "group": "properties", "definition": "let(w, [dec(random(0,0.5,1) size/10) , dec(random(0,0.5,1) size/10)],\n    [[x: random(0,2,4), value: w[0] ,  label: w[0] + \" \" + units[3]], \n     [x: random(L-4,L-2,L), value: w[0] , label: w[0] + \" \" + units[3]]])", "description": "", "templateType": "anything", "can_override": false}, "beam": {"name": "beam", "group": "Ungrouped variables", "definition": "vmloaddiagram(properties)", "description": "", "templateType": "anything", "can_override": false}, "shear": {"name": "shear", "group": "Ungrouped variables", "definition": "vmsheardiagram(properties, debug)", "description": "", "templateType": "anything", "can_override": false}, "forces": {"name": "forces", "group": "lists", "definition": "[F1,F2]", "description": "", "templateType": "anything", "can_override": false}, "rB": {"name": "rB", "group": "reactions", "definition": "-(sum(map(f->cross( vector(xa-f[\"x\"],0,0),vector(0,f[\"value\"],0))[2],forces))\n+sum(map(f->cross( vector(xa-f[\"x\"],0,0),vector(0,f[\"value\"],0))[2],equivalent_loads))\n+ m1[\"value\"])", "description": "<p style=\"text-align: left;\">Finds reaction moment</p>", "templateType": "anything", "can_override": false}, "rA": {"name": "rA", "group": "reactions", "definition": "f1['value'] + f2['value']\n//(sum(map(f->cross( vector(xb-f[\"x\"],0,0),vector(0,-f[\"value\"],0))[2],forces+equivalent_loads))\n//- sum(map(m->m['value'], moments)))/(xa-xb)\n", "description": "", "templateType": "anything", "can_override": false}, "sigmaF_check": {"name": "sigmaF_check", "group": "reactions", "definition": "[foldl((total, f) -> total + f[\"value\"], 0, forces+equivalent_loads),ra+rb]\n", "description": "", "templateType": "anything", "can_override": false}, "xa": {"name": "xa", "group": "reactions", "definition": "if(F1[\"x\"]=0,2,0)", "description": "", "templateType": "anything", "can_override": false}, "xb": {"name": "xb", "group": "reactions", "definition": "if(unique_points[-1]=L,L-2,L)", "description": "", "templateType": "anything", "can_override": false}, "moments": {"name": "moments", "group": "lists", "definition": "[m1,m2]", "description": "", "templateType": "anything", "can_override": false}, "area": {"name": "area", "group": "lists", "definition": "w -> let (xa, w[0][\"x\"], xb, w[1][\"x\"], ya, w[0][\"value\"], yb, w[1][\"value\"] ,(xb-xa)(ya+yb)/2)", "description": "", "templateType": "anything", "can_override": false}, "xbar": {"name": "xbar", "group": "lists", "definition": "(w) -> let (xa, w[0][\"x\"], xb, w[1][\"x\"], ya, w[0][\"value\"], yb, w[1][\"value\"] , if(xa+xb=0, 0, xa+(xb - xa)*(ya + 2 yb)/3/(ya + yb)))", "description": "<p>gives horizontal location of centroid of distributed load w</p>", "templateType": "anything", "can_override": false}, "equivalent_loads": {"name": "equivalent_loads", "group": "lists", "definition": "map((w)->let( f , area(w), [x:  xbar(w), value: f, label: f + \" lb\"]),loads)", "description": "", "templateType": "anything", "can_override": false}, "loads": {"name": "loads", "group": "lists", "definition": "[]", "description": "", "templateType": "anything", "can_override": false}, "w2": {"name": "w2", "group": "properties", "definition": "let(w, [dec(random(0,0.5,1) size/10) , dec(random(0,0.5,1) size/10)],\n    [[x: random(0,2,4), value: w[0] ,  label: w[0] + \" \" + units[3]], \n     [x: random(L-4,L-2,L), value: w[1] , label: w[1] + \" \" + units[3]]])", "description": "", "templateType": "anything", "can_override": false}, "moment": {"name": "moment", "group": "Ungrouped variables", "definition": "vmmomentdiagram(properties, debug)", "description": "", "templateType": "anything", "can_override": false}, "symbols": {"name": "symbols", "group": "lists", "definition": "[[type: \"fixed\", x: xa, label: \"$A$\", visible: true]]", "description": "<p>legal types: pin, roller, dot, fixed</p>", "templateType": "anything", "can_override": false}, "InterestingShearPoints": {"name": "InterestingShearPoints", "group": "Ungrouped variables", "definition": "vmshearpoints(properties)", "description": "", "templateType": "anything", "can_override": false}, "InterestingMomentPoints": {"name": "InterestingMomentPoints", "group": "Ungrouped variables", "definition": "vmmomentpoints(properties)", "description": "", "templateType": "anything", "can_override": false}, "vmax": {"name": "vmax", "group": "Ungrouped variables", "definition": "let( max, max(map(p ->p[1], InterestingshearPoints)),\n  min, min(map(p ->p[1], InterestingshearPoints)),\n  if(abs(max)>abs(min), max, min))", "description": "", "templateType": "anything", "can_override": false}, "mmax": {"name": "mmax", "group": "Ungrouped variables", "definition": "let( max, max(map(p ->p[1], interestingmomentpoints)),\n  min, min(map(p ->p[1], interestingmomentpoints)),\n  if(abs(max)>abs(min), max, min))", "description": "", "templateType": "anything", "can_override": false}, "unique_points": {"name": "unique_points", "group": "reactions", "definition": "shuffle(shuffle(2..L-2)[0..2] + [L])", "description": "", "templateType": "anything", "can_override": false}, "MomentCheck": {"name": "MomentCheck", "group": "reactions", "definition": "siground((\n  sum(map(f->cross( vector(L-f[\"x\"],0,0),vector(0,-f[\"value\"],0))[2],forces+equivalent_loads))\n- sum(map(f->cross(vector(L-f[\"x\"],0,0),vector(0,-f[\"value\"],0))[2],reactions))\n- sum(map(m->m['value'], moments))),6)", "description": "", "templateType": "anything", "can_override": false}, "units": {"name": "units", "group": "Ungrouped variables", "definition": "random(['ft','lb', 'ft*lb', 'lb/ft'],['m','kN', 'kN*m', 'kN/m'])", "description": "", "templateType": "anything", "can_override": false}, "size": {"name": "size", "group": "reactions", "definition": "random(100,200,200,300,500)", "description": "", "templateType": "anything", "can_override": false}, "random_force": {"name": "random_force", "group": "reactions", "definition": "() -> toNearest(size * random(0.5..1.5#0.1 except 0), 10)", "description": "<p>gives values of about the same order of magnitude.</p>", "templateType": "anything", "can_override": false}, "test": {"name": "test", "group": "Ungrouped variables", "definition": "qty(rb,units[2])", "description": "", "templateType": "anything", "can_override": false}, "debug": {"name": "debug", "group": "Ungrouped variables", "definition": "false", "description": "", "templateType": "anything", "can_override": false}}, "variablesTest": {"condition": "abs(f1[\"x\"] -f2[\"x\"]) > 1 // forces aren't too close together", "maxRuns": 100}, "ungrouped_variables": ["beam", "shear", "moment", "InterestingShearPoints", "InterestingMomentPoints", "vmax", "mmax", "units", "test", "debug"], "variable_groups": [{"name": "reactions", "variables": ["xa", "xb", "rB", "rA", "sigmaF_check", "MomentCheck", "size", "unique_points", "random_force"]}, {"name": "properties", "variables": ["l", "F1", "F2", "F3", "m1", "m2", "w1", "w2"]}, {"name": "lists", "variables": ["properties", "reactions", "forces", "loads", "moments", "equivalent_loads", "symbols", "area", "xbar"]}], "functions": {}, "preamble": {"js": "question.signals.on('adviceDisplayed', () => {\n  ['moment','shear'].forEach((board) => {\n  var objects = question.scope.getVariable(board).board.objects;\n  objects.Curve.setAttribute({visible: true});\n  Object.keys(objects).filter(k => k.startsWith('Point-')).forEach((k) => objects[k].setAttribute({visible: true}));\n  Object.keys(objects).filter(k => k.startsWith('Jump-')).forEach((k) => objects[k].setAttribute({visible: true}));\n});\n});\n", "css": ""}, "parts": [{"type": "gapfill", "useCustomName": false, "customName": "", "marks": 0, "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": true, "showFeedbackIcon": true, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "prompt": "<p><strong>Reactions: </strong>Upward forces positive, downward negative.</p>\n<p>$A = $ [[0]]</p>\n<p>$M_A = $ [[1]]</p>\n<p><strong>Maximum Shear and Bending Moment: </strong>Positive or negative using the standard sign convention</p>\n<p>$V_\\text{max} = $ [[2]]</p>\n<p>$M_\\text{max} = $ [[3]]</p>\n<p><strong></strong></p>", "gaps": [{"type": "engineering-answer", "useCustomName": true, "customName": "$A$", "marks": "5", "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": true, "showFeedbackIcon": true, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "settings": {"correctAnswer": "qty(ra,units[1])", "right": "0.2", "close": "1.0", "C1": "75", "C2": "50", "C3": "25"}}, {"type": "engineering-answer", "useCustomName": true, "customName": "$M_A$", "marks": "5", "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": true, "showFeedbackIcon": true, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "settings": {"correctAnswer": "qty(rb,units[2])", "right": "0.2", "close": "1.0", "C1": "75", "C2": "50", "C3": "25"}}, {"type": "engineering-answer", "useCustomName": true, "customName": "$V_\\text{max}$", "marks": "5", "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": true, "showFeedbackIcon": true, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "settings": {"correctAnswer": "qty(vmax, units[1])", "right": "0.2", "close": "1.0", "C1": "75", "C2": "50", "C3": "25"}}, {"type": "engineering-answer", "useCustomName": true, "customName": "$M_\\text{max}$", "marks": "5", "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": true, "showFeedbackIcon": true, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "settings": {"correctAnswer": "qty(mmax, units[1])", "right": "0.2", "close": "1.0", "C1": "75", "C2": "50", "C3": "25"}}], "sortAnswers": false}], "partsMode": "all", "maxMarks": 0, "objectives": [], "penalties": [], "objectiveVisibility": "always", "penaltyVisibility": "always"}, {"name": "VM3: Distributed Loads", "extensions": ["jsxgraph", "quantities", "shear-and-bending-moment-diagrams"], "custom_part_types": [{"source": {"pk": 19, "author": {"name": "William Haynes", "pk": 2530}, "edit_page": "/part_type/19/edit"}, "name": "Engineering Accuracy with units", "short_name": "engineering-answer", "description": "<p>A value with units marked right if within an adjustable % error of the correct value. &nbsp;Marked close if within a wider margin of error.</p>", "help_url": "", "input_widget": "string", "input_options": {"correctAnswer": "siground(settings['correctAnswer'],4)", "hint": {"static": true, "value": ""}, "allowEmpty": {"static": true, "value": true}}, "can_be_gap": true, "can_be_step": true, "marking_script": "mark:\nswitch( \n  right and good_units and right_sign, add_credit(1.0,'Correct.'),\n  right and good_units and not right_sign, add_credit(settings['C2'],'Wrong sign.'),\n  right and right_sign and not good_units, add_credit(settings['C2'],'Correct value, but wrong or missing units.'),\n  close and good_units, add_credit(settings['C1'],'Close.'),\n  close and not good_units, add_credit(settings['C3'],'Answer is close, but wrong or missing units.'),\n  incorrect('Wrong answer.')\n)\n\ninterpreted_answer:\nqty(student_scalar, student_units)\n\n\n\ncorrect_quantity:\nsettings[\"correctAnswer\"]\n\n\n\ncorrect_units:\nunits(correct_quantity)\n\n\nallowed_notation_styles:\n[\"plain\",\"en\"]\n\nmatch_student_number:\nmatchnumber(studentAnswer,allowed_notation_styles)\n\nstudent_scalar:\nmatch_student_number[1]\n\nstudent_units:\nreplace_regex('ohms','ohm',\n  replace_regex('\u00b0', ' deg',\n    replace_regex('-', ' ' ,\n      studentAnswer[len(match_student_number[0])..len(studentAnswer)])),\"i\")\n\ngood_units:\ntry(\ncompatible(quantity(1, student_units),correct_units),\nmsg,\nfeedback(msg);false)\n\n\nstudent_quantity:\nswitch(not good_units, \n       student_scalar * correct_units, \n       not right_sign,\n       -quantity(student_scalar, student_units),\n       quantity(student_scalar,student_units)\n)\n  \n\n\npercent_error:\ntry(\nscalar(abs((correct_quantity - student_quantity)/correct_quantity))*100  \n,msg,\nif(student_quantity=correct_quantity,0,100))\n   \n\nright:\npercent_error <= settings['right']\n\n\nclose:\nright_sign and percent_error <= settings['close']\n\nright_sign:\nsign(student_scalar) = sign(correct_quantity)", "marking_notes": [{"name": "mark", "description": "This is the main marking note. It should award credit and provide feedback based on the student's answer.", "definition": "switch( \n  right and good_units and right_sign, add_credit(1.0,'Correct.'),\n  right and good_units and not right_sign, add_credit(settings['C2'],'Wrong sign.'),\n  right and right_sign and not good_units, add_credit(settings['C2'],'Correct value, but wrong or missing units.'),\n  close and good_units, add_credit(settings['C1'],'Close.'),\n  close and not good_units, add_credit(settings['C3'],'Answer is close, but wrong or missing units.'),\n  incorrect('Wrong answer.')\n)"}, {"name": "interpreted_answer", "description": "A value representing the student's answer to this part.", "definition": "qty(student_scalar, student_units)\n\n"}, {"name": "correct_quantity", "description": "", "definition": "settings[\"correctAnswer\"]\n\n"}, {"name": "correct_units", "description": "", "definition": "units(correct_quantity)\n"}, {"name": "allowed_notation_styles", "description": "", "definition": "[\"plain\",\"en\"]"}, {"name": "match_student_number", "description": "", "definition": "matchnumber(studentAnswer,allowed_notation_styles)"}, {"name": "student_scalar", "description": "", "definition": "match_student_number[1]"}, {"name": "student_units", "description": "<p>Modify&nbsp;the&nbsp;unit portion of&nbsp;the student's answer by</p>\n<p>1. replacing \"ohms\" with \"ohm\" &nbsp;case insensitive</p>\n<p>2.&nbsp;replacing '-'&nbsp;with ' '&nbsp;</p>\n<p>3. replacing '&deg;' with ' deg'&nbsp;</p>\n<p>to allow answers like 10 ft-lb and 30&deg;</p>", "definition": "replace_regex('ohms','ohm',\n  replace_regex('\u00b0', ' deg',\n    replace_regex('-', ' ' ,\n      studentAnswer[len(match_student_number[0])..len(studentAnswer)])),\"i\")"}, {"name": "good_units", "description": "", "definition": "try(\ncompatible(quantity(1, student_units),correct_units),\nmsg,\nfeedback(msg);false)\n"}, {"name": "student_quantity", "description": "<p>This fixes the student answer for two common errors. &nbsp;</p>\n<p>If student_units are wrong&nbsp;&nbsp;- replace with correct units</p>\n<p>If student_scalar has the wrong sign - replace with right sign</p>\n<p>If student makes both errors, only one gets fixed.</p>", "definition": "switch(not good_units, \n       student_scalar * correct_units, \n       not right_sign,\n       -quantity(student_scalar, student_units),\n       quantity(student_scalar,student_units)\n)\n  \n"}, {"name": "percent_error", "description": "", "definition": "try(\nscalar(abs((correct_quantity - student_quantity)/correct_quantity))*100  \n,msg,\nif(student_quantity=correct_quantity,0,100))\n   "}, {"name": "right", "description": "", "definition": "percent_error <= settings['right']\n"}, {"name": "close", "description": "<p>Only marked close if the student actually has the right sign.</p>", "definition": "right_sign and percent_error <= settings['close']"}, {"name": "right_sign", "description": "", "definition": "sign(student_scalar) = sign(correct_quantity) "}], "settings": [{"name": "correctAnswer", "label": "Correct Quantity.", "help_url": "", "hint": "The correct answer given as a JME quantity.", "input_type": "code", "default_value": "", "evaluate": true}, {"name": "right", "label": "% Accuracy for right.", "help_url": "", "hint": "Question will be considered correct if the scalar part of the student's answer is within this % of correct value.", "input_type": "code", "default_value": "0.2", "evaluate": true}, {"name": "close", "label": "% Accuracy for close.", "help_url": "", "hint": "Question will be considered close if the scalar part of the student's answer is within this % of correct value.", "input_type": "code", "default_value": "1.0", "evaluate": true}, {"name": "C1", "label": "Close with units.", "help_url": "", "hint": "Partial Credit for close value with appropriate units. &nbsp;if correct answer is 100 N and close is &plusmn;1%,<br />99 &nbsp;N is accepted.", "input_type": "percent", "default_value": "75"}, {"name": "C2", "label": "No units or wrong sign", "help_url": "", "hint": "Partial credit for forgetting units or using wrong sign.<br />If the correct answer is 100 N, both 100 and -100 N are accepted.", "input_type": "percent", "default_value": "50"}, {"name": "C3", "label": "Close, no units.", "help_url": "", "hint": "Partial Credit for close value but forgotten units.<br />This value would be close&nbsp;if the expected units were provided. &nbsp;If the correct answer is 100 N, and close is &plusmn;1%,<br />99 is accepted.", "input_type": "percent", "default_value": "25"}], "public_availability": "always", "published": true, "extensions": ["quantities"]}], "resources": [], "navigation": {"allowregen": true, "showfrontpage": false, "preventleave": false, "typeendtoleave": false}, "contributors": [{"name": "William Haynes", "profile_url": "https://numbas.mathcentre.ac.uk/accounts/profile/2530/"}], "tags": [], "metadata": {"description": "<p>Draw Shear and Bending Moment Diagrams for a simply supported beam with one or two uniformly distributed loads.</p>", "licence": "Creative Commons Attribution-NonCommercial 4.0 International"}, "statement": "<p>{beam}</p>\n<p>{shear}</p>\n<p>{moment}</p>", "advice": "", "rulesets": {}, "builtin_constants": {"e": true, "pi,\u03c0": true, "i": true, "j": false}, "constants": [], "variables": {"properties": {"name": "properties", "group": "lists", "definition": "[beamLength: L, reactions: reactions, forces: forces,  moments: moments, loads: loads, symbols: symbols]", "description": "<p>Leave this variable the way it is, and adjust the loads using the reactions, forces, moments, loads Lists.</p>", "templateType": "anything", "can_override": false}, "F1": {"name": "F1", "group": "properties", "definition": "let(v, random_force(), \n  [x: unique_points[0], value: v, label:  abs(v) + \" \" + units[1], visible: true])", "description": "", "templateType": "anything", "can_override": false}, "F2": {"name": "F2", "group": "properties", "definition": "let(v, random_force(), \n  [x: unique_points[1], value: v, label:  abs(v) + \" \" + units[1] ,visible: true])", "description": "", "templateType": "anything", "can_override": false}, "F3": {"name": "F3", "group": "properties", "definition": "let(v, random_force(), \n  [x: 0, value: v, label: abs(v) + \" \" + units[1], visible: true])", "description": "", "templateType": "anything", "can_override": false}, "l": {"name": "l", "group": "properties", "definition": "random(20,24)", "description": "", "templateType": "anything", "can_override": false}, "m1": {"name": "m1", "group": "properties", "definition": "let(v, random_force(), \n  [x: 0, value: v, label: abs(v) + \" \" + units[2], visible: true])", "description": "", "templateType": "anything", "can_override": false}, "m2": {"name": "m2", "group": "properties", "definition": "let(v, random_force(), [x: 0, value: v, label: abs(v) + \" \" + units[2], visible: true])", "description": "", "templateType": "anything", "can_override": false}, "reactions": {"name": "reactions", "group": "lists", "definition": "[[x: xa, value: ra, label: \"A\", visible: false],[x: xb, value: rb, label: \"B\", visible: false]]", "description": "<p>pin, roller, fixed, dot</p>", "templateType": "anything", "can_override": false}, "w1": {"name": "w1", "group": "properties", "definition": "let(w, random_force(),\n[\n    [x:0, value: w ,  label: w+\" \" + units[3], visible: true], \n    [x: L, value: w , label: \"\" ]\n])", "description": "<p>case 1: single load of length of beam</p>", "templateType": "anything", "can_override": false}, "beam": {"name": "beam", "group": "Ungrouped variables", "definition": "vmloaddiagram(properties)", "description": "", "templateType": "anything", "can_override": false}, "shear": {"name": "shear", "group": "Ungrouped variables", "definition": "vmsheardiagram(properties, debug)", "description": "", "templateType": "anything", "can_override": false}, "forces": {"name": "forces", "group": "lists", "definition": "[]", "description": "", "templateType": "anything", "can_override": false}, "rB": {"name": "rB", "group": "reactions", "definition": "(sum(map(f->cross( vector(xa-f[\"x\"],0,0),vector(0,f[\"value\"],0))[2],forces))\n+sum(map(f->cross( vector(xa-f[\"x\"],0,0),vector(0,f[\"value\"],0))[2],equivalent_loads))\n+ sum(map(m->m['value'], moments)))/(xa-xb)", "description": "", "templateType": "anything", "can_override": false}, "rA": {"name": "rA", "group": "reactions", "definition": "(sum(map(f->cross( vector(xb-f[\"x\"],0,0),vector(0,-f[\"value\"],0))[2],forces+equivalent_loads))\n- sum(map(m->m['value'], moments)))/(xa-xb)\n", "description": "", "templateType": "anything", "can_override": false}, "sigmaF_check": {"name": "sigmaF_check", "group": "reactions", "definition": "[foldl((total, f) -> total + f[\"value\"], 0, forces+equivalent_loads),ra+rb]\n", "description": "", "templateType": "anything", "can_override": false}, "xa": {"name": "xa", "group": "reactions", "definition": "if(F1[\"x\"]=0,random(2,4,6),0)", "description": "", "templateType": "anything", "can_override": false}, "xb": {"name": "xb", "group": "reactions", "definition": "if(unique_points[-1]=L,L - random(2,4,6) ,L)", "description": "", "templateType": "anything", "can_override": false}, "moments": {"name": "moments", "group": "lists", "definition": "[]", "description": "", "templateType": "anything", "can_override": false}, "area": {"name": "area", "group": "lists", "definition": "w -> let (xa, w[0][\"x\"], xb, w[1][\"x\"], ya, w[0][\"value\"], yb, w[1][\"value\"] ,(xb-xa)(ya+yb)/2)", "description": "", "templateType": "anything", "can_override": false}, "xbar": {"name": "xbar", "group": "lists", "definition": "(w) -> let (xa, w[0][\"x\"], xb, w[1][\"x\"], ya, w[0][\"value\"], yb, w[1][\"value\"] , if(xa+xb=0, 0, xa+(xb - xa)*(ya + 2 yb)/3/(ya + yb)))", "description": "<p>gives horizontal location of centroid of distributed load w</p>", "templateType": "anything", "can_override": false}, "equivalent_loads": {"name": "equivalent_loads", "group": "lists", "definition": "map((w)->([x:  xbar(w), value: area(w), label: area(w) + \" lb\"]),loads)", "description": "", "templateType": "anything", "can_override": false}, "loads": {"name": "loads", "group": "lists", "definition": "weighted_random([[[w1],1], [[w2],3], [w3,2]])", "description": "", "templateType": "anything", "can_override": false}, "w2": {"name": "w2", "group": "properties", "definition": "let(w, random_force(), len, random(5..L-3), start, random(0..L-len),\n[\n    [x: start, value: w ,  label: w+\" \" + units[3], visible: true], \n    [x: start+len, value: w , label: \"\" ]\n])", "description": "<p>case 2: single load, shorter than beam, placed randomly along the beam.</p>", "templateType": "anything", "can_override": false}, "moment": {"name": "moment", "group": "Ungrouped variables", "definition": "vmmomentdiagram(properties, debug)", "description": "", "templateType": "anything", "can_override": false}, "symbols": {"name": "symbols", "group": "lists", "definition": "[[type: \"pin\", x: xa, label: \"$R_A$\", visible: true], [type: \"pin\", x: xb, label: \"$R_B$\", visible: true]]", "description": "<p>legal types: pin, roller, dot, fixed</p>", "templateType": "anything", "can_override": false}, "InterestingShearPoints": {"name": "InterestingShearPoints", "group": "Ungrouped variables", "definition": "vmshearpoints(properties)", "description": "", "templateType": "anything", "can_override": false}, "InterestingMomentPoints": {"name": "InterestingMomentPoints", "group": "Ungrouped variables", "definition": "vmmomentpoints(properties)", "description": "", "templateType": "anything", "can_override": false}, "vmax": {"name": "vmax", "group": "Ungrouped variables", "definition": "let( max, max(map(p ->p[1], InterestingshearPoints)),\n  min, min(map(p ->p[1], InterestingshearPoints)),\n  if(abs(max)>abs(min), max, min))", "description": "", "templateType": "anything", "can_override": false}, "mmax": {"name": "mmax", "group": "Ungrouped variables", "definition": "let( max, max(map(p ->p[1], interestingmomentpoints)),\n  min, min(map(p ->p[1], interestingmomentpoints)),\n  if(abs(max)>abs(min), max, min))", "description": "", "templateType": "anything", "can_override": false}, "unique_points": {"name": "unique_points", "group": "properties", "definition": "sort(shuffle(0..L)[0..4])", "description": "", "templateType": "anything", "can_override": false}, "MomentCheck": {"name": "MomentCheck", "group": "reactions", "definition": "siground((\n  sum(map(f->cross( vector(L-f[\"x\"],0,0),vector(0,-f[\"value\"],0))[2],forces+equivalent_loads))\n- sum(map(f->cross(vector(L-f[\"x\"],0,0),vector(0,-f[\"value\"],0))[2],reactions))\n- sum(map(m->m['value'], moments))),6)", "description": "", "templateType": "anything", "can_override": false}, "units": {"name": "units", "group": "Ungrouped variables", "definition": "random(['ft','lb', 'ft*lb', 'lb/ft'],['m','kN', 'kN*m', 'kN/m'])", "description": "", "templateType": "anything", "can_override": false}, "size": {"name": "size", "group": "reactions", "definition": "random(50,100,150,200,500)", "description": "", "templateType": "anything", "can_override": false}, "random_force": {"name": "random_force", "group": "properties", "definition": "() -> toNearest(size * random(0.5..1#0.1), 10)", "description": "<p>gives values of about the same order of magnitude.</p>", "templateType": "anything", "can_override": false}, "debug": {"name": "debug", "group": "Ungrouped variables", "definition": "false", "description": "", "templateType": "anything", "can_override": false}, "case": {"name": "case", "group": "properties", "definition": "['entire beam', 'shorter', 'two loads'][random(0..2)]", "description": "", "templateType": "anything", "can_override": false}, "w3": {"name": "w3", "group": "properties", "definition": "let(w1, random_force(), x1, random(L/4..L/2), w2, random_force(), gap, random(L/4..L/3),\n[[\n    [x: 0, value: w1 ,  label: w1+\" \" + units[3], visible: true], \n    [x: x1, value: w1 , label: \"\" ]\n],\n[\n    [x: x1+gap, value: w2 ,  label: w2+\" \" + units[3], visible: true], \n    [x: L, value: w2 , label: \"\" ]\n]]\n)", "description": "<p>case 3: &nbsp; two distributed loads with a gap in the middle.</p>", "templateType": "anything", "can_override": false}}, "variablesTest": {"condition": "", "maxRuns": 100}, "ungrouped_variables": ["beam", "shear", "moment", "InterestingShearPoints", "InterestingMomentPoints", "vmax", "mmax", "units", "debug"], "variable_groups": [{"name": "reactions", "variables": ["xa", "xb", "rB", "rA", "sigmaF_check", "MomentCheck", "size"]}, {"name": "properties", "variables": ["l", "F1", "F2", "F3", "m1", "m2", "w1", "w2", "w3", "unique_points", "random_force", "case"]}, {"name": "lists", "variables": ["properties", "reactions", "forces", "loads", "moments", "equivalent_loads", "symbols", "area", "xbar"]}], "functions": {}, "preamble": {"js": "question.signals.on('adviceDisplayed', () => {\n  ['moment','shear'].forEach((board) => {\n  var objects = question.scope.getVariable(board).board.objects;\n  objects.Curve.setAttribute({visible: true});\n  Object.keys(objects).filter(k => k.startsWith('Point-')).forEach((k) => objects[k].setAttribute({visible: true}));\n  Object.keys(objects).filter(k => k.startsWith('Jump-')).forEach((k) => objects[k].setAttribute({visible: true}));\n});\n});\n", "css": ""}, "parts": [{"type": "gapfill", "useCustomName": false, "customName": "", "marks": 0, "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": true, "showFeedbackIcon": true, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "prompt": "<p>Draw the shear and bending moment diagram and determine:</p>\n<p><strong>Reactions: </strong>Upward forces positive, downward negative.</p>\n<p>$A = $ [[0]]</p>\n<p>$B = $ [[1]]</p>\n<p><strong>Maximum Shear and Bending Moment: </strong>Positive or negative using the standard sign convention</p>\n<p>$V_\\text{max} = $ [[2]]</p>\n<p>$M_\\text{max} = $ [[3]]</p>", "gaps": [{"type": "engineering-answer", "useCustomName": true, "customName": "$A$", "marks": "5", "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": true, "showFeedbackIcon": true, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "settings": {"correctAnswer": "qty(ra,units[1])", "right": "0.2", "close": "1.0", "C1": "75", "C2": "50", "C3": "25"}}, {"type": "engineering-answer", "useCustomName": true, "customName": "$B$", "marks": "5", "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": true, "showFeedbackIcon": true, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "settings": {"correctAnswer": "qty(rb,units[1])", "right": "0.2", "close": "1.0", "C1": "75", "C2": "50", "C3": "25"}}, {"type": "engineering-answer", "useCustomName": true, "customName": "$V_\\text{max}$", "marks": "5", "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": true, "showFeedbackIcon": true, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "settings": {"correctAnswer": "qty(vmax, units[1])", "right": "0.2", "close": "1.0", "C1": "75", "C2": "50", "C3": "25"}}, {"type": "engineering-answer", "useCustomName": true, "customName": "$M_\\text{max}$", "marks": "5", "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": true, "showFeedbackIcon": true, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "settings": {"correctAnswer": "qty(mmax, units[2])", "right": "0.2", "close": "1.0", "C1": "75", "C2": "50", "C3": "25"}}], "sortAnswers": false}], "partsMode": "all", "maxMarks": 0, "objectives": [], "penalties": [], "objectiveVisibility": "always", "penaltyVisibility": "always"}, {"name": "VM4: Combined Loads", "extensions": ["jsxgraph", "quantities", "shear-and-bending-moment-diagrams"], "custom_part_types": [{"source": {"pk": 19, "author": {"name": "William Haynes", "pk": 2530}, "edit_page": "/part_type/19/edit"}, "name": "Engineering Accuracy with units", "short_name": "engineering-answer", "description": "<p>A value with units marked right if within an adjustable % error of the correct value. &nbsp;Marked close if within a wider margin of error.</p>", "help_url": "", "input_widget": "string", "input_options": {"correctAnswer": "siground(settings['correctAnswer'],4)", "hint": {"static": true, "value": ""}, "allowEmpty": {"static": true, "value": true}}, "can_be_gap": true, "can_be_step": true, "marking_script": "mark:\nswitch( \n  right and good_units and right_sign, add_credit(1.0,'Correct.'),\n  right and good_units and not right_sign, add_credit(settings['C2'],'Wrong sign.'),\n  right and right_sign and not good_units, add_credit(settings['C2'],'Correct value, but wrong or missing units.'),\n  close and good_units, add_credit(settings['C1'],'Close.'),\n  close and not good_units, add_credit(settings['C3'],'Answer is close, but wrong or missing units.'),\n  incorrect('Wrong answer.')\n)\n\ninterpreted_answer:\nqty(student_scalar, student_units)\n\n\n\ncorrect_quantity:\nsettings[\"correctAnswer\"]\n\n\n\ncorrect_units:\nunits(correct_quantity)\n\n\nallowed_notation_styles:\n[\"plain\",\"en\"]\n\nmatch_student_number:\nmatchnumber(studentAnswer,allowed_notation_styles)\n\nstudent_scalar:\nmatch_student_number[1]\n\nstudent_units:\nreplace_regex('ohms','ohm',\n  replace_regex('\u00b0', ' deg',\n    replace_regex('-', ' ' ,\n      studentAnswer[len(match_student_number[0])..len(studentAnswer)])),\"i\")\n\ngood_units:\ntry(\ncompatible(quantity(1, student_units),correct_units),\nmsg,\nfeedback(msg);false)\n\n\nstudent_quantity:\nswitch(not good_units, \n       student_scalar * correct_units, \n       not right_sign,\n       -quantity(student_scalar, student_units),\n       quantity(student_scalar,student_units)\n)\n  \n\n\npercent_error:\ntry(\nscalar(abs((correct_quantity - student_quantity)/correct_quantity))*100  \n,msg,\nif(student_quantity=correct_quantity,0,100))\n   \n\nright:\npercent_error <= settings['right']\n\n\nclose:\nright_sign and percent_error <= settings['close']\n\nright_sign:\nsign(student_scalar) = sign(correct_quantity)", "marking_notes": [{"name": "mark", "description": "This is the main marking note. It should award credit and provide feedback based on the student's answer.", "definition": "switch( \n  right and good_units and right_sign, add_credit(1.0,'Correct.'),\n  right and good_units and not right_sign, add_credit(settings['C2'],'Wrong sign.'),\n  right and right_sign and not good_units, add_credit(settings['C2'],'Correct value, but wrong or missing units.'),\n  close and good_units, add_credit(settings['C1'],'Close.'),\n  close and not good_units, add_credit(settings['C3'],'Answer is close, but wrong or missing units.'),\n  incorrect('Wrong answer.')\n)"}, {"name": "interpreted_answer", "description": "A value representing the student's answer to this part.", "definition": "qty(student_scalar, student_units)\n\n"}, {"name": "correct_quantity", "description": "", "definition": "settings[\"correctAnswer\"]\n\n"}, {"name": "correct_units", "description": "", "definition": "units(correct_quantity)\n"}, {"name": "allowed_notation_styles", "description": "", "definition": "[\"plain\",\"en\"]"}, {"name": "match_student_number", "description": "", "definition": "matchnumber(studentAnswer,allowed_notation_styles)"}, {"name": "student_scalar", "description": "", "definition": "match_student_number[1]"}, {"name": "student_units", "description": "<p>Modify&nbsp;the&nbsp;unit portion of&nbsp;the student's answer by</p>\n<p>1. replacing \"ohms\" with \"ohm\" &nbsp;case insensitive</p>\n<p>2.&nbsp;replacing '-'&nbsp;with ' '&nbsp;</p>\n<p>3. replacing '&deg;' with ' deg'&nbsp;</p>\n<p>to allow answers like 10 ft-lb and 30&deg;</p>", "definition": "replace_regex('ohms','ohm',\n  replace_regex('\u00b0', ' deg',\n    replace_regex('-', ' ' ,\n      studentAnswer[len(match_student_number[0])..len(studentAnswer)])),\"i\")"}, {"name": "good_units", "description": "", "definition": "try(\ncompatible(quantity(1, student_units),correct_units),\nmsg,\nfeedback(msg);false)\n"}, {"name": "student_quantity", "description": "<p>This fixes the student answer for two common errors. &nbsp;</p>\n<p>If student_units are wrong&nbsp;&nbsp;- replace with correct units</p>\n<p>If student_scalar has the wrong sign - replace with right sign</p>\n<p>If student makes both errors, only one gets fixed.</p>", "definition": "switch(not good_units, \n       student_scalar * correct_units, \n       not right_sign,\n       -quantity(student_scalar, student_units),\n       quantity(student_scalar,student_units)\n)\n  \n"}, {"name": "percent_error", "description": "", "definition": "try(\nscalar(abs((correct_quantity - student_quantity)/correct_quantity))*100  \n,msg,\nif(student_quantity=correct_quantity,0,100))\n   "}, {"name": "right", "description": "", "definition": "percent_error <= settings['right']\n"}, {"name": "close", "description": "<p>Only marked close if the student actually has the right sign.</p>", "definition": "right_sign and percent_error <= settings['close']"}, {"name": "right_sign", "description": "", "definition": "sign(student_scalar) = sign(correct_quantity) "}], "settings": [{"name": "correctAnswer", "label": "Correct Quantity.", "help_url": "", "hint": "The correct answer given as a JME quantity.", "input_type": "code", "default_value": "", "evaluate": true}, {"name": "right", "label": "% Accuracy for right.", "help_url": "", "hint": "Question will be considered correct if the scalar part of the student's answer is within this % of correct value.", "input_type": "code", "default_value": "0.2", "evaluate": true}, {"name": "close", "label": "% Accuracy for close.", "help_url": "", "hint": "Question will be considered close if the scalar part of the student's answer is within this % of correct value.", "input_type": "code", "default_value": "1.0", "evaluate": true}, {"name": "C1", "label": "Close with units.", "help_url": "", "hint": "Partial Credit for close value with appropriate units. &nbsp;if correct answer is 100 N and close is &plusmn;1%,<br />99 &nbsp;N is accepted.", "input_type": "percent", "default_value": "75"}, {"name": "C2", "label": "No units or wrong sign", "help_url": "", "hint": "Partial credit for forgetting units or using wrong sign.<br />If the correct answer is 100 N, both 100 and -100 N are accepted.", "input_type": "percent", "default_value": "50"}, {"name": "C3", "label": "Close, no units.", "help_url": "", "hint": "Partial Credit for close value but forgotten units.<br />This value would be close&nbsp;if the expected units were provided. &nbsp;If the correct answer is 100 N, and close is &plusmn;1%,<br />99 is accepted.", "input_type": "percent", "default_value": "25"}], "public_availability": "always", "published": true, "extensions": ["quantities"]}], "resources": [], "navigation": {"allowregen": true, "showfrontpage": false, "preventleave": false, "typeendtoleave": false}, "contributors": [{"name": "William Haynes", "profile_url": "https://numbas.mathcentre.ac.uk/accounts/profile/2530/"}], "tags": [], "metadata": {"description": "<p>Draw shear and bending moment diagram for &nbsp;beam with a uniformly distributed load and a concentrated force</p>", "licence": "Creative Commons Attribution-NonCommercial 4.0 International"}, "statement": "<p>{beam}</p>\n<p>{shear}</p>\n<p>{moment}</p>", "advice": "", "rulesets": {}, "builtin_constants": {"e": true, "pi,\u03c0": true, "i": true, "j": false}, "constants": [], "variables": {"properties": {"name": "properties", "group": "lists", "definition": "[beamLength: L, reactions: reactions, forces: forces,  moments: moments, loads: loads, symbols: symbols]", "description": "<p>Leave this variable the way it is, and adjust the loads using the reactions, forces, moments, loads Lists.</p>", "templateType": "anything", "can_override": false}, "F1": {"name": "F1", "group": "properties", "definition": "let(v, random_force(), \n  [x: unique_points[0], value: v, label:  abs(v) + \" \" + units[1], visible: true])", "description": "", "templateType": "anything", "can_override": false}, "F2": {"name": "F2", "group": "properties", "definition": "let(v, random(0,random_force()), \n  [x: unique_points[1], value: v, label:  abs(v) + \" \" + units[1] ,visible: v<>0])", "description": "", "templateType": "anything", "can_override": false}, "F3": {"name": "F3", "group": "properties", "definition": "let(v, random_force(), \n  [x: 0, value: v, label: abs(v) + \" \" + units[1], visible: true])", "description": "", "templateType": "anything", "can_override": false}, "l": {"name": "l", "group": "properties", "definition": "random(16..24#2)", "description": "", "templateType": "anything", "can_override": false}, "m1": {"name": "m1", "group": "properties", "definition": "let(v, random_force(), \n  [x: 0, value: v, label: abs(v) + \" \" + units[2], visible: true])", "description": "", "templateType": "anything", "can_override": false}, "m2": {"name": "m2", "group": "properties", "definition": "let(v, random_force(), [x: 0, value: v, label: abs(v) + \" \" + units[2], visible: true])", "description": "", "templateType": "anything", "can_override": false}, "reactions": {"name": "reactions", "group": "lists", "definition": "[[x: xa, value: ra, label: \"A\", visible: false],[x: xb, value: rb, label: \"B\", visible: false]]", "description": "<p>pin, roller, fixed, dot</p>", "templateType": "anything", "can_override": false}, "w1": {"name": "w1", "group": "properties", "definition": "let(w, random_force(),  len, random(L/4..3L/4#2), x1, random(0..L-len#2),\n  [[x: x1 , value: w ,  label: w + \" \" + units[3], visible: true],\n   [x: x1+len , value: w ,  label: \"\"]])\n  \n", "description": "", "templateType": "anything", "can_override": false}, "beam": {"name": "beam", "group": "Ungrouped variables", "definition": "vmloaddiagram(properties)", "description": "", "templateType": "anything", "can_override": false}, "shear": {"name": "shear", "group": "Ungrouped variables", "definition": "vmsheardiagram(properties, debug)", "description": "", "templateType": "anything", "can_override": false}, "forces": {"name": "forces", "group": "lists", "definition": "weighted_random([[[f1, f2],1], [[f1],4]])", "description": "<p>2 foces 20% of the time.</p>", "templateType": "anything", "can_override": false}, "rB": {"name": "rB", "group": "reactions", "definition": "(sum(map(f->cross( vector(xa-f[\"x\"],0,0),vector(0,f[\"value\"],0))[2],forces))\n+sum(map(f->cross( vector(xa-f[\"x\"],0,0),vector(0,f[\"value\"],0))[2],equivalent_loads))\n+ sum(map(m->m['value'], moments)))/(xa-xb)", "description": "", "templateType": "anything", "can_override": false}, "rA": {"name": "rA", "group": "reactions", "definition": "(sum(map(f->cross( vector(xb-f[\"x\"],0,0),vector(0,-f[\"value\"],0))[2],forces+equivalent_loads))\n- sum(map(m->m['value'], moments)))/(xa-xb)\n", "description": "", "templateType": "anything", "can_override": false}, "sigmaF_check": {"name": "sigmaF_check", "group": "reactions", "definition": "[foldl((total, f) -> total + f[\"value\"], 0, forces+equivalent_loads),ra+rb]\n", "description": "", "templateType": "anything", "can_override": false}, "xa": {"name": "xa", "group": "reactions", "definition": "if(w1[0][\"x\"]=0,2,0)", "description": "", "templateType": "anything", "can_override": false}, "xb": {"name": "xb", "group": "reactions", "definition": "if(w1[1][\"x\"]=L,random(L-4,L - 2), L)", "description": "", "templateType": "anything", "can_override": false}, "moments": {"name": "moments", "group": "lists", "definition": "[]", "description": "", "templateType": "anything", "can_override": false}, "area": {"name": "area", "group": "lists", "definition": "w -> let (xa, w[0][\"x\"], xb, w[1][\"x\"], ya, w[0][\"value\"], yb, w[1][\"value\"] ,(xb-xa)(ya+yb)/2)", "description": "", "templateType": "anything", "can_override": false}, "xbar": {"name": "xbar", "group": "lists", "definition": "(w) -> let (xa, w[0][\"x\"], xb, w[1][\"x\"], ya, w[0][\"value\"], yb, w[1][\"value\"] , if(xa+xb=0, 0, xa+(xb - xa)*(ya + 2 yb)/3/(ya + yb)))", "description": "<p>gives horizontal location of centroid of distributed load w</p>", "templateType": "anything", "can_override": false}, "equivalent_loads": {"name": "equivalent_loads", "group": "lists", "definition": "map((w)->let( f , area(w), [x:  xbar(w), value: f, label: f + \" lb\"]),loads)", "description": "", "templateType": "anything", "can_override": false}, "loads": {"name": "loads", "group": "lists", "definition": "[w1]", "description": "", "templateType": "anything", "can_override": false}, "w2": {"name": "w2", "group": "properties", "definition": "let(w, [dec(random(0,0.5,1) size/10) , dec(random(0,0.5,1) size/10)],\n    [[x: random(0,2,4), value: w[0] ,  label: w[0] + \" \" + units[3], visible: true], \n     [x: random(L-4,L-2,L), value: w[1] , label: w[1] + \" \" + units[3]]])", "description": "", "templateType": "anything", "can_override": false}, "moment": {"name": "moment", "group": "Ungrouped variables", "definition": "vmmomentdiagram(properties, debug)", "description": "", "templateType": "anything", "can_override": false}, "symbols": {"name": "symbols", "group": "lists", "definition": "[[type: \"pin\", x: xa, label: \"$R_A$\", visible: true], [type: \"pin\", x: xb, label: \"$R_B$\", visible: true]]", "description": "<p>legal types: pin, roller, dot, fixed</p>", "templateType": "anything", "can_override": false}, "InterestingShearPoints": {"name": "InterestingShearPoints", "group": "Ungrouped variables", "definition": "vmshearpoints(properties)", "description": "", "templateType": "anything", "can_override": false}, "InterestingMomentPoints": {"name": "InterestingMomentPoints", "group": "Ungrouped variables", "definition": "vmmomentpoints(properties)", "description": "", "templateType": "anything", "can_override": false}, "vmax": {"name": "vmax", "group": "Ungrouped variables", "definition": "let( max, max(map(p ->p[1], InterestingshearPoints)),\n  min, min(map(p ->p[1], InterestingshearPoints)),\n  if(abs(max)>abs(min), max, min))", "description": "", "templateType": "anything", "can_override": false}, "mmax": {"name": "mmax", "group": "Ungrouped variables", "definition": "let( max, max(map(p ->p[1], interestingmomentpoints)),\n  min, min(map(p ->p[1], interestingmomentpoints)),\n  if(abs(max)>abs(min), max, min))", "description": "", "templateType": "anything", "can_override": false}, "unique_points": {"name": "unique_points", "group": "properties", "definition": "sort(shuffle(0..L#2)[0..2])", "description": "", "templateType": "anything", "can_override": false}, "MomentCheck": {"name": "MomentCheck", "group": "reactions", "definition": "siground((\n  sum(map(f->cross( vector(L-f[\"x\"],0,0),vector(0,-f[\"value\"],0))[2],forces+equivalent_loads))\n- sum(map(f->cross(vector(L-f[\"x\"],0,0),vector(0,-f[\"value\"],0))[2],reactions))\n- sum(map(m->m['value'], moments))),6)", "description": "", "templateType": "anything", "can_override": false}, "units": {"name": "units", "group": "Ungrouped variables", "definition": "random(['ft','lb', 'ft*lb', 'lb/ft'],['m','kN', 'kN*m', 'kN/m'])", "description": "", "templateType": "anything", "can_override": false}, "size": {"name": "size", "group": "reactions", "definition": "random(100,200,500)", "description": "", "templateType": "anything", "can_override": false}, "random_force": {"name": "random_force", "group": "properties", "definition": "() -> toNearest(size * random(0.5..1#0.1),10)", "description": "<p>gives values of about the same order of magnitude.</p>", "templateType": "anything", "can_override": false}, "debug": {"name": "debug", "group": "Ungrouped variables", "definition": "false", "description": "", "templateType": "anything", "can_override": false}}, "variablesTest": {"condition": "abs(w1[0][\"x\"] - w1[1][\"x\"]) > 3", "maxRuns": 100}, "ungrouped_variables": ["beam", "shear", "moment", "InterestingShearPoints", "InterestingMomentPoints", "vmax", "mmax", "units", "debug"], "variable_groups": [{"name": "reactions", "variables": ["xa", "xb", "rB", "rA", "sigmaF_check", "MomentCheck", "size"]}, {"name": "properties", "variables": ["l", "F1", "F2", "F3", "m1", "m2", "w1", "w2", "unique_points", "random_force"]}, {"name": "lists", "variables": ["properties", "reactions", "forces", "loads", "moments", "equivalent_loads", "symbols", "area", "xbar"]}], "functions": {}, "preamble": {"js": "question.signals.on('adviceDisplayed', () => {\n  ['moment','shear'].forEach((board) => {\n  var objects = question.scope.getVariable(board).board.objects;\n  objects.Curve.setAttribute({visible: true});\n  Object.keys(objects).filter(k => k.startsWith('Point-')).forEach((k) => objects[k].setAttribute({visible: true}));\n  Object.keys(objects).filter(k => k.startsWith('Jump-')).forEach((k) => objects[k].setAttribute({visible: true}));\n});\n});\n", "css": ""}, "parts": [{"type": "gapfill", "useCustomName": false, "customName": "", "marks": 0, "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": true, "showFeedbackIcon": true, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "prompt": "<p>Draw the shear and bending moment diagram and determine the</p>\n<p><strong>Reactions: </strong>Upward forces positive, downward negative.</p>\n<p>$A = $ [[0]]</p>\n<p>$B = $ [[1]]</p>\n<p><strong>Maximum Shear and Bending Moment: </strong>Positive or negative using the standard sign convention</p>\n<p>$V_\\text{max} = $ [[2]]</p>\n<p>$M_\\text{max} = $ [[3]]</p>", "gaps": [{"type": "engineering-answer", "useCustomName": true, "customName": "$A$", "marks": "5", "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": true, "showFeedbackIcon": true, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "settings": {"correctAnswer": "qty(ra,units[1])", "right": "0.2", "close": "1.0", "C1": "75", "C2": "50", "C3": "25"}}, {"type": "engineering-answer", "useCustomName": true, "customName": "$B$", "marks": "5", "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": true, "showFeedbackIcon": true, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "settings": {"correctAnswer": "qty(rb,units[1])", "right": "0.2", "close": "1.0", "C1": "75", "C2": "50", "C3": "25"}}, {"type": "engineering-answer", "useCustomName": true, "customName": "$V_\\text{max}$", "marks": "5", "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": true, "showFeedbackIcon": true, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "settings": {"correctAnswer": "qty(vmax, units[1])", "right": "0.2", "close": "1.0", "C1": "75", "C2": "50", "C3": "25"}}, {"type": "engineering-answer", "useCustomName": true, "customName": "$M_\\text{max}$", "marks": "5", "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": true, "showFeedbackIcon": false, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "settings": {"correctAnswer": "qty(mmax, units[2])", "right": "0.2", "close": "1.0", "C1": "75", "C2": "50", "C3": "25"}}], "sortAnswers": false}], "partsMode": "all", "maxMarks": 0, "objectives": [], "penalties": [], "objectiveVisibility": "always", "penaltyVisibility": "always"}, {"name": "VM6: Ground Beam", "extensions": ["jsxgraph", "quantities", "shear-and-bending-moment-diagrams"], "custom_part_types": [{"source": {"pk": 19, "author": {"name": "William Haynes", "pk": 2530}, "edit_page": "/part_type/19/edit"}, "name": "Engineering Accuracy with units", "short_name": "engineering-answer", "description": "<p>A value with units marked right if within an adjustable % error of the correct value. &nbsp;Marked close if within a wider margin of error.</p>", "help_url": "", "input_widget": "string", "input_options": {"correctAnswer": "siground(settings['correctAnswer'],4)", "hint": {"static": true, "value": ""}, "allowEmpty": {"static": true, "value": true}}, "can_be_gap": true, "can_be_step": true, "marking_script": "mark:\nswitch( \n  right and good_units and right_sign, add_credit(1.0,'Correct.'),\n  right and good_units and not right_sign, add_credit(settings['C2'],'Wrong sign.'),\n  right and right_sign and not good_units, add_credit(settings['C2'],'Correct value, but wrong or missing units.'),\n  close and good_units, add_credit(settings['C1'],'Close.'),\n  close and not good_units, add_credit(settings['C3'],'Answer is close, but wrong or missing units.'),\n  incorrect('Wrong answer.')\n)\n\ninterpreted_answer:\nqty(student_scalar, student_units)\n\n\n\ncorrect_quantity:\nsettings[\"correctAnswer\"]\n\n\n\ncorrect_units:\nunits(correct_quantity)\n\n\nallowed_notation_styles:\n[\"plain\",\"en\"]\n\nmatch_student_number:\nmatchnumber(studentAnswer,allowed_notation_styles)\n\nstudent_scalar:\nmatch_student_number[1]\n\nstudent_units:\nreplace_regex('ohms','ohm',\n  replace_regex('\u00b0', ' deg',\n    replace_regex('-', ' ' ,\n      studentAnswer[len(match_student_number[0])..len(studentAnswer)])),\"i\")\n\ngood_units:\ntry(\ncompatible(quantity(1, student_units),correct_units),\nmsg,\nfeedback(msg);false)\n\n\nstudent_quantity:\nswitch(not good_units, \n       student_scalar * correct_units, \n       not right_sign,\n       -quantity(student_scalar, student_units),\n       quantity(student_scalar,student_units)\n)\n  \n\n\npercent_error:\ntry(\nscalar(abs((correct_quantity - student_quantity)/correct_quantity))*100  \n,msg,\nif(student_quantity=correct_quantity,0,100))\n   \n\nright:\npercent_error <= settings['right']\n\n\nclose:\nright_sign and percent_error <= settings['close']\n\nright_sign:\nsign(student_scalar) = sign(correct_quantity)", "marking_notes": [{"name": "mark", "description": "This is the main marking note. It should award credit and provide feedback based on the student's answer.", "definition": "switch( \n  right and good_units and right_sign, add_credit(1.0,'Correct.'),\n  right and good_units and not right_sign, add_credit(settings['C2'],'Wrong sign.'),\n  right and right_sign and not good_units, add_credit(settings['C2'],'Correct value, but wrong or missing units.'),\n  close and good_units, add_credit(settings['C1'],'Close.'),\n  close and not good_units, add_credit(settings['C3'],'Answer is close, but wrong or missing units.'),\n  incorrect('Wrong answer.')\n)"}, {"name": "interpreted_answer", "description": "A value representing the student's answer to this part.", "definition": "qty(student_scalar, student_units)\n\n"}, {"name": "correct_quantity", "description": "", "definition": "settings[\"correctAnswer\"]\n\n"}, {"name": "correct_units", "description": "", "definition": "units(correct_quantity)\n"}, {"name": "allowed_notation_styles", "description": "", "definition": "[\"plain\",\"en\"]"}, {"name": "match_student_number", "description": "", "definition": "matchnumber(studentAnswer,allowed_notation_styles)"}, {"name": "student_scalar", "description": "", "definition": "match_student_number[1]"}, {"name": "student_units", "description": "<p>Modify&nbsp;the&nbsp;unit portion of&nbsp;the student's answer by</p>\n<p>1. replacing \"ohms\" with \"ohm\" &nbsp;case insensitive</p>\n<p>2.&nbsp;replacing '-'&nbsp;with ' '&nbsp;</p>\n<p>3. replacing '&deg;' with ' deg'&nbsp;</p>\n<p>to allow answers like 10 ft-lb and 30&deg;</p>", "definition": "replace_regex('ohms','ohm',\n  replace_regex('\u00b0', ' deg',\n    replace_regex('-', ' ' ,\n      studentAnswer[len(match_student_number[0])..len(studentAnswer)])),\"i\")"}, {"name": "good_units", "description": "", "definition": "try(\ncompatible(quantity(1, student_units),correct_units),\nmsg,\nfeedback(msg);false)\n"}, {"name": "student_quantity", "description": "<p>This fixes the student answer for two common errors. &nbsp;</p>\n<p>If student_units are wrong&nbsp;&nbsp;- replace with correct units</p>\n<p>If student_scalar has the wrong sign - replace with right sign</p>\n<p>If student makes both errors, only one gets fixed.</p>", "definition": "switch(not good_units, \n       student_scalar * correct_units, \n       not right_sign,\n       -quantity(student_scalar, student_units),\n       quantity(student_scalar,student_units)\n)\n  \n"}, {"name": "percent_error", "description": "", "definition": "try(\nscalar(abs((correct_quantity - student_quantity)/correct_quantity))*100  \n,msg,\nif(student_quantity=correct_quantity,0,100))\n   "}, {"name": "right", "description": "", "definition": "percent_error <= settings['right']\n"}, {"name": "close", "description": "<p>Only marked close if the student actually has the right sign.</p>", "definition": "right_sign and percent_error <= settings['close']"}, {"name": "right_sign", "description": "", "definition": "sign(student_scalar) = sign(correct_quantity) "}], "settings": [{"name": "correctAnswer", "label": "Correct Quantity.", "help_url": "", "hint": "The correct answer given as a JME quantity.", "input_type": "code", "default_value": "", "evaluate": true}, {"name": "right", "label": "% Accuracy for right.", "help_url": "", "hint": "Question will be considered correct if the scalar part of the student's answer is within this % of correct value.", "input_type": "code", "default_value": "0.2", "evaluate": true}, {"name": "close", "label": "% Accuracy for close.", "help_url": "", "hint": "Question will be considered close if the scalar part of the student's answer is within this % of correct value.", "input_type": "code", "default_value": "1.0", "evaluate": true}, {"name": "C1", "label": "Close with units.", "help_url": "", "hint": "Partial Credit for close value with appropriate units. &nbsp;if correct answer is 100 N and close is &plusmn;1%,<br />99 &nbsp;N is accepted.", "input_type": "percent", "default_value": "75"}, {"name": "C2", "label": "No units or wrong sign", "help_url": "", "hint": "Partial credit for forgetting units or using wrong sign.<br />If the correct answer is 100 N, both 100 and -100 N are accepted.", "input_type": "percent", "default_value": "50"}, {"name": "C3", "label": "Close, no units.", "help_url": "", "hint": "Partial Credit for close value but forgotten units.<br />This value would be close&nbsp;if the expected units were provided. &nbsp;If the correct answer is 100 N, and close is &plusmn;1%,<br />99 is accepted.", "input_type": "percent", "default_value": "25"}], "public_availability": "always", "published": true, "extensions": ["quantities"]}], "resources": [], "navigation": {"allowregen": true, "showfrontpage": false, "preventleave": false, "typeendtoleave": false}, "contributors": [{"name": "William Haynes", "profile_url": "https://numbas.mathcentre.ac.uk/accounts/profile/2530/"}], "tags": [], "metadata": {"description": "<p>Draw shear and bending moment diagram for a symmetrically loaded beam resting on the ground.</p>", "licence": "Creative Commons Attribution-NonCommercial 4.0 International"}, "statement": "<p>{beam}</p>\n<p>{shear}</p>\n<p>{moment}</p>", "advice": "", "rulesets": {}, "builtin_constants": {"e": true, "pi,\u03c0": true, "i": true, "j": false}, "constants": [], "variables": {"properties": {"name": "properties", "group": "lists", "definition": "[beamLength: L, reactions: reactions, forces: forces,  moments: moments, loads: loads, symbols: symbols]", "description": "<p>Leave this variable the way it is, and adjust the loads using the reactions, forces, moments, loads Lists.</p>", "templateType": "anything", "can_override": false}, "F1": {"name": "F1", "group": "properties", "definition": "let(v, random_force(), \n  [x: random(0..6), value: v, label:  abs(v) + \" \" + units[1], visible: true])", "description": "", "templateType": "anything", "can_override": false}, "F2": {"name": "F2", "group": "properties", "definition": "let(v, f1[\"value\"], \n  [x: L - f1[\"x\"], value: v, label:  abs(v) + \" \" + units[1] ,visible: true])", "description": "", "templateType": "anything", "can_override": false}, "F3": {"name": "F3", "group": "properties", "definition": "let(v, random(0,random_force()), \n  [x: L/2, value: v, label: abs(v) + \" \" + units[1], visible: v<>0])", "description": "", "templateType": "anything", "can_override": false}, "l": {"name": "l", "group": "properties", "definition": "20", "description": "", "templateType": "anything", "can_override": false}, "m1": {"name": "m1", "group": "properties", "definition": "let(v, random_force(), \n  [x: 0, value: v, label: abs(v) + \" \" + units[2], visible: true])", "description": "", "templateType": "anything", "can_override": false}, "m2": {"name": "m2", "group": "properties", "definition": "let(v, random_force(), [x: 0, value: v, label: abs(v) + \" \" + units[2], visible: true])", "description": "", "templateType": "anything", "can_override": false}, "reactions": {"name": "reactions", "group": "lists", "definition": "[]", "description": "<p>pin, roller, fixed, dot</p>", "templateType": "anything", "can_override": false}, "w1": {"name": "w1", "group": "properties", "definition": "\n    [[x: xa, value: w0 ,  label: \"$w$\", visible: true], \n     [x: xb, value: w0 , label: abs(w0) + \" \" + units[3]]]", "description": "", "templateType": "anything", "can_override": false}, "beam": {"name": "beam", "group": "Ungrouped variables", "definition": "vmloaddiagram(properties)", "description": "", "templateType": "anything", "can_override": false}, "shear": {"name": "shear", "group": "Ungrouped variables", "definition": "vmsheardiagram(properties, debug)", "description": "", "templateType": "anything", "can_override": false}, "forces": {"name": "forces", "group": "lists", "definition": "[F1,F2,F3]", "description": "", "templateType": "anything", "can_override": false}, "rB": {"name": "rB", "group": "reactions", "definition": "0", "description": "", "templateType": "anything", "can_override": false}, "rA": {"name": "rA", "group": "reactions", "definition": "0\n", "description": "", "templateType": "anything", "can_override": false}, "sigmaF_check": {"name": "sigmaF_check", "group": "reactions", "definition": "[foldl((total, f) -> total + f[\"value\"], 0, forces+equivalent_loads),ra+rb]\n", "description": "", "templateType": "anything", "can_override": false}, "xa": {"name": "xa", "group": "reactions", "definition": "0", "description": "", "templateType": "anything", "can_override": false}, "xb": {"name": "xb", "group": "reactions", "definition": "L-xa", "description": "", "templateType": "anything", "can_override": false}, "moments": {"name": "moments", "group": "lists", "definition": "[]", "description": "", "templateType": "anything", "can_override": false}, "area": {"name": "area", "group": "lists", "definition": "w -> let (xa, w[0][\"x\"], xb, w[1][\"x\"], ya, w[0][\"value\"], yb, w[1][\"value\"] ,(xb-xa)(ya+yb)/2)", "description": "", "templateType": "anything", "can_override": false}, "xbar": {"name": "xbar", "group": "lists", "definition": "(w) -> let (xa, w[0][\"x\"], xb, w[1][\"x\"], ya, w[0][\"value\"], yb, w[1][\"value\"] , if(xa+xb=0, 0, xa+(xb - xa)*(ya + 2 yb)/3/(ya + yb)))", "description": "<p>gives horizontal location of centroid of distributed load w</p>", "templateType": "anything", "can_override": false}, "equivalent_loads": {"name": "equivalent_loads", "group": "lists", "definition": " map((w)->let( f , area(w), [x:  xbar(w), value: f, label: f + \" lb\"]),loads)", "description": "", "templateType": "anything", "can_override": false}, "loads": {"name": "loads", "group": "lists", "definition": "[w1]", "description": "", "templateType": "anything", "can_override": false}, "w2": {"name": "w2", "group": "properties", "definition": "let(w, [dec(random(0,0.5,1) size/10) , dec(random(0,0.5,1) size/10)],\n    [[x: random(0,2,4), value: w[0] ,  label: w[0] + \" \" + units[3], visible: true], \n     [x: random(L-4,L-2,L), value: w[1] , label: w[1] + \" \" + units[3]]])", "description": "", "templateType": "anything", "can_override": false}, "moment": {"name": "moment", "group": "Ungrouped variables", "definition": "vmmomentdiagram(properties, debug)", "description": "", "templateType": "anything", "can_override": false}, "symbols": {"name": "symbols", "group": "lists", "definition": "[[type: \"pin\", x: xa, label: \"$R_A$\", visible: false], [type: \"roller\", x: xb, label: \"$R_B$\", visible: false]]", "description": "<p>legal types: pin, roller, dot, fixed</p>", "templateType": "anything", "can_override": false}, "InterestingShearPoints": {"name": "InterestingShearPoints", "group": "Ungrouped variables", "definition": "vmshearpoints(properties)", "description": "", "templateType": "anything", "can_override": false}, "InterestingMomentPoints": {"name": "InterestingMomentPoints", "group": "Ungrouped variables", "definition": "vmmomentpoints(properties)", "description": "", "templateType": "anything", "can_override": false}, "vmax": {"name": "vmax", "group": "Ungrouped variables", "definition": "let( max, max(map(p ->p[1], InterestingshearPoints)),\n  min, min(map(p ->p[1], InterestingshearPoints)),\n  if(abs(max)>=abs(min), max, min))", "description": "", "templateType": "anything", "can_override": false}, "mmax": {"name": "mmax", "group": "Ungrouped variables", "definition": "let( max, max(map(p ->p[1], interestingmomentpoints)),\n  min, min(map(p ->p[1], interestingmomentpoints)),\n  if(abs(max)>=abs(min), max, min))", "description": "", "templateType": "anything", "can_override": false}, "unique_points": {"name": "unique_points", "group": "properties", "definition": "sort(shuffle(0..L)[0..2])", "description": "", "templateType": "anything", "can_override": false}, "MomentCheck": {"name": "MomentCheck", "group": "reactions", "definition": "\"off\"//siground((\n//  sum(map(f->cross( vector(L-f[\"x\"],0,0),vector(0,-f[\"value\"],0))[2],forces+equivalent_loads))\n//- sum(map(f->cross(vector(L-f[\"x\"],0,0),vector(0,-f[\"value\"],0))[2],reactions))\n//- sum(map(m->m['value'], moments))),6)", "description": "", "templateType": "anything", "can_override": false}, "units": {"name": "units", "group": "Ungrouped variables", "definition": "random(['ft','lb', 'ft*lb', 'lb/ft'],['m','kN', 'kN*m', 'kN/m'])", "description": "", "templateType": "anything", "can_override": false}, "size": {"name": "size", "group": "reactions", "definition": "random(100,200,200,400,600)", "description": "", "templateType": "anything", "can_override": false}, "random_force": {"name": "random_force", "group": "reactions", "definition": "() -> round(size * random(0.5..1.5#0.1 except 0))", "description": "<p>gives values of about the same order of magnitude.</p>", "templateType": "anything", "can_override": false}, "test": {"name": "test", "group": "Ungrouped variables", "definition": "sum(map(x->x[\"value\"], forces))/L", "description": "", "templateType": "anything", "can_override": false}, "w0": {"name": "w0", "group": "properties", "definition": "-sum(map(x->x[\"value\"], forces))/L", "description": "<p>magnitude of distributed load, negative loads point up</p>", "templateType": "anything", "can_override": false}, "debug": {"name": "debug", "group": "Ungrouped variables", "definition": "false", "description": "", "templateType": "anything", "can_override": false}}, "variablesTest": {"condition": "", "maxRuns": 100}, "ungrouped_variables": ["beam", "shear", "moment", "InterestingShearPoints", "InterestingMomentPoints", "vmax", "mmax", "units", "test", "debug"], "variable_groups": [{"name": "reactions", "variables": ["xa", "xb", "rB", "rA", "sigmaF_check", "MomentCheck", "size", "random_force"]}, {"name": "properties", "variables": ["l", "F1", "F2", "F3", "m1", "m2", "w1", "w2", "w0", "unique_points"]}, {"name": "lists", "variables": ["properties", "reactions", "forces", "loads", "moments", "equivalent_loads", "symbols", "area", "xbar"]}], "functions": {}, "preamble": {"js": "question.signals.on('adviceDisplayed', () => {\n  ['moment','shear'].forEach((board) => {\n  var objects = question.scope.getVariable(board).board.objects;\n  objects.Curve.setAttribute({visible: true});\n  Object.keys(objects).filter(k => k.startsWith('Point-')).forEach((k) => objects[k].setAttribute({visible: true}));\n  Object.keys(objects).filter(k => k.startsWith('Jump-')).forEach((k) => objects[k].setAttribute({visible: true}));\n});\n});\n", "css": ""}, "parts": [{"type": "gapfill", "useCustomName": false, "customName": "", "marks": 0, "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": true, "showFeedbackIcon": true, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "prompt": "<p>Draw the shear and bending moment diagram and determine:</p>\n<p><strong>Distributed Load: </strong>Upward forces positive, downward negative.</p>\n<p>$w = $ [[0]]</p>\n<p><strong>Maximum Shear and Bending Moment: </strong>Positive or negative using the standard sign convention</p>\n<p>$V_\\text{max} = $[[1]]</p>\n<p>$M_\\text{max} = $[[2]]</p>", "gaps": [{"type": "engineering-answer", "useCustomName": true, "customName": "$w$", "marks": "5", "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": true, "showFeedbackIcon": true, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "settings": {"correctAnswer": "-qty(w0,units[3])", "right": "0.2", "close": "1.0", "C1": "75", "C2": "50", "C3": "25"}}, {"type": "engineering-answer", "useCustomName": true, "customName": "$V_\\text{max}$", "marks": "5", "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": true, "showFeedbackIcon": true, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "alternatives": [{"type": "engineering-answer", "useCustomName": true, "customName": "$-V_\\text{max}$", "marks": "5", "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "alternativeFeedbackMessage": "", "useAlternativeFeedback": false, "settings": {"correctAnswer": "-qty(vmax, units[1])", "right": "0.2", "close": "1.0", "C1": "75", "C2": "50", "C3": "25"}}], "settings": {"correctAnswer": "qty(vmax, units[1])", "right": "0.2", "close": "1.0", "C1": "75", "C2": "50", "C3": "25"}}, {"type": "engineering-answer", "useCustomName": true, "customName": "$M_\\text{max}$", "marks": "5", "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": true, "showFeedbackIcon": true, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "settings": {"correctAnswer": "qty(mmax, units[2])", "right": "0.2", "close": "1.0", "C1": "75", "C2": "50", "C3": "25"}}], "sortAnswers": false}], "partsMode": "all", "maxMarks": 0, "objectives": [], "penalties": [], "objectiveVisibility": "always", "penaltyVisibility": "always"}, {"name": "VM5: Triangular Loading", "extensions": ["jsxgraph", "quantities", "shear-and-bending-moment-diagrams"], "custom_part_types": [{"source": {"pk": 19, "author": {"name": "William Haynes", "pk": 2530}, "edit_page": "/part_type/19/edit"}, "name": "Engineering Accuracy with units", "short_name": "engineering-answer", "description": "<p>A value with units marked right if within an adjustable % error of the correct value. &nbsp;Marked close if within a wider margin of error.</p>", "help_url": "", "input_widget": "string", "input_options": {"correctAnswer": "siground(settings['correctAnswer'],4)", "hint": {"static": true, "value": ""}, "allowEmpty": {"static": true, "value": true}}, "can_be_gap": true, "can_be_step": true, "marking_script": "mark:\nswitch( \n  right and good_units and right_sign, add_credit(1.0,'Correct.'),\n  right and good_units and not right_sign, add_credit(settings['C2'],'Wrong sign.'),\n  right and right_sign and not good_units, add_credit(settings['C2'],'Correct value, but wrong or missing units.'),\n  close and good_units, add_credit(settings['C1'],'Close.'),\n  close and not good_units, add_credit(settings['C3'],'Answer is close, but wrong or missing units.'),\n  incorrect('Wrong answer.')\n)\n\ninterpreted_answer:\nqty(student_scalar, student_units)\n\n\n\ncorrect_quantity:\nsettings[\"correctAnswer\"]\n\n\n\ncorrect_units:\nunits(correct_quantity)\n\n\nallowed_notation_styles:\n[\"plain\",\"en\"]\n\nmatch_student_number:\nmatchnumber(studentAnswer,allowed_notation_styles)\n\nstudent_scalar:\nmatch_student_number[1]\n\nstudent_units:\nreplace_regex('ohms','ohm',\n  replace_regex('\u00b0', ' deg',\n    replace_regex('-', ' ' ,\n      studentAnswer[len(match_student_number[0])..len(studentAnswer)])),\"i\")\n\ngood_units:\ntry(\ncompatible(quantity(1, student_units),correct_units),\nmsg,\nfeedback(msg);false)\n\n\nstudent_quantity:\nswitch(not good_units, \n       student_scalar * correct_units, \n       not right_sign,\n       -quantity(student_scalar, student_units),\n       quantity(student_scalar,student_units)\n)\n  \n\n\npercent_error:\ntry(\nscalar(abs((correct_quantity - student_quantity)/correct_quantity))*100  \n,msg,\nif(student_quantity=correct_quantity,0,100))\n   \n\nright:\npercent_error <= settings['right']\n\n\nclose:\nright_sign and percent_error <= settings['close']\n\nright_sign:\nsign(student_scalar) = sign(correct_quantity)", "marking_notes": [{"name": "mark", "description": "This is the main marking note. It should award credit and provide feedback based on the student's answer.", "definition": "switch( \n  right and good_units and right_sign, add_credit(1.0,'Correct.'),\n  right and good_units and not right_sign, add_credit(settings['C2'],'Wrong sign.'),\n  right and right_sign and not good_units, add_credit(settings['C2'],'Correct value, but wrong or missing units.'),\n  close and good_units, add_credit(settings['C1'],'Close.'),\n  close and not good_units, add_credit(settings['C3'],'Answer is close, but wrong or missing units.'),\n  incorrect('Wrong answer.')\n)"}, {"name": "interpreted_answer", "description": "A value representing the student's answer to this part.", "definition": "qty(student_scalar, student_units)\n\n"}, {"name": "correct_quantity", "description": "", "definition": "settings[\"correctAnswer\"]\n\n"}, {"name": "correct_units", "description": "", "definition": "units(correct_quantity)\n"}, {"name": "allowed_notation_styles", "description": "", "definition": "[\"plain\",\"en\"]"}, {"name": "match_student_number", "description": "", "definition": "matchnumber(studentAnswer,allowed_notation_styles)"}, {"name": "student_scalar", "description": "", "definition": "match_student_number[1]"}, {"name": "student_units", "description": "<p>Modify&nbsp;the&nbsp;unit portion of&nbsp;the student's answer by</p>\n<p>1. replacing \"ohms\" with \"ohm\" &nbsp;case insensitive</p>\n<p>2.&nbsp;replacing '-'&nbsp;with ' '&nbsp;</p>\n<p>3. replacing '&deg;' with ' deg'&nbsp;</p>\n<p>to allow answers like 10 ft-lb and 30&deg;</p>", "definition": "replace_regex('ohms','ohm',\n  replace_regex('\u00b0', ' deg',\n    replace_regex('-', ' ' ,\n      studentAnswer[len(match_student_number[0])..len(studentAnswer)])),\"i\")"}, {"name": "good_units", "description": "", "definition": "try(\ncompatible(quantity(1, student_units),correct_units),\nmsg,\nfeedback(msg);false)\n"}, {"name": "student_quantity", "description": "<p>This fixes the student answer for two common errors. &nbsp;</p>\n<p>If student_units are wrong&nbsp;&nbsp;- replace with correct units</p>\n<p>If student_scalar has the wrong sign - replace with right sign</p>\n<p>If student makes both errors, only one gets fixed.</p>", "definition": "switch(not good_units, \n       student_scalar * correct_units, \n       not right_sign,\n       -quantity(student_scalar, student_units),\n       quantity(student_scalar,student_units)\n)\n  \n"}, {"name": "percent_error", "description": "", "definition": "try(\nscalar(abs((correct_quantity - student_quantity)/correct_quantity))*100  \n,msg,\nif(student_quantity=correct_quantity,0,100))\n   "}, {"name": "right", "description": "", "definition": "percent_error <= settings['right']\n"}, {"name": "close", "description": "<p>Only marked close if the student actually has the right sign.</p>", "definition": "right_sign and percent_error <= settings['close']"}, {"name": "right_sign", "description": "", "definition": "sign(student_scalar) = sign(correct_quantity) "}], "settings": [{"name": "correctAnswer", "label": "Correct Quantity.", "help_url": "", "hint": "The correct answer given as a JME quantity.", "input_type": "code", "default_value": "", "evaluate": true}, {"name": "right", "label": "% Accuracy for right.", "help_url": "", "hint": "Question will be considered correct if the scalar part of the student's answer is within this % of correct value.", "input_type": "code", "default_value": "0.2", "evaluate": true}, {"name": "close", "label": "% Accuracy for close.", "help_url": "", "hint": "Question will be considered close if the scalar part of the student's answer is within this % of correct value.", "input_type": "code", "default_value": "1.0", "evaluate": true}, {"name": "C1", "label": "Close with units.", "help_url": "", "hint": "Partial Credit for close value with appropriate units. &nbsp;if correct answer is 100 N and close is &plusmn;1%,<br />99 &nbsp;N is accepted.", "input_type": "percent", "default_value": "75"}, {"name": "C2", "label": "No units or wrong sign", "help_url": "", "hint": "Partial credit for forgetting units or using wrong sign.<br />If the correct answer is 100 N, both 100 and -100 N are accepted.", "input_type": "percent", "default_value": "50"}, {"name": "C3", "label": "Close, no units.", "help_url": "", "hint": "Partial Credit for close value but forgotten units.<br />This value would be close&nbsp;if the expected units were provided. &nbsp;If the correct answer is 100 N, and close is &plusmn;1%,<br />99 is accepted.", "input_type": "percent", "default_value": "25"}], "public_availability": "always", "published": true, "extensions": ["quantities"]}], "resources": [], "navigation": {"allowregen": true, "showfrontpage": false, "preventleave": false, "typeendtoleave": false}, "contributors": [{"name": "William Haynes", "profile_url": "https://numbas.mathcentre.ac.uk/accounts/profile/2530/"}], "tags": [], "metadata": {"description": "<p>Draw Shear and Bending Moment Diagrams for a simply supported beam with triangular loading</p>", "licence": "Creative Commons Attribution-NonCommercial 4.0 International"}, "statement": "<p>{beam}</p>\n<p>{shear}</p>\n<p>{moment}</p>", "advice": "", "rulesets": {}, "builtin_constants": {"e": true, "pi,\u03c0": true, "i": true, "j": false}, "constants": [], "variables": {"properties": {"name": "properties", "group": "lists", "definition": "[beamLength: L, reactions: reactions, forces: forces,  moments: moments, loads: loads, symbols: symbols]", "description": "<p>Leave this variable the way it is, and adjust the loads using the reactions, forces, moments, loads Lists.</p>", "templateType": "anything", "can_override": false}, "F1": {"name": "F1", "group": "properties", "definition": "let(v, random_force(), \n  [x: unique_points[0], value: v, label:  abs(v) + \" \" + units[1], visible: true])", "description": "", "templateType": "anything", "can_override": false}, "F2": {"name": "F2", "group": "properties", "definition": "let(v, random_force(), \n  [x: unique_points[1], value: v, label:  abs(v) + \" \" + units[1] ,visible: true])", "description": "", "templateType": "anything", "can_override": false}, "F3": {"name": "F3", "group": "properties", "definition": "let(v, random_force(), \n  [x: 0, value: v, label: abs(v) + \" \" + units[1], visible: true])", "description": "", "templateType": "anything", "can_override": false}, "l": {"name": "l", "group": "properties", "definition": "18", "description": "", "templateType": "anything", "can_override": false}, "m1": {"name": "m1", "group": "properties", "definition": "let(v, random_force(), \n  [x: 0, value: v, label: abs(v) + \" \" + units[2], visible: true])", "description": "", "templateType": "anything", "can_override": false}, "m2": {"name": "m2", "group": "properties", "definition": "let(v, random_force(), [x: 0, value: v, label: abs(v) + \" \" + units[2], visible: true])", "description": "", "templateType": "anything", "can_override": false}, "reactions": {"name": "reactions", "group": "lists", "definition": "[[x: xa, value: ra, label: \"A\", visible: false],[x: xb, value: rb, label: \"B\", visible: false]]", "description": "<p>pin, roller, fixed, dot</p>", "templateType": "anything", "can_override": false}, "w1": {"name": "w1", "group": "properties", "definition": "let(ww, shuffle([0, w]),\n    [[x: 0, value: ww[0] ,  label: max(ww[0],ww[1]) + \" \" + units[3], visible: true], \n     [x: L, value: ww[1] ,  label: \" \"]])", "description": "<p>this makes either an increasing or decreasing triangular load of length L</p>", "templateType": "anything", "can_override": false}, "beam": {"name": "beam", "group": "Ungrouped variables", "definition": "vmloaddiagram(properties)", "description": "", "templateType": "anything", "can_override": false}, "shear": {"name": "shear", "group": "Ungrouped variables", "definition": "vmsheardiagram(properties, debug)", "description": "", "templateType": "anything", "can_override": false}, "forces": {"name": "forces", "group": "lists", "definition": "[]", "description": "", "templateType": "anything", "can_override": false}, "rB": {"name": "rB", "group": "reactions", "definition": "(sum(map(f->cross( vector(xa-f[\"x\"],0,0),vector(0,f[\"value\"],0))[2],forces))\n+sum(map(f->cross( vector(xa-f[\"x\"],0,0),vector(0,f[\"value\"],0))[2],equivalent_loads))\n+ sum(map(m->m['value'], moments)))/(xa-xb)", "description": "", "templateType": "anything", "can_override": false}, "rA": {"name": "rA", "group": "reactions", "definition": "(sum(map(f->cross( vector(xb-f[\"x\"],0,0),vector(0,-f[\"value\"],0))[2],forces+equivalent_loads))\n- sum(map(m->m['value'], moments)))/(xa-xb)\n", "description": "", "templateType": "anything", "can_override": false}, "sigmaF_check": {"name": "sigmaF_check", "group": "reactions", "definition": "[foldl((total, f) -> total + f[\"value\"], 0, forces+equivalent_loads),ra+rb]\n", "description": "", "templateType": "anything", "can_override": false}, "xa": {"name": "xa", "group": "reactions", "definition": "0", "description": "", "templateType": "anything", "can_override": false}, "xb": {"name": "xb", "group": "reactions", "definition": "L", "description": "", "templateType": "anything", "can_override": false}, "moments": {"name": "moments", "group": "lists", "definition": "[]", "description": "", "templateType": "anything", "can_override": false}, "area": {"name": "area", "group": "lists", "definition": "w -> let (xa, w[0][\"x\"], xb, w[1][\"x\"], ya, w[0][\"value\"], yb, w[1][\"value\"] ,(xb-xa)(ya+yb)/2)", "description": "", "templateType": "anything", "can_override": false}, "xbar": {"name": "xbar", "group": "lists", "definition": "(w) -> let (xa, w[0][\"x\"], xb, w[1][\"x\"], ya, w[0][\"value\"], yb, w[1][\"value\"] , if(xa+xb=0, 0, xa+(xb - xa)*(ya + 2 yb)/3/(ya + yb)))", "description": "<p>gives horizontal location of centroid of distributed load w</p>", "templateType": "anything", "can_override": false}, "equivalent_loads": {"name": "equivalent_loads", "group": "lists", "definition": "map((w)->let( f , area(w), [x:  xbar(w), value: f, label: f + \" lb\"]),loads)", "description": "", "templateType": "anything", "can_override": false}, "loads": {"name": "loads", "group": "lists", "definition": "random([w1],[w2,w3])", "description": "", "templateType": "anything", "can_override": false}, "w2": {"name": "w2", "group": "properties", "definition": "let(ww, shuffle([0, w]),\n    [[x: 0, value: ww[0] ,  label: max(ww[0],ww[1]) + \" \" + units[3], visible: true], \n     [x: L/2, value: ww[1] ,  label: \" \"]])", "description": "", "templateType": "anything", "can_override": false}, "moment": {"name": "moment", "group": "Ungrouped variables", "definition": "vmmomentdiagram(properties, debug)", "description": "", "templateType": "anything", "can_override": false}, "symbols": {"name": "symbols", "group": "lists", "definition": "[[type: \"pin\", x: xa, label: \"$R_A$\", visible: true], [type: \"roller\", x: xb, label: \"$R_B$\", visible: true]]", "description": "<p>legal types: pin, roller, dot, fixed</p>", "templateType": "anything", "can_override": false}, "InterestingShearPoints": {"name": "InterestingShearPoints", "group": "Ungrouped variables", "definition": "vmshearpoints(properties)", "description": "", "templateType": "anything", "can_override": false}, "InterestingMomentPoints": {"name": "InterestingMomentPoints", "group": "Ungrouped variables", "definition": "vmmomentpoints(properties)", "description": "", "templateType": "anything", "can_override": false}, "vmax": {"name": "vmax", "group": "Ungrouped variables", "definition": "let( max, max(map(p ->p[1], InterestingshearPoints)),\n  min, min(map(p ->p[1], InterestingshearPoints)),\n  if(abs(max)>abs(min), max, min))", "description": "", "templateType": "anything", "can_override": false}, "mmax": {"name": "mmax", "group": "Ungrouped variables", "definition": "let( max, max(map(p ->p[1], interestingmomentpoints)),\n  min, min(map(p ->p[1], interestingmomentpoints)),\n  if(abs(max)>abs(min), max, min))", "description": "", "templateType": "anything", "can_override": false}, "unique_points": {"name": "unique_points", "group": "properties", "definition": "sort(shuffle(0..L)[0..2])", "description": "", "templateType": "anything", "can_override": false}, "MomentCheck": {"name": "MomentCheck", "group": "reactions", "definition": "siground((\n  sum(map(f->cross( vector(L-f[\"x\"],0,0),vector(0,-f[\"value\"],0))[2],forces+equivalent_loads))\n- sum(map(f->cross(vector(L-f[\"x\"],0,0),vector(0,-f[\"value\"],0))[2],reactions))\n- sum(map(m->m['value'], moments))),6)", "description": "", "templateType": "anything", "can_override": false}, "units": {"name": "units", "group": "Ungrouped variables", "definition": "random(['ft','lb', 'ft*lb', 'lb/ft'],['m','kN', 'kN*m', 'kN/m'])", "description": "", "templateType": "anything", "can_override": false}, "size": {"name": "size", "group": "reactions", "definition": "random(10,50)", "description": "", "templateType": "anything", "can_override": false}, "random_force": {"name": "random_force", "group": "reactions", "definition": "() -> round(size * random(-1..1.5#0.1 except 0))", "description": "<p>gives values of about the same order of magnitude.</p>", "templateType": "anything", "can_override": false}, "w3": {"name": "w3", "group": "properties", "definition": "let(ww, shuffle([0, w]),\n    [[x: L/2, value: ww[0] ,  label: max(ww[0],ww[1]) + \" \" + units[3], visible: true], \n     [x: L, value: ww[1] ,  label: \" \"]])", "description": "", "templateType": "anything", "can_override": false}, "w": {"name": "w", "group": "properties", "definition": "random(0.5.. 1.5 except 0)  size", "description": "", "templateType": "anything", "can_override": false}, "debug": {"name": "debug", "group": "Ungrouped variables", "definition": "false", "description": "", "templateType": "anything", "can_override": false}}, "variablesTest": {"condition": "", "maxRuns": 100}, "ungrouped_variables": ["beam", "shear", "moment", "InterestingShearPoints", "InterestingMomentPoints", "vmax", "mmax", "units", "debug"], "variable_groups": [{"name": "reactions", "variables": ["xa", "xb", "rB", "rA", "sigmaF_check", "MomentCheck", "size", "random_force"]}, {"name": "properties", "variables": ["l", "F1", "F2", "F3", "m1", "m2", "w", "w1", "w2", "w3", "unique_points"]}, {"name": "lists", "variables": ["properties", "reactions", "forces", "loads", "moments", "equivalent_loads", "symbols", "area", "xbar"]}], "functions": {}, "preamble": {"js": "question.signals.on('adviceDisplayed', () => {\n  ['moment','shear'].forEach((board) => {\n  var objects = question.scope.getVariable(board).board.objects;\n  objects.Curve.setAttribute({visible: true});\n  Object.keys(objects).filter(k => k.startsWith('Point-')).forEach((k) => objects[k].setAttribute({visible: true}));\n  Object.keys(objects).filter(k => k.startsWith('Jump-')).forEach((k) => objects[k].setAttribute({visible: true}));\n});\n});\n", "css": ""}, "parts": [{"type": "gapfill", "useCustomName": false, "customName": "", "marks": 0, "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": true, "showFeedbackIcon": true, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "prompt": "<p>Draw the shear and bending moment diagram and determine:</p>\n<p><strong>Reactions: </strong>Upward forces positive, downward negative.</p>\n<p>$A = $ [[0]]</p>\n<p>$B = $ [[1]]</p>\n<p><strong>Maximum Shear and Bending Moment: </strong>Positive or negative using the standard sign convention</p>\n<p>$V_\\text{max} = $ [[2]]</p>\n<p>$M_\\text{max} = $ [[3]]</p>", "gaps": [{"type": "engineering-answer", "useCustomName": true, "customName": "$A$", "marks": "5", "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": true, "showFeedbackIcon": true, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "settings": {"correctAnswer": "qty(ra,units[1])", "right": "0.2", "close": "1.0", "C1": "75", "C2": "50", "C3": "25"}}, {"type": "engineering-answer", "useCustomName": true, "customName": "$B$", "marks": "5", "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": true, "showFeedbackIcon": true, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "settings": {"correctAnswer": "qty(rb,units[1])", "right": "0.2", "close": "1.0", "C1": "75", "C2": "50", "C3": "25"}}, {"type": "engineering-answer", "useCustomName": true, "customName": "$V_\\text{max}$", "marks": "5", "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": true, "showFeedbackIcon": true, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "settings": {"correctAnswer": "qty(vmax, units[1])", "right": "0.2", "close": "1.0", "C1": "75", "C2": "50", "C3": "25"}}, {"type": "engineering-answer", "useCustomName": true, "customName": "$M_\\text{max}$", "marks": "5", "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": true, "showFeedbackIcon": true, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "settings": {"correctAnswer": "qty(mmax, units[2])", "right": "0.2", "close": "1.0", "C1": "75", "C2": "50", "C3": "25"}}], "sortAnswers": false}], "partsMode": "all", "maxMarks": 0, "objectives": [], "penalties": [], "objectiveVisibility": "always", "penaltyVisibility": "always"}, {"name": "VM7: Symmetric parabolic loading", "extensions": ["jsxgraph", "polynomials", "quantities"], "custom_part_types": [{"source": {"pk": 19, "author": {"name": "William Haynes", "pk": 2530}, "edit_page": "/part_type/19/edit"}, "name": "Engineering Accuracy with units", "short_name": "engineering-answer", "description": "<p>A value with units marked right if within an adjustable % error of the correct value. &nbsp;Marked close if within a wider margin of error.</p>", "help_url": "", "input_widget": "string", "input_options": {"correctAnswer": "siground(settings['correctAnswer'],4)", "hint": {"static": true, "value": ""}, "allowEmpty": {"static": true, "value": true}}, "can_be_gap": true, "can_be_step": true, "marking_script": "mark:\nswitch( \n  right and good_units and right_sign, add_credit(1.0,'Correct.'),\n  right and good_units and not right_sign, add_credit(settings['C2'],'Wrong sign.'),\n  right and right_sign and not good_units, add_credit(settings['C2'],'Correct value, but wrong or missing units.'),\n  close and good_units, add_credit(settings['C1'],'Close.'),\n  close and not good_units, add_credit(settings['C3'],'Answer is close, but wrong or missing units.'),\n  incorrect('Wrong answer.')\n)\n\ninterpreted_answer:\nqty(student_scalar, student_units)\n\n\n\ncorrect_quantity:\nsettings[\"correctAnswer\"]\n\n\n\ncorrect_units:\nunits(correct_quantity)\n\n\nallowed_notation_styles:\n[\"plain\",\"en\"]\n\nmatch_student_number:\nmatchnumber(studentAnswer,allowed_notation_styles)\n\nstudent_scalar:\nmatch_student_number[1]\n\nstudent_units:\nreplace_regex('ohms','ohm',\n  replace_regex('\u00b0', ' deg',\n    replace_regex('-', ' ' ,\n      studentAnswer[len(match_student_number[0])..len(studentAnswer)])),\"i\")\n\ngood_units:\ntry(\ncompatible(quantity(1, student_units),correct_units),\nmsg,\nfeedback(msg);false)\n\n\nstudent_quantity:\nswitch(not good_units, \n       student_scalar * correct_units, \n       not right_sign,\n       -quantity(student_scalar, student_units),\n       quantity(student_scalar,student_units)\n)\n  \n\n\npercent_error:\ntry(\nscalar(abs((correct_quantity - student_quantity)/correct_quantity))*100  \n,msg,\nif(student_quantity=correct_quantity,0,100))\n   \n\nright:\npercent_error <= settings['right']\n\n\nclose:\nright_sign and percent_error <= settings['close']\n\nright_sign:\nsign(student_scalar) = sign(correct_quantity)", "marking_notes": [{"name": "mark", "description": "This is the main marking note. It should award credit and provide feedback based on the student's answer.", "definition": "switch( \n  right and good_units and right_sign, add_credit(1.0,'Correct.'),\n  right and good_units and not right_sign, add_credit(settings['C2'],'Wrong sign.'),\n  right and right_sign and not good_units, add_credit(settings['C2'],'Correct value, but wrong or missing units.'),\n  close and good_units, add_credit(settings['C1'],'Close.'),\n  close and not good_units, add_credit(settings['C3'],'Answer is close, but wrong or missing units.'),\n  incorrect('Wrong answer.')\n)"}, {"name": "interpreted_answer", "description": "A value representing the student's answer to this part.", "definition": "qty(student_scalar, student_units)\n\n"}, {"name": "correct_quantity", "description": "", "definition": "settings[\"correctAnswer\"]\n\n"}, {"name": "correct_units", "description": "", "definition": "units(correct_quantity)\n"}, {"name": "allowed_notation_styles", "description": "", "definition": "[\"plain\",\"en\"]"}, {"name": "match_student_number", "description": "", "definition": "matchnumber(studentAnswer,allowed_notation_styles)"}, {"name": "student_scalar", "description": "", "definition": "match_student_number[1]"}, {"name": "student_units", "description": "<p>Modify&nbsp;the&nbsp;unit portion of&nbsp;the student's answer by</p>\n<p>1. replacing \"ohms\" with \"ohm\" &nbsp;case insensitive</p>\n<p>2.&nbsp;replacing '-'&nbsp;with ' '&nbsp;</p>\n<p>3. replacing '&deg;' with ' deg'&nbsp;</p>\n<p>to allow answers like 10 ft-lb and 30&deg;</p>", "definition": "replace_regex('ohms','ohm',\n  replace_regex('\u00b0', ' deg',\n    replace_regex('-', ' ' ,\n      studentAnswer[len(match_student_number[0])..len(studentAnswer)])),\"i\")"}, {"name": "good_units", "description": "", "definition": "try(\ncompatible(quantity(1, student_units),correct_units),\nmsg,\nfeedback(msg);false)\n"}, {"name": "student_quantity", "description": "<p>This fixes the student answer for two common errors. &nbsp;</p>\n<p>If student_units are wrong&nbsp;&nbsp;- replace with correct units</p>\n<p>If student_scalar has the wrong sign - replace with right sign</p>\n<p>If student makes both errors, only one gets fixed.</p>", "definition": "switch(not good_units, \n       student_scalar * correct_units, \n       not right_sign,\n       -quantity(student_scalar, student_units),\n       quantity(student_scalar,student_units)\n)\n  \n"}, {"name": "percent_error", "description": "", "definition": "try(\nscalar(abs((correct_quantity - student_quantity)/correct_quantity))*100  \n,msg,\nif(student_quantity=correct_quantity,0,100))\n   "}, {"name": "right", "description": "", "definition": "percent_error <= settings['right']\n"}, {"name": "close", "description": "<p>Only marked close if the student actually has the right sign.</p>", "definition": "right_sign and percent_error <= settings['close']"}, {"name": "right_sign", "description": "", "definition": "sign(student_scalar) = sign(correct_quantity) "}], "settings": [{"name": "correctAnswer", "label": "Correct Quantity.", "help_url": "", "hint": "The correct answer given as a JME quantity.", "input_type": "code", "default_value": "", "evaluate": true}, {"name": "right", "label": "% Accuracy for right.", "help_url": "", "hint": "Question will be considered correct if the scalar part of the student's answer is within this % of correct value.", "input_type": "code", "default_value": "0.2", "evaluate": true}, {"name": "close", "label": "% Accuracy for close.", "help_url": "", "hint": "Question will be considered close if the scalar part of the student's answer is within this % of correct value.", "input_type": "code", "default_value": "1.0", "evaluate": true}, {"name": "C1", "label": "Close with units.", "help_url": "", "hint": "Partial Credit for close value with appropriate units. &nbsp;if correct answer is 100 N and close is &plusmn;1%,<br />99 &nbsp;N is accepted.", "input_type": "percent", "default_value": "75"}, {"name": "C2", "label": "No units or wrong sign", "help_url": "", "hint": "Partial credit for forgetting units or using wrong sign.<br />If the correct answer is 100 N, both 100 and -100 N are accepted.", "input_type": "percent", "default_value": "50"}, {"name": "C3", "label": "Close, no units.", "help_url": "", "hint": "Partial Credit for close value but forgotten units.<br />This value would be close&nbsp;if the expected units were provided. &nbsp;If the correct answer is 100 N, and close is &plusmn;1%,<br />99 is accepted.", "input_type": "percent", "default_value": "25"}], "public_availability": "always", "published": true, "extensions": ["quantities"]}], "resources": ["question-resources/newVM_cA1Sig0.ggb"], "navigation": {"allowregen": true, "showfrontpage": false, "preventleave": false, "typeendtoleave": false}, "contributors": [{"name": "William Haynes", "profile_url": "https://numbas.mathcentre.ac.uk/accounts/profile/2530/"}], "tags": ["gets answer from ggb", "Mechanics", "mechanics", "shear and bending moment", "Statics", "statics"], "metadata": {"description": "<p>&nbsp;Students must derive the shear and bending moment functions for beam loaded with a parabolic distributed load described with a loading function. &nbsp;Diagrams are given, but the students must derive the equations by integration.</p>", "licence": "Creative Commons Attribution-NonCommercial 4.0 International"}, "statement": "<p>A {qty(2b, units[0])} long, simply-supported beam is subjected to a symmetrical parabolic loading, where</p>\n<p>\\[w(x) =\\simplify[fractionNumbers]{{w}} \\quad [\\var{units_string(qty(1,units[3]))}]\\].</p>\n<p><span data-jme-visible=\"debug\">$V(x) =\\simplify[fractionNumbers]{{v}}$ &nbsp;$[\\var{units_string(qty(1,units[1]))}]$.</span></p>\n<p><span data-jme-visible=\"debug\">$M(x) =\\simplify[fractionNumbers]{{m}}$ &nbsp; $[\\var{units_string(qty(1,units[2]))}]$.</span></p>\n<p>{loadBoard}</p>\n<p>{shearBoard}</p>\n<p>{momentBoard}</p>\n<p></p>", "advice": "<p><strong>Given</strong>: &nbsp;The beam is $\\var{qty(L, units[0])}$ long. The loading function is \\[w(x) = \\simplify[fractionNumbers]{{w}}.\\]</p>\n<p>The area under the loading function is the downward force on the beam. Here, because positive values of $w$ point down, we replace $w(x)$ with $-w(x)$ &nbsp;to agree with the standard convention that <em>negative</em> forces point down.</p>\n<p>1. &nbsp;The total load acting on the beam is the integral loading function from $0$ to $L$.</p>\n<p style=\"padding-left: 40px;\">\\[\\begin{align}W &amp;= -\\int_0^L w(x)\\; dx \\\\ <br/>&amp;= \\int_0^L \\simplify[fractionNumbers]{{-w}}\\; dx\\\\<br/>&amp;= &nbsp;\\left. \\simplify[fractionNumbers]{{polynomial(x,[ 0,0,-h/b, h/(b^2)/3])}}\\;\\right |_0^L \\\\<br/>&amp;= \\var{force(load_integral)}<br/>\\end{align}\\]</p>\n<p>By symmetry, the reactions at $x=0$ and $x= L$ are each half this load, pointing up, so:</p>\n<p style=\"padding-left: 40px;\">\\[\\begin{align}A &amp;= B=W/2 \\\\<br/>&nbsp;&amp;=\\var{-force(load_integral/2)}\\end{align}\\]</p>\n<p>2. &nbsp; The shear function $V(x)$ is the integral of the loading function $w(x)$. &nbsp;</p>\n<p style=\"padding-left: 40px;\">\\[\\begin{align} V(x) &amp;= -\\int w(x)\\; dx \\\\<br/>&amp;= \\int \\simplify[fractionNumbers]{{-w}}\\;dx\\\\<br/>&amp;= \\simplify[fractionNumbers]{{polynomial(x,[ 0,0, -h/b, h/(b^2)/3])}} + C_0 \\end{align}\\]</p>\n<p>The constant of integration can be found by evaluating the shear function at $x=0$, where $V(0) = A$ to get</p>\n<p style=\"padding-left: 40px;\">\\[V(0) = C_0 = \\var{force(-load_integral/2)} \\]</p>\n<p>5. &nbsp;The moment function is the integral of the shear function</p>\n<p style=\"padding-left: 40px;\">\\[\\begin{align} M(x) &amp;= \\int V(x)\\; dx \\\\<br/>&amp;= \\int \\simplify[fractionNumbers]{{polynomial(x,[ 0,0, -h/b, h/(b^2)/3])}} + C_0 \\;dx\\\\<br/>&amp; = \\simplify[fractionNumbers]{{m}} + C_1\\\\<br/>\\end{align}\\]</p>\n<p>Since the moment $M(0) = 0$, $C_1 = 0$</p>\n<p>6. The Maximum shear occurs at the ends, where $dV /dx = -w(x) = 0$</p>\n<p style=\"padding-left: 30px;\">\\[\\begin{align}V_{max} &amp;= V(0) = V(L)\\\\<br/>&amp;= \\var{force(maximums[1])}\\end{align} <br/>\\]</p>\n<p>7. The &nbsp;Maximum moment occurs at midpoint, $x = \\var{qty(L/2,units[0])}$, where $dM/dx = 0$</p>\n<p style=\"padding-left: 30px;\">\\[\\begin{align}M_{max} &amp;= M(\\var{b})\\\\ <br/>&amp;= \\var{moment(maximums[2])}\\end{align}\\]</p>\n<p></p>", "rulesets": {}, "builtin_constants": {"e": true, "pi,\u03c0": true, "i": true, "j": false}, "constants": [], "variables": {"units": {"name": "units", "group": "Unnamed group", "definition": "random(['ft','lb', 'ft*lb', 'lb/ft'],['m','kN', 'kN*m', 'kN/m'])", "description": "", "templateType": "anything", "can_override": false}, "b": {"name": "b", "group": "Ungrouped variables", "definition": "0.5 L", "description": "<p>half width of beam \"base\"</p>", "templateType": "anything", "can_override": false}, "h": {"name": "h", "group": "Ungrouped variables", "definition": "random([1,2,2.5,5,7.5,10])random([10,100])", "description": "<p>distributed load at the center of the beam. &nbsp;The \"height\" of the parabola</p>", "templateType": "anything", "can_override": false}, "w": {"name": "w", "group": "Ungrouped variables", "definition": "polynomial(x,[0,2 h/b,-h/(b^2)])", "description": "<p style=\"text-align: left;\">loading function w(x)</p>", "templateType": "anything", "can_override": false}, "F_A": {"name": "F_A", "group": "Unnamed group", "definition": "rational(2/3 b h)", "description": "<p>Reaction at A = half the downward force ( 2/3 bh)</p>\n<p>Reaction at B is the same.</p>", "templateType": "anything", "can_override": false}, "v": {"name": "v", "group": "Ungrouped variables", "definition": "polynomial(x,[ F_A,0, -h/b, h/(b^2)/3])", "description": "<p>the shear function. result of integrating -w(x)</p>", "templateType": "anything", "can_override": false}, "m": {"name": "m", "group": "Ungrouped variables", "definition": "polynomial(x,[0, F_A,0, -h/b/3, h/(b^2)/3/4])", "description": "<p>The moment function m(x), result of integrating v(x)</p>", "templateType": "anything", "can_override": false}, "w_t": {"name": "w_t", "group": "Unnamed group", "definition": "2 F_A", "description": "<p>Total Weight supported by the beam</p>", "templateType": "anything", "can_override": false}, "debug": {"name": "debug", "group": "Ungrouped variables", "definition": "false", "description": "", "templateType": "anything", "can_override": false}, "loadBoard": {"name": "loadBoard", "group": "Ungrouped variables", "definition": "let(max, maximums[0],\n  jsxgraph(\n    480,200,[-2, 1.2 max, 2 b+2, - max/2],\n    merge(\n    [   \"$w(x)$\": ['functiongraph', [load_function, 0, L], [name: \"a\", withLabel: true, strokeWidth: 3, strokeColor: \"#CC0000\", fillColor: \"#CC0000\", \n            fillOpacity: 0.1,label:[fixed: false, fontSize: 14]]]],\narrows,\n    [\"beam\":   ['segment', [[0,0],[L,0]], [strokeWidth: 5, color: \"black\"]] ],\n    [ \"$A$\": ['segment', [[0,-max 0.4], [0,0]], merge(reactionoptions, [label: [fixed: false, color: \"#CC0000\", fontSize: 16]])]],\n    [ \"$B$\": ['segment', [[L,-max 0.4],[L,0],], merge(reactionoptions, [label: [fixed: false, color: \"#CC0000\", fontSize: 16]])]]\n  )\n)\n)", "description": "", "templateType": "anything", "can_override": false}, "load_function": {"name": "load_function", "group": "Ungrouped variables", "definition": "expr(polynomials[0])", "description": "", "templateType": "anything", "can_override": false}, "maximums": {"name": "maximums", "group": "Ungrouped variables", "definition": "let(\n  w, polynomials[0],\n  v, polynomials[1],\n  m, polynomials[2],\n  [eval(w,b),eval(v,0),eval(m,b)])", "description": "<p>load function at peak</p>", "templateType": "anything", "can_override": false}, "L": {"name": "L", "group": "Ungrouped variables", "definition": "20", "description": "<p>beamLength</p>", "templateType": "anything", "can_override": false}, "shear_function": {"name": "shear_function", "group": "Ungrouped variables", "definition": "expr(polynomials[1])", "description": "", "templateType": "anything", "can_override": false}, "moment_function": {"name": "moment_function", "group": "Ungrouped variables", "definition": "expr(polynomials[2])", "description": "", "templateType": "anything", "can_override": false}, "polynomials": {"name": "polynomials", "group": "Ungrouped variables", "definition": "[\npolynomial(x,[0,2 h/b,-h/(b^2)]),\npolynomial(x,[ F_A,0, -h/b, h/(b^2)/3]),\npolynomial(x,[0, F_A,0, -h/b/3, h/(b^2)/3/4])\n]", "description": "", "templateType": "anything", "can_override": false}, "shearBoard": {"name": "shearBoard", "group": "Ungrouped variables", "definition": "let(max, 1.2*maximums[1],\n  jsxgraph(\n    480,200,[-2, 1.1 max, 2 b+2, -max],\n    [   \n        \"$V(x)$\": ['functiongraph', [shear_function, 0, L], [withLabel: true, strokeWidth: 3, strokeColor: \"#CC0000\" ,label:[fixed: false, fontSize: 14]]],\n\n    ]\n))", "description": "", "templateType": "anything", "can_override": false}, "momentBoard": {"name": "momentBoard", "group": "Ungrouped variables", "definition": " let(max, maximums[2], color,  \"#3070AD\", \n  jsxgraph(\n    480,200,[-2, 1.2 max, 2 b+2, -max/3],\n    [\"$M(x)$\": ['functiongraph', [moment_function, 0, L], [withLabel: true, strokeWidth: 3, strokeColor: color, label:[fixed: false, fontSize: 14]]],\n ],\n    ))", "description": "", "templateType": "anything", "can_override": false}, "shearload": {"name": "shearload", "group": "Ungrouped variables", "definition": "eval(-w,L)", "description": "", "templateType": "anything", "can_override": false}, "force": {"name": "force", "group": "Ungrouped variables", "definition": "f -> siground(qty(f,units[1]),4)", "description": "", "templateType": "anything", "can_override": false}, "moment": {"name": "moment", "group": "Ungrouped variables", "definition": "m -> siground(qty(m,units[2]),4)", "description": "", "templateType": "anything", "can_override": false}, "load_integral": {"name": "load_integral", "group": "Ungrouped variables", "definition": "eval(polynomial(x,[0,0, -h/b, h/(b^2)/3]),L)", "description": "", "templateType": "anything", "can_override": false}, "Arrow": {"name": "Arrow", "group": "Ungrouped variables", "definition": "let( w , polynomials[0],\n  (x) ->  ['segment', [[x, eval(w,x)],[x,0]],[ fixed: true, color: \"black\",strokewidth: 1.5,highlight: false, lastArrow: [ type: 4 ]]])", "description": "", "templateType": "anything", "can_override": false}, "reactionOptions": {"name": "reactionOptions", "group": "Ungrouped variables", "definition": "[withLabel: true, \"fixed\": true, \"color\": \"#CC0000\", \"strokewidth\": 4, \"highlight\": false, \"lastArrow\": [ \"type\": 4 ] ]", "description": "", "templateType": "anything", "can_override": false}, "Arrows": {"name": "Arrows", "group": "Ungrouped variables", "definition": "dict(map((i)->([(\"A\"+i),Arrow(i)]), 1..L))", "description": "", "templateType": "anything", "can_override": false}}, "variablesTest": {"condition": "", "maxRuns": 100}, "ungrouped_variables": ["debug", "L", "b", "h", "w", "v", "m", "maximums", "load_function", "shear_function", "moment_function", "polynomials", "loadBoard", "shearBoard", "momentBoard", "shearload", "force", "moment", "load_integral", "Arrow", "reactionOptions", "Arrows"], "variable_groups": [{"name": "Unnamed group", "variables": ["w_t", "F_A", "units"]}], "functions": {"show_curvesxxx": {"parameters": [["app", "?"]], "type": "anything", "language": "javascript", "definition": "app.promise.then(function(d) {\n  d.app.setVisible(\"showV\", true,false);\n  d.app.setVisible(\"showM\", true,false);\n  d.app.setValue(\"showV\",true);\n  d.app.setValue(\"showM\",true);\n});\nreturn \"\"//new Numbas.jme.types.ggbapplet(app);\n"}}, "preamble": {"js": "\n", "css": ""}, "parts": [{"type": "gapfill", "useCustomName": true, "customName": "Load and Reactions", "marks": 0, "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": true, "showFeedbackIcon": true, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "prompt": "<p>Determine the total weight supported by the beam and the reactions at $A$ and $B$.</p>\n<p>$W = $ [[0]]</p>\n<p>$R_A =$&nbsp;[[1]]</p>\n<p>$R_B = $ [[2]]</p>\n<p><span data-jme-visible=\"debug\">$R_A = R_B =\\simplify[fractionNumbers]{{F_A}}$ = &nbsp;{force(F_A)}</span></p>", "stepsPenalty": "10", "steps": [{"type": "information", "useCustomName": false, "customName": "", "marks": 0, "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": true, "showFeedbackIcon": true, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "prompt": "<p>The total weight is found by integrating the loading function $w(x)$. &nbsp;Positive values indicate a downward load.</p>\n<p style=\"padding-left: 40px;\">$\\begin{align}W &amp;= \\simplify{defint(w,x,0,L)}\\\\ &amp;= \\simplify[fractionNumbers,canonicalOrder]{defint({w},x,0,{2b})}\\end{align}$</p>\n<p>By symmetry, the reactions are half the weight:</p>\n<p style=\"padding-left: 40px;\">$F_A = F_B = \\dfrac{W}{2}$. &nbsp;These point up.</p>"}], "gaps": [{"type": "engineering-answer", "useCustomName": true, "customName": "$W$", "marks": "10", "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": true, "showFeedbackIcon": true, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "settings": {"correctAnswer": "qty(2 F_A,units[1])", "right": "0.2", "close": "1.0", "C1": "75", "C2": "50", "C3": "25"}}, {"type": "engineering-answer", "useCustomName": true, "customName": "$R_A$", "marks": "5", "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": true, "showFeedbackIcon": true, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "settings": {"correctAnswer": "force(F_A)", "right": "0.2", "close": "1.0", "C1": "75", "C2": "50", "C3": "25"}}, {"type": "engineering-answer", "useCustomName": true, "customName": "$R_B$", "marks": "5", "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": true, "showFeedbackIcon": true, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "settings": {"correctAnswer": "force(F_A)", "right": "0.2", "close": "1.0", "C1": "75", "C2": "50", "C3": "25"}}], "sortAnswers": false}, {"type": "gapfill", "useCustomName": true, "customName": "Shear and Bending Moment Functions", "marks": 0, "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": true, "showFeedbackIcon": true, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "prompt": "<p>Determine expressions for:</p>\n<p>$V\\!(x) =$&nbsp;[[0]]</p>\n<p>$M\\!(x) =$&nbsp;[[1]]</p>\n<p>and then plot the shear and bending moment diagrams.</p>\n<p><span data-jme-visible=\"debug\">$V(x) = \\simplify[canonicalOrder,fractionNumbers]{{v}}$</span></p>\n<p><span data-jme-visible=\"debug\">$M(x) = \\simplify[canonicalOrder,fractionNumbers]{{m}}$</span></p>\n<p></p>", "stepsPenalty": "10", "steps": [{"type": "information", "useCustomName": false, "customName": "", "marks": 0, "scripts": {"validate": {"script": "{show_curves(applet)}", "order": "after"}}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": true, "showFeedbackIcon": true, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "prompt": "<p>The shear function is found by integrating the loading function. The negative sign is because positive values of w(x) represent a load which points down.</p>\n<p style=\"padding-left: 40px;\">$\\begin{align}V(x) &amp;= &nbsp;\\simplify{-defint(w,x,0,x)} \\\\&amp;= \\simplify[fractionNumbers,canonicalOrder]{defint({-w},x,0,L)} \\\\&amp;= \\simplify[fractionNumbers,canonicalOrder]{{v}}\\end{align}$</p>\n<p>The bending moment function is found by integrating the shear function.</p>\n<p style=\"padding-left: 40px;\">$\\begin{align}M(x) &amp;= \\simplify{defint(V,x,0,x)}\\\\&amp;= \\simplify[fractionNumbers,canonicalOrder]{defint({v},x,0,L)} \\\\&amp;= \\simplify[fractionNumbers,canonicalOrder]{{M}}\\end{align}$</p>\n<p>In both cases, the resulting constant of integration is determined by considering the values at $x=0$.</p>\n<p style=\"padding-left: 40px;\">$V(0) = F_A, \\text{ and } M(0) = 0$</p>\n<p></p>"}], "gaps": [{"type": "jme", "useCustomName": true, "customName": "V(x)", "marks": "10", "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": true, "showFeedbackIcon": true, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "answer": "{expr(v)}", "answerSimplification": "fractionNumbers", "showPreview": true, "checkingType": "sigfig", "checkingAccuracy": "2", "failureRate": 1, "vsetRangePoints": 5, "vsetRange": [0, 1], "checkVariableNames": false, "singleLetterVariables": false, "allowUnknownFunctions": true, "implicitFunctionComposition": false, "caseSensitive": false, "valuegenerators": []}, {"type": "jme", "useCustomName": true, "customName": "M(x)", "marks": "10", "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": true, "showFeedbackIcon": true, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "answer": "{expr(m)}", "answerSimplification": "fractionNumbers", "showPreview": true, "checkingType": "sigfig", "checkingAccuracy": "2", "failureRate": 1, "vsetRangePoints": 5, "vsetRange": [0, 1], "checkVariableNames": false, "singleLetterVariables": false, "allowUnknownFunctions": true, "implicitFunctionComposition": false, "caseSensitive": false, "valuegenerators": []}], "sortAnswers": false}, {"type": "gapfill", "useCustomName": true, "customName": "Maximum internal loads", "marks": 0, "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": true, "showFeedbackIcon": true, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "prompt": "<p>Give the (signed) values of the largest&nbsp;shear and bending moment occuring anywhere within the beam. &nbsp;Use the standard sign convention for shear and bending moments.</p>\n<p>$V_{\\text{max}} = $ &nbsp;[[0]]&nbsp;$\\qquad M_{\\text{max}} = $ &nbsp;[[1]]</p>\n<p><span data-jme-visible=\"debug\">$V_{max} = \\var{siground(qty(eval(v,0),units[1]),4)}$&nbsp;</span></p>\n<p><span data-jme-visible=\"debug\">$M_{max} = \\var{siground(qty(eval(m,b),units[0]+\" \" + units[1]),4)}$</span></p>\n<p></p>", "stepsPenalty": "10", "steps": [{"type": "information", "useCustomName": false, "customName": "", "marks": 0, "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": true, "showFeedbackIcon": true, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "prompt": "<p>The maximum shear occurs at the ends, where $\\simplify{diff(V,x,1)} = -w(x) = 0$ i.e. at $x=0$, or $x=\\var{qty(2b,units[0])}$.</p>\n<p style=\"padding-left: 40px;\">$\\begin{align}V_{max} &amp;= V(0) \\\\ &amp;= \\var{siground(qty(F_A,units[1]),4)}\\end{align}$</p>\n<p>Maximum moment occurs at midpoint, where $\\simplify{diff(M,x,1)} = V = 0$</p>\n<p style=\"padding-left: 40px;\">$\\begin{align}M_{max} &amp;= M(\\var{b}) \\\\&amp;= \\var{siground(qty(eval(m,b),units[0] + ' ' + units[1]),4)}\\end{align}$</p>"}], "gaps": [{"type": "engineering-answer", "useCustomName": true, "customName": "$V_{max}$", "marks": "10", "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": true, "showFeedbackIcon": true, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "settings": {"correctAnswer": "force(F_A)", "right": "0.5", "close": "1", "C1": "75", "C2": "50", "C3": "25"}}, {"type": "engineering-answer", "useCustomName": true, "customName": "$M_{max}$", "marks": "10", "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": true, "showFeedbackIcon": true, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "settings": {"correctAnswer": "moment(eval(m,b))", "right": "0.5", "close": "1", "C1": "75", "C2": "50", "C3": "25"}}], "sortAnswers": false}], "partsMode": "all", "maxMarks": 0, "objectives": [], "penalties": [], "objectiveVisibility": "always", "penaltyVisibility": "always"}, {"name": "VM8: Arbitrary loading function", "extensions": ["jsxgraph", "linear-algebra", "polynomials", "quantities"], "custom_part_types": [{"source": {"pk": 19, "author": {"name": "William Haynes", "pk": 2530}, "edit_page": "/part_type/19/edit"}, "name": "Engineering Accuracy with units", "short_name": "engineering-answer", "description": "<p>A value with units marked right if within an adjustable % error of the correct value. &nbsp;Marked close if within a wider margin of error.</p>", "help_url": "", "input_widget": "string", "input_options": {"correctAnswer": "siground(settings['correctAnswer'],4)", "hint": {"static": true, "value": ""}, "allowEmpty": {"static": true, "value": true}}, "can_be_gap": true, "can_be_step": true, "marking_script": "mark:\nswitch( \n  right and good_units and right_sign, add_credit(1.0,'Correct.'),\n  right and good_units and not right_sign, add_credit(settings['C2'],'Wrong sign.'),\n  right and right_sign and not good_units, add_credit(settings['C2'],'Correct value, but wrong or missing units.'),\n  close and good_units, add_credit(settings['C1'],'Close.'),\n  close and not good_units, add_credit(settings['C3'],'Answer is close, but wrong or missing units.'),\n  incorrect('Wrong answer.')\n)\n\ninterpreted_answer:\nqty(student_scalar, student_units)\n\n\n\ncorrect_quantity:\nsettings[\"correctAnswer\"]\n\n\n\ncorrect_units:\nunits(correct_quantity)\n\n\nallowed_notation_styles:\n[\"plain\",\"en\"]\n\nmatch_student_number:\nmatchnumber(studentAnswer,allowed_notation_styles)\n\nstudent_scalar:\nmatch_student_number[1]\n\nstudent_units:\nreplace_regex('ohms','ohm',\n  replace_regex('\u00b0', ' deg',\n    replace_regex('-', ' ' ,\n      studentAnswer[len(match_student_number[0])..len(studentAnswer)])),\"i\")\n\ngood_units:\ntry(\ncompatible(quantity(1, student_units),correct_units),\nmsg,\nfeedback(msg);false)\n\n\nstudent_quantity:\nswitch(not good_units, \n       student_scalar * correct_units, \n       not right_sign,\n       -quantity(student_scalar, student_units),\n       quantity(student_scalar,student_units)\n)\n  \n\n\npercent_error:\ntry(\nscalar(abs((correct_quantity - student_quantity)/correct_quantity))*100  \n,msg,\nif(student_quantity=correct_quantity,0,100))\n   \n\nright:\npercent_error <= settings['right']\n\n\nclose:\nright_sign and percent_error <= settings['close']\n\nright_sign:\nsign(student_scalar) = sign(correct_quantity)", "marking_notes": [{"name": "mark", "description": "This is the main marking note. It should award credit and provide feedback based on the student's answer.", "definition": "switch( \n  right and good_units and right_sign, add_credit(1.0,'Correct.'),\n  right and good_units and not right_sign, add_credit(settings['C2'],'Wrong sign.'),\n  right and right_sign and not good_units, add_credit(settings['C2'],'Correct value, but wrong or missing units.'),\n  close and good_units, add_credit(settings['C1'],'Close.'),\n  close and not good_units, add_credit(settings['C3'],'Answer is close, but wrong or missing units.'),\n  incorrect('Wrong answer.')\n)"}, {"name": "interpreted_answer", "description": "A value representing the student's answer to this part.", "definition": "qty(student_scalar, student_units)\n\n"}, {"name": "correct_quantity", "description": "", "definition": "settings[\"correctAnswer\"]\n\n"}, {"name": "correct_units", "description": "", "definition": "units(correct_quantity)\n"}, {"name": "allowed_notation_styles", "description": "", "definition": "[\"plain\",\"en\"]"}, {"name": "match_student_number", "description": "", "definition": "matchnumber(studentAnswer,allowed_notation_styles)"}, {"name": "student_scalar", "description": "", "definition": "match_student_number[1]"}, {"name": "student_units", "description": "<p>Modify&nbsp;the&nbsp;unit portion of&nbsp;the student's answer by</p>\n<p>1. replacing \"ohms\" with \"ohm\" &nbsp;case insensitive</p>\n<p>2.&nbsp;replacing '-'&nbsp;with ' '&nbsp;</p>\n<p>3. replacing '&deg;' with ' deg'&nbsp;</p>\n<p>to allow answers like 10 ft-lb and 30&deg;</p>", "definition": "replace_regex('ohms','ohm',\n  replace_regex('\u00b0', ' deg',\n    replace_regex('-', ' ' ,\n      studentAnswer[len(match_student_number[0])..len(studentAnswer)])),\"i\")"}, {"name": "good_units", "description": "", "definition": "try(\ncompatible(quantity(1, student_units),correct_units),\nmsg,\nfeedback(msg);false)\n"}, {"name": "student_quantity", "description": "<p>This fixes the student answer for two common errors. &nbsp;</p>\n<p>If student_units are wrong&nbsp;&nbsp;- replace with correct units</p>\n<p>If student_scalar has the wrong sign - replace with right sign</p>\n<p>If student makes both errors, only one gets fixed.</p>", "definition": "switch(not good_units, \n       student_scalar * correct_units, \n       not right_sign,\n       -quantity(student_scalar, student_units),\n       quantity(student_scalar,student_units)\n)\n  \n"}, {"name": "percent_error", "description": "", "definition": "try(\nscalar(abs((correct_quantity - student_quantity)/correct_quantity))*100  \n,msg,\nif(student_quantity=correct_quantity,0,100))\n   "}, {"name": "right", "description": "", "definition": "percent_error <= settings['right']\n"}, {"name": "close", "description": "<p>Only marked close if the student actually has the right sign.</p>", "definition": "right_sign and percent_error <= settings['close']"}, {"name": "right_sign", "description": "", "definition": "sign(student_scalar) = sign(correct_quantity) "}], "settings": [{"name": "correctAnswer", "label": "Correct Quantity.", "help_url": "", "hint": "The correct answer given as a JME quantity.", "input_type": "code", "default_value": "", "evaluate": true}, {"name": "right", "label": "% Accuracy for right.", "help_url": "", "hint": "Question will be considered correct if the scalar part of the student's answer is within this % of correct value.", "input_type": "code", "default_value": "0.2", "evaluate": true}, {"name": "close", "label": "% Accuracy for close.", "help_url": "", "hint": "Question will be considered close if the scalar part of the student's answer is within this % of correct value.", "input_type": "code", "default_value": "1.0", "evaluate": true}, {"name": "C1", "label": "Close with units.", "help_url": "", "hint": "Partial Credit for close value with appropriate units. &nbsp;if correct answer is 100 N and close is &plusmn;1%,<br />99 &nbsp;N is accepted.", "input_type": "percent", "default_value": "75"}, {"name": "C2", "label": "No units or wrong sign", "help_url": "", "hint": "Partial credit for forgetting units or using wrong sign.<br />If the correct answer is 100 N, both 100 and -100 N are accepted.", "input_type": "percent", "default_value": "50"}, {"name": "C3", "label": "Close, no units.", "help_url": "", "hint": "Partial Credit for close value but forgotten units.<br />This value would be close&nbsp;if the expected units were provided. &nbsp;If the correct answer is 100 N, and close is &plusmn;1%,<br />99 is accepted.", "input_type": "percent", "default_value": "25"}], "public_availability": "always", "published": true, "extensions": ["quantities"]}], "resources": [], "navigation": {"allowregen": true, "showfrontpage": false, "preventleave": false, "typeendtoleave": false}, "contributors": [{"name": "William Haynes", "profile_url": "https://numbas.mathcentre.ac.uk/accounts/profile/2530/"}], "tags": ["Mechanics", "mechanics", "shear and bending moment", "Statics", "statics"], "metadata": {"description": "<p>Shear and bending moment diagram for a beam loaded with an arbitrary parabolic distributed load with a loading function &nbsp;given. &nbsp;Students must integrate to find reactions and equations for shear and bending moment. &nbsp;Problem sometimes fails when simplifying up the equations.</p>", "licence": "Creative Commons Attribution-NonCommercial 4.0 International"}, "statement": "<p>A simply-supported beam of length $L = \\var {qty(L, units[0])}$ is subjected to a parabolic loading $w(x)$ &nbsp;in {units[3]} given by the function:</p>\n<p>\\[w(x) = \\simplify[fractionNumbers,canonicalOrder]{{w}}\\] &nbsp;</p>\n<p>The load, shear and bending moment diagrams are shown below.</p>\n<p>{loadBoard}</p>\n<p>{shearBoard}</p>\n<p>{momentBoard}</p>", "advice": "<p>Given $w(x)$ and beam length $L$,</p>\n<p>\\[ w(x) = \\simplify[fractionNumbers,canonicalOrder]{{w}} \\]</p>\n<p>1. &nbsp;Find load $W= \\int_0^L w(x)\\; dx$</p>\n<p style=\"padding-left: 40px;\">\\[\\begin{align} W &amp; = \\int w(x) \\text{d}x \\\\ &amp; = \\simplify[fractionNumbers,canonicalOrder]{defint({w}, x, 0, {L})} \\\\ &amp;= \\left[\\simplify[fractionNumbers,canonicalOrder]{{intw}}\\right]_0^\\var{L}\\\\ &amp;= \\var{siground(qty(load,units[1]),5)} = \\var{siground(qty(abs(load),units[1]),5)} &nbsp;\\var{arrow(-load)}\\end{align}\\]</p>\n<p>2. &nbsp;Find $Q_y = \\int_0^L x w(x)\\;dx$</p>\n<p style=\"padding-left: 40px;\">\\[\\begin{align} &nbsp;Q_y &amp;= \\int_0^L x\\ w(x) \\text{d}x\\\\&amp;= \\simplify[fractionNumbers,canonicalOrder]{defint({dqy},x,0,L)}\\\\&amp; = \\left[\\simplify[fractionNumbers,canonicalOrder]{{intdqy}} \\right]_0^\\var{L}\\\\ &amp;= \\var{siground(qty(Qy,units[0] + \" \" + units[1]),4)} \\end{align}\\]</p>\n<p>3. &nbsp;Find centroid $\\bar{x}=\\frac{Q_y}{W}$</p>\n<p style=\"padding-left: 40px;\">\\[\\bar{x} = \\dfrac{Q_y}{W} = \\dfrac{\\var{siground(Qy,4)}}{\\var{siground(load,4)}} = \\var{siground(qty(xbar,units[0]),4)}\\]</p>\n<p>4. &nbsp;Take moments about $A$ and $B$ to find reactions.</p>\n<p style=\"padding-left: 40px;\">\\[\\begin{align}<br/>\\sum M_B &amp;= 0 &amp; \\sum M_A &amp;=0 \\\\<br/>&nbsp; R_A L &amp;= &nbsp;\\simplify{{sign(load)} W }(L-\\bar{x}) &amp; + R_B L &amp;= \\simplify{{sign(load)} W }\\bar{x} &amp; &nbsp;\\\\<br/>R_A&amp;= \\var{force(abs(R_A))} \\var{arrow(R_A)} &amp;&nbsp;&nbsp;R_B &amp;= \\var{force(abs(R_B))} \\var{arrow(R_B)} <br/>&nbsp;\\end{align}\\]</p>\n<p>5. &nbsp;Integrate $V(x) = \\int w(x)\\; dx$ to get the shear function.</p>\n<p style=\"padding-left: 40px;\">Note: <em>Positive values of</em> $w(x)$ <em>indicate downward forces, so the integrations is over</em> $-w(x)$.</p>\n<p style=\"padding-left: 40px;\">\\[\\begin{align} V(x) &amp;= \\int - w(x) dx \\\\<br/>&amp;= \\simplify[fractionNumbers, canonicalOrder]{int({-w},x)} \\\\<br/>&amp;= \\simplify[fractionNumbers,canonicalOrder]{{v -v[0]}}+C_3 &nbsp;&amp;&amp; v(0) = R_A &nbsp;\\therefore C_3 = \\var{force(R_A)}<br/>\\\\ &amp;= \\simplify[fractionNumbers,canonicalOrder]{{v}} &amp;&amp; [\\var{units[1]}] &amp;\\end{align}\\]</p>\n<p>6. &nbsp;Integrate $M(x) = \\int V(x)\\; dx$ to get moment function. &nbsp;</p>\n<p style=\"padding-left: 30px;\">\\[\\begin{align}<br/>M(x) &amp;= \\int V(x) dx \\\\<br/>&amp;= \\simplify[fractionNumbers, canonicalOrder]{int({v},x)}\\\\<br/>&amp;= \\simplify[fractionNumbers,canonicalOrder]{{m}}+C_4 &nbsp;&amp;&amp; M(0) =0 &nbsp;\\therefore C_4 = 0 \\\\<br/>&amp;= \\simplify[fractionNumbers,canonicalOrder]{{m}} &amp;&amp; [\\var{units[1]}\\text{-}\\var{units[0]} ]&amp;<br/>\\end{align}\\]</p>\n<p style=\"padding-left: 30px;\"></p>\n<p style=\"padding-left: 30px;\"><span data-jme-visible=\"false\">Maximum moment occurs where $dM/dx = V = 0$</span></p>\n<p style=\"padding-left: 30px;\"><span data-jme-visible=\"false\">Evaluate $M(x)$ at point of maximum bending moment.</span></p>\n<p style=\"padding-left: 30px;\"><span data-jme-visible=\"false\">Maximum shear occurs where $d V&nbsp;/d x = -w(x) = 0$</span></p>\n<p style=\"padding-left: 30px;\"><span data-jme-visible=\"false\">Evaluate $V(x)$ at point of maximum shear.</span></p>\n<p style=\"padding-left: 40px;\"></p>\n<p style=\"padding-left: 40px;\"><span data-jme-visible=\"false\">To find maximum shear, determine where $\\simplify{diff(v,x,1)} = -w(x) = 0$ using the quadratic equation.</span></p>\n<p style=\"padding-left: 40px;\"><span data-jme-visible=\"false\">$x_{max} = &nbsp;\\frac{- b \\pm \\sqrt{b^2 - 4 a c}}{2a}$ where, $a= \\var[fractionNumbers]{-w[2]}, b=\\var[fractionNumbers]{-w[1]}$ and $c=\\var[fractionNumbers]{-w[0]}$.</span></p>\n<p style=\"padding-left: 40px;\"><span data-jme-visible=\"false\">Any real roots of $w(x)$ between the beam's endpoints plus the endpoints themselves are locations of local maximums or minimums.</span></p>\n<p style=\"padding-left: 40px;\"><span data-jme-visible=\"false\">{v_extremes}</span></p>\n<p style=\"padding-left: 40px;\"><span data-jme-visible=\"false\">The maximum of these local maximums is the the one we want</span></p>\n<p style=\"padding-left: 40px;\"><span data-jme-visible=\"false\">$V_{max} = \\var{show(qty(v_max, units[1]))}$</span></p>\n<p style=\"padding-left: 40px;\"></p>\n<p style=\"padding-left: 40px;\"></p>", "rulesets": {}, "builtin_constants": {"e": true, "pi,\u03c0": true, "i": true, "j": false}, "constants": [], "variables": {"L": {"name": "L", "group": "Unnamed group", "definition": "20", "description": "", "templateType": "anything", "can_override": false}, "units": {"name": "units", "group": "Unnamed group", "definition": "random(['ft','lb','ft*lb', 'lb/ft'],['m','kN', 'kN*m', 'kN/m'])", "description": "", "templateType": "anything", "can_override": false}, "w": {"name": "w", "group": "functions", "definition": "polynomial(x,load_coefficients)", "description": "<p>loading function w(x)</p>\n<p></p>", "templateType": "anything", "can_override": false}, "v": {"name": "v", "group": "functions", "definition": "-polynomial(x, [-R_A, w[0], w[1]/2, w[2]/3, w[3]/4])", "description": "<p>This is the shear function V(x) = - \\int w(x) dx</p>\n<p>Constant C is reaction at x=0</p>", "templateType": "anything", "can_override": false}, "m": {"name": "m", "group": "functions", "definition": "polynomial(x,moment_coefficients)", "description": "", "templateType": "anything", "can_override": false}, "load": {"name": "load", "group": "Reactions", "definition": "eval(intW,L) - eval(intW,0)", "description": "<p>downward force on beam = $\\simplify{defint(w,x,0,{beamlen})$</p>\n<p></p>\n<p>Positive = down</p>", "templateType": "anything", "can_override": false}, "dQy": {"name": "dQy", "group": "Reactions", "definition": "polynomial(x) w", "description": "", "templateType": "anything", "can_override": false}, "intdQy": {"name": "intdQy", "group": "Reactions", "definition": "polynomial(x, [0, dQy[0], dQy[1]/2, dQy[2]/3, dQy[3]/4, dQy[4]/5])", "description": "<p>integral of dQy &nbsp;&nbsp;</p>", "templateType": "anything", "can_override": false}, "Qy": {"name": "Qy", "group": "Reactions", "definition": "eval(intdqy,L)", "description": "<p>definite integral of x dw from 0 to L</p>", "templateType": "anything", "can_override": false}, "xBar": {"name": "xBar", "group": "Reactions", "definition": "Qy/load", "description": "", "templateType": "anything", "can_override": false}, "intW": {"name": "intW", "group": "Reactions", "definition": "polynomial(x, [0, w[0], w[1]/2, w[2]/3, w[3]/4])", "description": "", "templateType": "anything", "can_override": false}, "R_B": {"name": "R_B", "group": "Reactions", "definition": "xbar load / L", "description": "<p>reaction at B &nbsp;Positive is up</p>", "templateType": "anything", "can_override": false}, "R_A": {"name": "R_A", "group": "Reactions", "definition": "(L-xbar) load/ L", "description": "", "templateType": "anything", "can_override": false}, "check": {"name": "check", "group": "Reactions", "definition": "withintolerance(R_A+R_B,load,10^10)", "description": "<p>check sometimes has roundoff error.</p>", "templateType": "anything", "can_override": false}, "roots": {"name": "roots", "group": "maxshear", "definition": "sort(\n  if(d>=0, \n    filter(x>=0 and x <=L, x,\n      let([a: w[2], b: w[1], c: w[0]], \n     [(-b + sqrt(d))/(2 a), (-b - sqrt(d))/(2 a)]\n)),[]) + [0,L])", "description": "<p>use quadratic equation to find where w(x) is zero, filter out any roots not on interval, or imaginary.</p>\n<p>The maximum shear will occur at one of these points</p>", "templateType": "anything", "can_override": false}, "d": {"name": "d", "group": "Ungrouped variables", "definition": "w[1]^2 - 4 w[2] * w[0]", "description": "<p>descriminant for quadratic equation w(x)</p>", "templateType": "anything", "can_override": false}, "v_extremes": {"name": "v_extremes", "group": "maxshear", "definition": "map(vector(x,eval(v,x)),x,roots)", "description": "<p>extreme points</p>\n<p>list of shear force v(x) at ends and at roots of w(x) -- potential maximums or minimums</p>", "templateType": "anything", "can_override": false}, "v_max": {"name": "v_max", "group": "functions", "definition": "max([v_maxmin[0],-v_maxmin[1]])", "description": "<p>filters the list of v_extremes to find the one with the greatest absolute value of shear</p>", "templateType": "anything", "can_override": false}, "debug": {"name": "debug", "group": "Ungrouped variables", "definition": "false", "description": "", "templateType": "anything", "can_override": true}, "loadBoard": {"name": "loadBoard", "group": "Ungrouped variables", "definition": "let(max, w_maxmin,\n  jsxgraph(\n    500,250,[-2, max(1.2 max[0],-max[1]/2),  L+2,  min(1.2 max[1], -max[0]/2)],\n    merge(\n    arrows,\n    [\"$w(x)$\": ['functiongraph', [load_function, 0, L], [name: \"a\", withLabel: true, strokeWidth: 3, strokeColor: \"#CC0000\", fillOpacity: 0.1,label:[fixed: false, fontSize: 14]]]],\n    [\"beam\":   ['segment', [[0,0],[L,0]], [strokeWidth: 5, color: \"black\"]] ]\n     \n\n      )\n))\n", "description": "", "templateType": "anything", "can_override": false}, "load_function": {"name": "load_function", "group": "functions", "definition": "expr(w)", "description": "", "templateType": "anything", "can_override": false}, "reactionoptions": {"name": "reactionoptions", "group": "Ungrouped variables", "definition": "[withLabel: true, \"fixed\": true, \"color\": \"#CC0000\", \"strokewidth\": 3, \"highlight\": false, \"lastArrow\": [ \"type\": 4 ] ]", "description": "", "templateType": "anything", "can_override": false}, "drawArrow": {"name": "drawArrow", "group": "Ungrouped variables", "definition": " (x) ->  ['segment', [[x, eval(w,x)],[x,0]],[ fixed: true, color: \"black\",strokewidth: 1.5,highlight: false, lastArrow: [ type: 4 ]]]", "description": "", "templateType": "anything", "can_override": false}, "arrows": {"name": "arrows", "group": "Ungrouped variables", "definition": "dict(map((i)->([(\"A\"+i),drawArrow(i)]), 1..L))", "description": "", "templateType": "anything", "can_override": false}, "w_max": {"name": "w_max", "group": "functions", "definition": "max([abs(r_a),abs(r_b)])", "description": "<p>hack to scale load diagram</p>", "templateType": "anything", "can_override": false}, "w_maxmin": {"name": "w_maxmin", "group": "functions", "definition": "[max(map(x->eval(w,x),0..l)) |> round(), round(min(map(x->eval(w,x),0..l)))]", "description": "", "templateType": "anything", "can_override": false}, "shearBoard": {"name": "shearBoard", "group": "Ungrouped variables", "definition": "\n  jsxgraph(\n    500,250,[-2, 1.2 v_max, L+2, -v_max],\n    [   \n        \"$V(x)$\": ['functiongraph', [shear_function, 0, L], [withLabel: true, strokeWidth: 3, strokeColor: \"#CC0000\", label:[fixed: false, fontSize: 14]]],\n\n    ]\n)", "description": "", "templateType": "anything", "can_override": false}, "shear_function": {"name": "shear_function", "group": "functions", "definition": "expr(v)", "description": "", "templateType": "anything", "can_override": false}, "v_maxmin": {"name": "v_maxmin", "group": "functions", "definition": "[max(map(x->eval(v,x),0..l)) |> round(), round(min(map(x->eval(v,x),0..l)))]", "description": "", "templateType": "anything", "can_override": false}, "moment_function": {"name": "moment_function", "group": "functions", "definition": "expr(m)", "description": "", "templateType": "anything", "can_override": false}, "m_maxmin": {"name": "m_maxmin", "group": "functions", "definition": "[max(map(x->eval(m,x),0..l)) |> round(), round(min(map(x->eval(m,x),0..l)))]", "description": "", "templateType": "anything", "can_override": false}, "m_max": {"name": "m_max", "group": "functions", "definition": "max([m_maxmin[0],-m_maxmin[1]])", "description": "", "templateType": "anything", "can_override": false}, "momentBoard": {"name": "momentBoard", "group": "Ungrouped variables", "definition": "  let(max, m_maxmin[0], min, m_maxmin[1],\n  jsxgraph(\n    500,250,[-2, 1.2 max(1.2 max, -min/2), L+2, min(1.2 min, -max/2)],\n    [\"$M(x)$\": ['functiongraph', [moment_function, 0, L], [withLabel: true, strokeWidth: 3, strokeColor: \"#3070AD\", label:[fixed: false, fontSize: 14] ]],\n ]\n  )  )", "description": "<p>max(1.2 max[0],-max[1]/2)</p>", "templateType": "anything", "can_override": false}, "force": {"name": "force", "group": "Ungrouped variables", "definition": "(f)->siground(qty(f,units[1]),4)", "description": "", "templateType": "anything", "can_override": false}, "load_coefficients": {"name": "load_coefficients", "group": "functions", "definition": "random(coefficients)", "description": "<p>get coefficients puts curve through three points, A,B,C &nbsp;siground tries to make the coefficients simpler fractions</p>", "templateType": "anything", "can_override": false}, "moment_coefficients": {"name": "moment_coefficients", "group": "functions", "definition": "[0,v[0],v[1]/2,v[2]/3,v[3]/4,v[4]/5]", "description": "", "templateType": "anything", "can_override": false}, "shear_coefficients": {"name": "shear_coefficients", "group": "functions", "definition": "[-R_A, w[0], w[1]/2, w[2]/3, w[3]/4]", "description": "", "templateType": "anything", "can_override": false}, "random_frac": {"name": "random_frac", "group": "Ungrouped variables", "definition": "() -> random(-9..9 except 0)/random(1..9)", "description": "", "templateType": "anything", "can_override": false}, "coefficients": {"name": "coefficients", "group": "functions", "definition": "[[ 0, -10, 3, -0.1 ],\n[ 0, -10, 4, -0.1 ],\n[ 0, -10, 4, -0.1 ],\n[ 0, -10, 4, -0.2 ],\n[ 0, -20, 4, -0.2 ],\n[ 0, -20, 5, -0.2 ],\n[ 0, -3, 0.3, -0.006 ],\n[ 0, -4, 0.04, 0.009 ],\n[ 0, -4, 0.07, 0.006 ],\n[ 0, -4, 0.3, -0.007 ],\n[ 0, -4, 0.4, -0.008 ],\n[ 0, -5, 0.5, -0.01 ],\n[ 0, -5, 0.6, -0.02 ],\n[ 0, -5, 0.7, -0.02 ],\n[ 0, -6, 0.5, -0.01 ],\n[ 0, -6, 0.8, -0.03 ],\n[ 0, -7, 0.9, -0.03 ],\n[ 0, -8, 1, -0.03 ],\n[ 0, -8, 1, -0.04 ],\n[ 0, -9, 1, -0.04 ],\n[ 0, 2, -0.04, -0.004 ],\n[ 0, 2, -0.05, -0.004 ],\n[ 0, 2, -0.1, 0 ],\n[ 0, 20, -5, 0.2 ],\n[ 0, 3, -0.03, -0.007 ],\n[ 0, 3, -0.05, -0.005 ],\n[ 0, 3, -0.1, 0 ],\n[ 0, 3, -0.3, 0.006 ],\n[ 0, 4, -0.03, -0.007 ],\n[ 0, 4, -0.04, -0.008 ],\n[ 0, 4, -0.04, -0.009 ],\n[ 0, 4, -0.07, -0.006 ],\n[ 0, 4, -0.2, 0 ],\n[ 0, 5, -0.05, -0.01 ],\n[ 0, 5, -0.7, 0.02 ],\n[ 0, 6, -0.05, -0.01 ],\n[ 0, 6, -0.06, -0.01 ],\n[ 0, 6, -0.8, 0.03 ],\n[ 0, 8, -1, 0.03 ],\n[ 0, -3, 0.3, -0.007 ]]", "description": "<p>These coefficients do not cause \"Simplifier is stuck in a loop\" errors. &nbsp;The were generated by giving three random points to getCoefficients() extension function</p>", "templateType": "anything", "can_override": false}}, "variablesTest": {"condition": "", "maxRuns": 100}, "ungrouped_variables": ["d", "debug", "loadBoard", "shearBoard", "momentBoard", "reactionoptions", "drawArrow", "arrows", "force", "random_frac"], "variable_groups": [{"name": "Unnamed group", "variables": ["L", "units"]}, {"name": "functions", "variables": ["w", "v", "m", "coefficients", "load_coefficients", "shear_coefficients", "moment_coefficients", "load_function", "shear_function", "moment_function", "w_maxmin", "v_maxmin", "m_maxmin", "w_max", "v_max", "m_max"]}, {"name": "Reactions", "variables": ["load", "dQy", "intdQy", "Qy", "xBar", "intW", "R_B", "R_A", "check"]}, {"name": "maxshear", "variables": ["roots", "v_extremes"]}], "functions": {"arrow": {"parameters": [["F", "?"]], "type": "anything", "language": "jme", "definition": "if(sign(F) >= 0 ,latex(\"\\\\uparrow\"), latex(\"\\\\downarrow\"))"}, "getCoefficients": {"parameters": [["A", "list of integer"], ["B", "list of integer"], ["C", "list of integer"]], "type": "list", "language": "javascript", "definition": "    const jme = Numbas.jme;\n    const extension = Numbas.extensions.polynomial\n    const [x0, y1] = A;\n    const [x2, y2] = B;\n    const [x3, y3] = C;\n\n    // Sanity check: first point must be at x=0\n    if (x0 !== 0) {\n        throw new Error(\"First point A must have x = 0\");\n    }\n\n    const d = y1;\n\n    // Right-hand side: subtract y1 to isolate a,b,c terms\n    const r1 = y2 - y1;\n    const r2 = y3 - y1;\n\n    // Matrix coefficients\n    const a11 = Math.pow(x2, 3);\n    const a12 = Math.pow(x2, 2);\n    const a13 = x2;\n\n    const a21 = Math.pow(x3, 3);\n    const a22 = Math.pow(x3, 2);\n    const a23 = x3;\n\n    // Solve the system using Cramer's Rule or elimination\n    // We'll eliminate c first\n\n    // Multiply row 1 by x3 and row 2 by x2 to align c terms\n    const m1 = x3, m2 = x2;\n\n    const A1 = m1 * a11 - m2 * a21;\n    const B1 = m1 * a12 - m2 * a22;\n    const R1 = m1 * r1 - m2 * r2;\n\n    // Now solve A1 * a + B1 * b = R1\n    // We'll solve for b in terms of a, then back-substitute\n\n    // Solve for a and b\n    // System: A1 * a + B1 * b = R1\n    //         a13 * a + a12 * b + c = r1\n\n    // Choose to solve directly (2x2 linear system)\n    const det = A1 * (-a12) - B1 * (-a13);\n    if (Math.abs(det) < 1e-12) {\n        throw new Error(\"Points are degenerate or lead to singular system.\");\n    }\n\n    // Use Cramer's Rule\n    const detA = R1 * (-a12) - B1 * (r1 - a13 * 0); // assuming a = 0 temporarily\n    const detB = A1 * (r1 - a13 * 0) - R1 * (-a13);\n\n    const a = detA / det;\n    const b = detB / det;\n\n    // Solve for c using first equation\n    const c = (r1 - a * a11 - b * a12) / a13;\n\n    // Return function  a * x ** 3 + b * x ** 2 + c * x + d;\n    return [d,c,b,a]\n    \n"}, "show": {"parameters": [["A", "number"]], "type": "anything", "language": "jme", "definition": "if(abs(if(type(A)=type(qty(1,'m')),scalar(A),A))<1,\n  precround(A,4),siground(A,4))"}}, "preamble": {"js": "question.signals.on('adviceDisplayed',function() {\n   try{\n   }\n  catch(err){}  \n})\n\n\n", "css": ""}, "parts": [{"type": "gapfill", "useCustomName": true, "customName": "Reactions", "marks": 0, "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": true, "showFeedbackIcon": true, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "prompt": "<p>Find the reactions at the end suppports. &nbsp;Use negative values to indicate downward forces.</p>\n<p>$R_A = $ [[0]]</p>\n<p>$ R_B= $ [[1]]</p>", "gaps": [{"type": "engineering-answer", "useCustomName": true, "customName": "A", "marks": "10", "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": true, "showFeedbackIcon": true, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "settings": {"correctAnswer": "qty(R_A,units[1])", "right": "0.2", "close": "1.0", "C1": "75", "C2": "50", "C3": "25"}}, {"type": "engineering-answer", "useCustomName": true, "customName": "B", "marks": "10", "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": true, "showFeedbackIcon": true, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "settings": {"correctAnswer": "qty(R_B,units[1])", "right": "0.2", "close": "1.0", "C1": "75", "C2": "50", "C3": "25"}}], "sortAnswers": false}, {"type": "gapfill", "useCustomName": true, "customName": "Shear Function", "marks": 0, "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": true, "showFeedbackIcon": true, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "prompt": "<p>Use integration to determine the equation of the shear function $V (x) = \\int -w(x)\\ dx$</p>\n<p><span data-jme-visible=\"debug\">$V\\!(x) = \\simplify[fractionNumbers,canonicalOrder]{{v}} = &nbsp;\\simplify[canonicalOrder]{{v}} $</span></p>\n<p>$V\\!(x) = $[[0]]</p>", "gaps": [{"type": "jme", "useCustomName": true, "customName": "$V(x)$", "marks": "10", "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": true, "showFeedbackIcon": true, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "answer": "{expr(v)}", "answerSimplification": "fractionNumbers,canonicalOrder", "showPreview": true, "checkingType": "sigfig", "checkingAccuracy": "2", "failureRate": 1, "vsetRangePoints": 5, "vsetRange": [0, "1"], "checkVariableNames": false, "singleLetterVariables": false, "allowUnknownFunctions": true, "implicitFunctionComposition": false, "caseSensitive": false, "valuegenerators": []}], "sortAnswers": false}, {"type": "gapfill", "useCustomName": true, "customName": "Bending Moment", "marks": 0, "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": true, "showFeedbackIcon": true, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "prompt": "<p>Use integration to find the bending moment function $M(x) =\\int V(x)\\ dx$.</p>\n<p><span data-jme-visible=\"debug\">$M(x) = \\simplify[fractionNumbers,canonicalOrder]{{m}}$&nbsp;<br/></span></p>\n<p><span data-jme-visible=\"debug\">$=\\simplify[canonicalOrder]{{m}}$</span></p>\n<p>$M(x) = $ [[0]]</p>", "gaps": [{"type": "jme", "useCustomName": true, "customName": "$M(x)$", "marks": "10", "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": true, "showFeedbackIcon": true, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "answer": "{expr(m)}", "answerSimplification": "fractionNumbers,canonicalOrder", "showPreview": true, "checkingType": "sigfig", "checkingAccuracy": "2", "failureRate": 1, "vsetRangePoints": 5, "vsetRange": [0, 1], "checkVariableNames": false, "singleLetterVariables": false, "allowUnknownFunctions": true, "implicitFunctionComposition": false, "caseSensitive": false, "valuegenerators": []}], "sortAnswers": false}], "partsMode": "all", "maxMarks": 0, "objectives": [], "penalties": [], "objectiveVisibility": "always", "penaltyVisibility": "always"}]}], "allowPrinting": true, "navigation": {"allowregen": true, "reverse": true, "browse": true, "allowsteps": true, "showfrontpage": false, "navigatemode": "menu", "onleave": {"action": "none", "message": ""}, "preventleave": false, "typeendtoleave": false, "startpassword": "", "autoSubmit": true, "allowAttemptDownload": false, "downloadEncryptionKey": "", "showresultspage": "oncompletion"}, "timing": {"allowPause": true, "timeout": {"action": "none", "message": ""}, "timedwarning": {"action": "none", "message": ""}}, "feedback": {"enterreviewmodeimmediately": true, "showactualmarkwhen": "always", "showtotalmarkwhen": "always", "showanswerstatewhen": "always", "showpartfeedbackmessageswhen": "always", "showexpectedanswerswhen": "inreview", "showadvicewhen": "inreview", "allowrevealanswer": true, "intro": "", "end_message": "", "results_options": {"printquestions": true, "printadvice": true}, "feedbackmessages": [], "reviewshowexpectedanswer": true, "showanswerstate": true, "reviewshowfeedback": true, "showactualmark": true, "showtotalmark": true, "reviewshowscore": true, "reviewshowadvice": true}, "diagnostic": {"knowledge_graph": {"topics": [], "learning_objectives": []}, "script": "diagnosys", "customScript": ""}, "contributors": [{"name": "William Haynes", "profile_url": "https://numbas.mathcentre.ac.uk/accounts/profile/2530/"}], "extensions": ["geogebra", "jsxgraph", "linear-algebra", "polynomials", "quantities", "shear-and-bending-moment-diagrams"], "custom_part_types": [{"source": {"pk": 19, "author": {"name": "William Haynes", "pk": 2530}, "edit_page": "/part_type/19/edit"}, "name": "Engineering Accuracy with units", "short_name": "engineering-answer", "description": "<p>A value with units marked right if within an adjustable % error of the correct value. &nbsp;Marked close if within a wider margin of error.</p>", "help_url": "", "input_widget": "string", "input_options": {"correctAnswer": "siground(settings['correctAnswer'],4)", "hint": {"static": true, "value": ""}, "allowEmpty": {"static": true, "value": true}}, "can_be_gap": true, "can_be_step": true, "marking_script": "mark:\nswitch( \n  right and good_units and right_sign, add_credit(1.0,'Correct.'),\n  right and good_units and not right_sign, add_credit(settings['C2'],'Wrong sign.'),\n  right and right_sign and not good_units, add_credit(settings['C2'],'Correct value, but wrong or missing units.'),\n  close and good_units, add_credit(settings['C1'],'Close.'),\n  close and not good_units, add_credit(settings['C3'],'Answer is close, but wrong or missing units.'),\n  incorrect('Wrong answer.')\n)\n\ninterpreted_answer:\nqty(student_scalar, student_units)\n\n\n\ncorrect_quantity:\nsettings[\"correctAnswer\"]\n\n\n\ncorrect_units:\nunits(correct_quantity)\n\n\nallowed_notation_styles:\n[\"plain\",\"en\"]\n\nmatch_student_number:\nmatchnumber(studentAnswer,allowed_notation_styles)\n\nstudent_scalar:\nmatch_student_number[1]\n\nstudent_units:\nreplace_regex('ohms','ohm',\n  replace_regex('\u00b0', ' deg',\n    replace_regex('-', ' ' ,\n      studentAnswer[len(match_student_number[0])..len(studentAnswer)])),\"i\")\n\ngood_units:\ntry(\ncompatible(quantity(1, student_units),correct_units),\nmsg,\nfeedback(msg);false)\n\n\nstudent_quantity:\nswitch(not good_units, \n       student_scalar * correct_units, \n       not right_sign,\n       -quantity(student_scalar, student_units),\n       quantity(student_scalar,student_units)\n)\n  \n\n\npercent_error:\ntry(\nscalar(abs((correct_quantity - student_quantity)/correct_quantity))*100  \n,msg,\nif(student_quantity=correct_quantity,0,100))\n   \n\nright:\npercent_error <= settings['right']\n\n\nclose:\nright_sign and percent_error <= settings['close']\n\nright_sign:\nsign(student_scalar) = sign(correct_quantity)", "marking_notes": [{"name": "mark", "description": "This is the main marking note. It should award credit and provide feedback based on the student's answer.", "definition": "switch( \n  right and good_units and right_sign, add_credit(1.0,'Correct.'),\n  right and good_units and not right_sign, add_credit(settings['C2'],'Wrong sign.'),\n  right and right_sign and not good_units, add_credit(settings['C2'],'Correct value, but wrong or missing units.'),\n  close and good_units, add_credit(settings['C1'],'Close.'),\n  close and not good_units, add_credit(settings['C3'],'Answer is close, but wrong or missing units.'),\n  incorrect('Wrong answer.')\n)"}, {"name": "interpreted_answer", "description": "A value representing the student's answer to this part.", "definition": "qty(student_scalar, student_units)\n\n"}, {"name": "correct_quantity", "description": "", "definition": "settings[\"correctAnswer\"]\n\n"}, {"name": "correct_units", "description": "", "definition": "units(correct_quantity)\n"}, {"name": "allowed_notation_styles", "description": "", "definition": "[\"plain\",\"en\"]"}, {"name": "match_student_number", "description": "", "definition": "matchnumber(studentAnswer,allowed_notation_styles)"}, {"name": "student_scalar", "description": "", "definition": "match_student_number[1]"}, {"name": "student_units", "description": "<p>Modify&nbsp;the&nbsp;unit portion of&nbsp;the student's answer by</p>\n<p>1. replacing \"ohms\" with \"ohm\" &nbsp;case insensitive</p>\n<p>2.&nbsp;replacing '-'&nbsp;with ' '&nbsp;</p>\n<p>3. replacing '&deg;' with ' deg'&nbsp;</p>\n<p>to allow answers like 10 ft-lb and 30&deg;</p>", "definition": "replace_regex('ohms','ohm',\n  replace_regex('\u00b0', ' deg',\n    replace_regex('-', ' ' ,\n      studentAnswer[len(match_student_number[0])..len(studentAnswer)])),\"i\")"}, {"name": "good_units", "description": "", "definition": "try(\ncompatible(quantity(1, student_units),correct_units),\nmsg,\nfeedback(msg);false)\n"}, {"name": "student_quantity", "description": "<p>This fixes the student answer for two common errors. &nbsp;</p>\n<p>If student_units are wrong&nbsp;&nbsp;- replace with correct units</p>\n<p>If student_scalar has the wrong sign - replace with right sign</p>\n<p>If student makes both errors, only one gets fixed.</p>", "definition": "switch(not good_units, \n       student_scalar * correct_units, \n       not right_sign,\n       -quantity(student_scalar, student_units),\n       quantity(student_scalar,student_units)\n)\n  \n"}, {"name": "percent_error", "description": "", "definition": "try(\nscalar(abs((correct_quantity - student_quantity)/correct_quantity))*100  \n,msg,\nif(student_quantity=correct_quantity,0,100))\n   "}, {"name": "right", "description": "", "definition": "percent_error <= settings['right']\n"}, {"name": "close", "description": "<p>Only marked close if the student actually has the right sign.</p>", "definition": "right_sign and percent_error <= settings['close']"}, {"name": "right_sign", "description": "", "definition": "sign(student_scalar) = sign(correct_quantity) "}], "settings": [{"name": "correctAnswer", "label": "Correct Quantity.", "help_url": "", "hint": "The correct answer given as a JME quantity.", "input_type": "code", "default_value": "", "evaluate": true}, {"name": "right", "label": "% Accuracy for right.", "help_url": "", "hint": "Question will be considered correct if the scalar part of the student's answer is within this % of correct value.", "input_type": "code", "default_value": "0.2", "evaluate": true}, {"name": "close", "label": "% Accuracy for close.", "help_url": "", "hint": "Question will be considered close if the scalar part of the student's answer is within this % of correct value.", "input_type": "code", "default_value": "1.0", "evaluate": true}, {"name": "C1", "label": "Close with units.", "help_url": "", "hint": "Partial Credit for close value with appropriate units. &nbsp;if correct answer is 100 N and close is &plusmn;1%,<br />99 &nbsp;N is accepted.", "input_type": "percent", "default_value": "75"}, {"name": "C2", "label": "No units or wrong sign", "help_url": "", "hint": "Partial credit for forgetting units or using wrong sign.<br />If the correct answer is 100 N, both 100 and -100 N are accepted.", "input_type": "percent", "default_value": "50"}, {"name": "C3", "label": "Close, no units.", "help_url": "", "hint": "Partial Credit for close value but forgotten units.<br />This value would be close&nbsp;if the expected units were provided. &nbsp;If the correct answer is 100 N, and close is &plusmn;1%,<br />99 is accepted.", "input_type": "percent", "default_value": "25"}], "public_availability": "always", "published": true, "extensions": ["quantities"]}], "resources": [["question-resources/newVM_cA1Sig0.ggb", "/srv/numbas/media/question-resources/newVM_cA1Sig0.ggb"], ["question-resources/FBDS.svg", "/srv/numbas/media/question-resources/FBDS_H6jeTl8.svg"]]}