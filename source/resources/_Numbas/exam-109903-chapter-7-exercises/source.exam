// Numbas version: finer_feedback_settings
{"name": "Chapter 7 Exercises", "metadata": {"description": "<p>End of chapter exercises for <a href=\"http://engineeringstatics.org\"><em>Engineering Statics: Open and Interactive</em></a>&nbsp;</p>", "licence": "Creative Commons Attribution-NonCommercial 4.0 International"}, "duration": 0, "percentPass": 0, "showQuestionGroupNames": true, "shuffleQuestionGroups": false, "showstudentname": true, "question_groups": [{"name": "Centroids by Composite Area", "pickingStrategy": "all-ordered", "pickQuestions": 1, "questionNames": ["", "Shape with Hole", "Rectangles and Triangles"], "variable_overrides": [[], [], []], "questions": [{"name": "Centroid of parts", "extensions": ["geogebra", "quantities", "sheets"], "custom_part_types": [{"source": {"pk": 242, "author": {"name": "Christian Lawson-Perfect", "pk": 7}, "edit_page": "/part_type/242/edit"}, "name": "Spreadsheet", "short_name": "spreadsheet", "description": "<p>An editable spreadsheet. Ranges of cells can be disabled, and you can specify ranges of cells to be marked. A cell is marked correct if its value is equal to the value in the expected answer spreadsheet.</p>", "help_url": "", "input_widget": "spread-sheet", "input_options": {"correctAnswer": "settings[\"correct_answer\"]", "hint": {"static": true, "value": ""}, "initial_sheet": {"static": false, "value": "disable_cells(settings[\"initial_sheet\"], settings[\"disable_ranges\"])"}}, "can_be_gap": true, "can_be_step": true, "marking_script": "mark:\nif(sum(mark_ranges)=0,\n  incorrect(),\n  apply(mark_ranges)\n)\n\ninterpreted_answer:\nstudentAnswer\n\nrange_cells:\nmap(parse_range(ref),ref,values(settings[\"mark_ranges\"]))\n\ntotal_cells:\nlen(flatten(range_cells))\n\nrange_weights:\nswitch(\n  settings[\"marking_method\"]=\"per_cell\",\n    map(len(r)/total_cells, r, range_cells),\n  // otherwise, mark per range\n    repeat(1/len(range_cells), len(range_cells))\n)\n\nmark_ranges:\nmap(\n  let(\n    range_credit,\n      sum(map(\n        let(\n          correctCellString, correctAnswer[c],\n          correctCellNumber, parsenumber(correctCellString, notation_styles),\n          studentCellString, studentAnswer[c],\n          studentCellNumber, parsenumber(studentCellString, notation_styles),\n          award(\n            1/len(cells), \n            switch(\n              correctCellString=\"\",\n                isnan(studentCellNumber) or studentCellString=\"\",\n              isnan(correctCellNumber),\n                lower(correctCellString) = lower(studentCellString)\n              ,\n                abs(studentCellNumber - if(isnan(correctCellNumber),0,correctCellNumber)) <= settings[\"tolerance\"]\n            )\n          )\n        ),\n        c,\n        cells\n      )),\n    message,\n      switch(\n        range_credit=0,\n          if(len(cells)=1, \"This entry is incorrect.\", \"All entries in this range are incorrect.\"),\n        range_credit=1,\n          if(len(cells)=1, \"This entry is correct.\", \"All entries in this range are correct.\"),\n        //otherwise\n          \"Some entries in this range are correct.\"\n      ),\n    assert(len(cells)=0, add_credit(range_credit*w, \"<strong>{name}:</strong> \"+message)); \n    range_credit\n  ),\n  [cells,w,name],\n  zip(range_cells, range_weights, keys(settings[\"mark_ranges\"]))\n)\n\nnotation_styles:\n[\"plain\",\"si-en\"]\n\ncorrectAnswer:\nsettings[\"correct_answer\"]", "marking_notes": [{"name": "mark", "description": "This is the main marking note. It should award credit and provide feedback based on the student's answer.", "definition": "if(sum(mark_ranges)=0,\n  incorrect(),\n  apply(mark_ranges)\n)"}, {"name": "interpreted_answer", "description": "A value representing the student's answer to this part.", "definition": "studentAnswer"}, {"name": "range_cells", "description": "<p>For each range to be marked, the addresses of the cells in that range.</p>", "definition": "map(parse_range(ref),ref,values(settings[\"mark_ranges\"]))"}, {"name": "total_cells", "description": "<p>The total number of cells to be marked. Cells in overlapping ranges will be counted once for each range they're in.</p>", "definition": "len(flatten(range_cells))"}, {"name": "range_weights", "description": "<p>The weight of each range, as a proportion of the available credit.</p>", "definition": "switch(\n  settings[\"marking_method\"]=\"per_cell\",\n    map(len(r)/total_cells, r, range_cells),\n  // otherwise, mark per range\n    repeat(1/len(range_cells), len(range_cells))\n)"}, {"name": "mark_ranges", "description": "<p>Mark each of the ranges specified by the question author.</p>", "definition": "map(\n  let(\n    range_credit,\n      sum(map(\n        let(\n          correctCellString, correctAnswer[c],\n          correctCellNumber, parsenumber(correctCellString, notation_styles),\n          studentCellString, studentAnswer[c],\n          studentCellNumber, parsenumber(studentCellString, notation_styles),\n          award(\n            1/len(cells), \n            switch(\n              correctCellString=\"\",\n                isnan(studentCellNumber) or studentCellString=\"\",\n              isnan(correctCellNumber),\n                lower(correctCellString) = lower(studentCellString)\n              ,\n                abs(studentCellNumber - if(isnan(correctCellNumber),0,correctCellNumber)) <= settings[\"tolerance\"]\n            )\n          )\n        ),\n        c,\n        cells\n      )),\n    message,\n      switch(\n        range_credit=0,\n          if(len(cells)=1, \"This entry is incorrect.\", \"All entries in this range are incorrect.\"),\n        range_credit=1,\n          if(len(cells)=1, \"This entry is correct.\", \"All entries in this range are correct.\"),\n        //otherwise\n          \"Some entries in this range are correct.\"\n      ),\n    assert(len(cells)=0, add_credit(range_credit*w, \"<strong>{name}:</strong> \"+message)); \n    range_credit\n  ),\n  [cells,w,name],\n  zip(range_cells, range_weights, keys(settings[\"mark_ranges\"]))\n)"}, {"name": "notation_styles", "description": "<p>Accepted number notation styles for a value in an individual cell.</p>", "definition": "[\"plain\",\"si-en\"]"}, {"name": "correctAnswer", "description": "", "definition": "settings[\"correct_answer\"]"}], "settings": [{"name": "initial_sheet", "label": "Initial sheet", "help_url": "", "hint": "A <code>spreadsheet</code> object giving the initial state of the sheet that the student should fill in.", "input_type": "code", "default_value": "", "evaluate": true}, {"name": "correct_answer", "label": "Correct answer", "help_url": "", "hint": "A <code>spreadsheet</code> object representing a correct answer to the part.", "input_type": "code", "default_value": "", "evaluate": true}, {"name": "disable_ranges", "label": "Ranges to disable", "help_url": "", "hint": "A list of cell or range references, denoting the cells that should not be editable.", "input_type": "code", "default_value": "[]", "evaluate": true}, {"name": "mark_ranges", "label": "Ranges to mark", "help_url": "", "hint": "A dictionary of cell or range references, mapping names to ranges of cells, denoting the cells that should be compared for equality with the expected answer.", "input_type": "code", "default_value": "dict()", "evaluate": true}, {"name": "marking_method", "label": "Marking method", "help_url": "", "hint": "", "input_type": "dropdown", "default_value": "per_cell", "choices": [{"value": "per_cell", "label": "Each cell has the same weight"}, {"value": "per_range", "label": "Each range has the same weight"}]}, {"name": "tolerance", "label": "Allowed margin of error", "help_url": "", "hint": "", "input_type": "code", "default_value": "0", "evaluate": true}], "public_availability": "always", "published": true, "extensions": ["sheets"]}], "resources": ["question-resources/centroids.png", "question-resources/centroids_3A0rXlj.png", "question-resources/centroids_zSOgoBb.png"], "navigation": {"allowregen": true, "showfrontpage": false, "preventleave": false, "typeendtoleave": false}, "contributors": [{"name": "William Haynes", "profile_url": "https://numbas.mathcentre.ac.uk/accounts/profile/2530/"}], "tags": [], "metadata": {"description": "<p>Locate the centroid of a rectangle, triangle, and semi-circle on a coordinate grid.</p>", "licence": "Creative Commons Attribution-NonCommercial 4.0 International"}, "statement": "<p>Fill the table with the coordinates of the centroids of the three shapes. &nbsp;Grid units are $[\\var{units}]$.</p>\n<table style=\"margin-left: auto; margin-right: auto; width: 16px;\">\n<tbody>\n<tr>\n<td style=\"width: 0px;\">{applet}</td>\n</tr>\n</tbody>\n</table>\n<p></p>\n<p><span data-jme-visible=\"debug\">{answer_table}</span></p>", "advice": "<p>For a rectangle, the centroid is at the geometric center.</p>\n<p>For a right triangle, divide the base and height into thirds. &nbsp;The centroid is located at the intersection point nearest to the right angle.</p>\n<p>For a semicircle, the centroid is located on the axis of symmetry, a distance of $\\frac{4r}{3\\pi}$ from the straight edge.</p>\n<p></p>\n<p><img src=\"resources/question-resources/centroids_zSOgoBb.png\" width=\"778\" height=\"250\"/></p>", "rulesets": {}, "builtin_constants": {"e": true, "pi,\u03c0": true, "i": true, "j": false}, "constants": [], "variables": {"CC": {"name": "CC", "group": "Ungrouped variables", "definition": "C1 + (C2-C1) 4 / 3 / 3.14159", "description": "", "templateType": "anything", "can_override": false}, "C2": {"name": "C2", "group": "inputs", "definition": "random(\n  vector(C1[0],c1[1]+random(-6..6)),\n  vector(C1[0]+random(-6..6),C1[1]))\n  \n  \n  \n  ", "description": "", "templateType": "anything", "can_override": false}, "TC": {"name": "TC", "group": "Ungrouped variables", "definition": "T1 + (T2-T1)/3", "description": "", "templateType": "anything", "can_override": false}, "T1": {"name": "T1", "group": "inputs", "definition": "vector(random(-10..10),random(-8..8))", "description": "", "templateType": "anything", "can_override": false}, "T2": {"name": "T2", "group": "inputs", "definition": "vector(random(-10..10),random(-8..8))", "description": "", "templateType": "anything", "can_override": false}, "C1": {"name": "C1", "group": "inputs", "definition": "vector(random(-10..10),random(-8..8))\n", "description": "", "templateType": "anything", "can_override": false}, "debug": {"name": "debug", "group": "Ungrouped variables", "definition": "false", "description": "", "templateType": "anything", "can_override": false}, "R1": {"name": "R1", "group": "inputs", "definition": "vector(random(-10..10),random(-8..8))", "description": "", "templateType": "anything", "can_override": false}, "R2": {"name": "R2", "group": "inputs", "definition": "vector(random(-10..10),random(-8..8))", "description": "", "templateType": "anything", "can_override": false}, "units": {"name": "units", "group": "Ungrouped variables", "definition": "random('in','cm','mm','ft')", "description": "", "templateType": "anything", "can_override": false}, "RC": {"name": "RC", "group": "Ungrouped variables", "definition": "R1 + (R2-R1)/2", "description": "", "templateType": "anything", "can_override": false}, "centroid_table": {"name": "centroid_table", "group": "Ungrouped variables", "definition": "spreadsheet_from_base64_file(safe(\"centroid_table-2.xlsx\"), safe(\"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\"))", "description": "", "templateType": "spreadsheet", "can_override": false}, "answer_table": {"name": "answer_table", "group": "Ungrouped variables", "definition": "fill_range(centroid_table,\"B2:C4\", [dist(RC),dist(TC),dist(CC)])", "description": "<p>table filled with centroid coordinates</p>", "templateType": "anything", "can_override": false}, "dist": {"name": "dist", "group": "Ungrouped variables", "definition": "//(V) -> [siground(qty(V[0], units),3),siground(qty(V[1], units),3)]\n(V) -> [siground(V[0],3),siground(V[1],3)]", "description": "<p>input vector, output rounded vector of quantities</p>", "templateType": "anything", "can_override": false}, "params": {"name": "params", "group": "inputs", "definition": "[['R_1',R1],['R_2',R2],['T_1',T1],['T_2',T2],['C_1',C1],['C_2',C2]]", "description": "", "templateType": "anything", "can_override": false}, "applet": {"name": "applet", "group": "inputs", "definition": "geogebra_applet('xjjm7qqr',params)", "description": "", "templateType": "anything", "can_override": false}}, "variablesTest": {"condition": "(R1-R2)[0] >= 2 and (R1-R2)[1] >= 2 and  \n(T1-T2)[0] >= 2 and (T1-T2)[1] >= 2 and \nC1<>C2 and abs(C1-C2) > 2\n\n", "maxRuns": "200"}, "ungrouped_variables": ["units", "RC", "TC", "CC", "debug", "centroid_table", "answer_table", "dist"], "variable_groups": [{"name": "inputs", "variables": ["R1", "R2", "T1", "T2", "C1", "C2", "params", "applet"]}], "functions": {}, "preamble": {"js": "", "css": ""}, "parts": [{"type": "spreadsheet", "useCustomName": false, "customName": "", "marks": "30", "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": true, "showFeedbackIcon": true, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "prompt": "<p>Don't include units in table values.</p>", "settings": {"initial_sheet": "centroid_table", "correct_answer": "answer_table", "disable_ranges": "[\"A1:C1\", \"A1:A4\"]", "mark_ranges": "[\"Rectangle\": \"B2:C2\", \"Triangle\": \"B3:C3\", \"Circle\": \"B4:C4\"]", "marking_method": "per_cell", "tolerance": "0.1"}}], "partsMode": "all", "maxMarks": 0, "objectives": [], "penalties": [], "objectiveVisibility": "always", "penaltyVisibility": "always"}, {"name": "Centroid of a composite area: shape with hole", "extensions": ["geogebra", "quantities", "sheets"], "custom_part_types": [{"source": {"pk": 19, "author": {"name": "William Haynes", "pk": 2530}, "edit_page": "/part_type/19/edit"}, "name": "Engineering Accuracy with units", "short_name": "engineering-answer", "description": "<p>A value with units marked right if within an adjustable % error of the correct value. &nbsp;Marked close if within a wider margin of error.</p>", "help_url": "", "input_widget": "string", "input_options": {"correctAnswer": "siground(settings['correctAnswer'],4)", "hint": {"static": true, "value": ""}, "allowEmpty": {"static": true, "value": true}}, "can_be_gap": true, "can_be_step": true, "marking_script": "mark:\nswitch( \n  right and good_units and right_sign, add_credit(1.0,'Correct.'),\n  right and good_units and not right_sign, add_credit(settings['C2'],'Wrong sign.'),\n  right and right_sign and not good_units, add_credit(settings['C2'],'Correct value, but wrong or missing units.'),\n  close and good_units, add_credit(settings['C1'],'Close.'),\n  close and not good_units, add_credit(settings['C3'],'Answer is close, but wrong or missing units.'),\n  incorrect('Wrong answer.')\n)\n\ninterpreted_answer:\nqty(student_scalar, student_units)\n\n\n\ncorrect_quantity:\nsettings[\"correctAnswer\"]\n\n\n\ncorrect_units:\nunits(correct_quantity)\n\n\nallowed_notation_styles:\n[\"plain\",\"en\"]\n\nmatch_student_number:\nmatchnumber(studentAnswer,allowed_notation_styles)\n\nstudent_scalar:\nmatch_student_number[1]\n\nstudent_units:\nreplace_regex('ohms','ohm',\n  replace_regex('\u00b0', ' deg',\n    replace_regex('-', ' ' ,\n      studentAnswer[len(match_student_number[0])..len(studentAnswer)])),\"i\")\n\ngood_units:\ntry(\ncompatible(quantity(1, student_units),correct_units),\nmsg,\nfeedback(msg);false)\n\n\nstudent_quantity:\nswitch(not good_units, \n       student_scalar * correct_units, \n       not right_sign,\n       -quantity(student_scalar, student_units),\n       quantity(student_scalar,student_units)\n)\n  \n\n\npercent_error:\ntry(\nscalar(abs((correct_quantity - student_quantity)/correct_quantity))*100  \n,msg,\nif(student_quantity=correct_quantity,0,100))\n   \n\nright:\npercent_error <= settings['right']\n\n\nclose:\nright_sign and percent_error <= settings['close']\n\nright_sign:\nsign(student_scalar) = sign(correct_quantity)", "marking_notes": [{"name": "mark", "description": "This is the main marking note. It should award credit and provide feedback based on the student's answer.", "definition": "switch( \n  right and good_units and right_sign, add_credit(1.0,'Correct.'),\n  right and good_units and not right_sign, add_credit(settings['C2'],'Wrong sign.'),\n  right and right_sign and not good_units, add_credit(settings['C2'],'Correct value, but wrong or missing units.'),\n  close and good_units, add_credit(settings['C1'],'Close.'),\n  close and not good_units, add_credit(settings['C3'],'Answer is close, but wrong or missing units.'),\n  incorrect('Wrong answer.')\n)"}, {"name": "interpreted_answer", "description": "A value representing the student's answer to this part.", "definition": "qty(student_scalar, student_units)\n\n"}, {"name": "correct_quantity", "description": "", "definition": "settings[\"correctAnswer\"]\n\n"}, {"name": "correct_units", "description": "", "definition": "units(correct_quantity)\n"}, {"name": "allowed_notation_styles", "description": "", "definition": "[\"plain\",\"en\"]"}, {"name": "match_student_number", "description": "", "definition": "matchnumber(studentAnswer,allowed_notation_styles)"}, {"name": "student_scalar", "description": "", "definition": "match_student_number[1]"}, {"name": "student_units", "description": "<p>Modify&nbsp;the&nbsp;unit portion of&nbsp;the student's answer by</p>\n<p>1. replacing \"ohms\" with \"ohm\" &nbsp;case insensitive</p>\n<p>2.&nbsp;replacing '-'&nbsp;with ' '&nbsp;</p>\n<p>3. replacing '&deg;' with ' deg'&nbsp;</p>\n<p>to allow answers like 10 ft-lb and 30&deg;</p>", "definition": "replace_regex('ohms','ohm',\n  replace_regex('\u00b0', ' deg',\n    replace_regex('-', ' ' ,\n      studentAnswer[len(match_student_number[0])..len(studentAnswer)])),\"i\")"}, {"name": "good_units", "description": "", "definition": "try(\ncompatible(quantity(1, student_units),correct_units),\nmsg,\nfeedback(msg);false)\n"}, {"name": "student_quantity", "description": "<p>This fixes the student answer for two common errors. &nbsp;</p>\n<p>If student_units are wrong&nbsp;&nbsp;- replace with correct units</p>\n<p>If student_scalar has the wrong sign - replace with right sign</p>\n<p>If student makes both errors, only one gets fixed.</p>", "definition": "switch(not good_units, \n       student_scalar * correct_units, \n       not right_sign,\n       -quantity(student_scalar, student_units),\n       quantity(student_scalar,student_units)\n)\n  \n"}, {"name": "percent_error", "description": "", "definition": "try(\nscalar(abs((correct_quantity - student_quantity)/correct_quantity))*100  \n,msg,\nif(student_quantity=correct_quantity,0,100))\n   "}, {"name": "right", "description": "", "definition": "percent_error <= settings['right']\n"}, {"name": "close", "description": "<p>Only marked close if the student actually has the right sign.</p>", "definition": "right_sign and percent_error <= settings['close']"}, {"name": "right_sign", "description": "", "definition": "sign(student_scalar) = sign(correct_quantity) "}], "settings": [{"name": "correctAnswer", "label": "Correct Quantity.", "help_url": "", "hint": "The correct answer given as a JME quantity.", "input_type": "code", "default_value": "", "evaluate": true}, {"name": "right", "label": "% Accuracy for right.", "help_url": "", "hint": "Question will be considered correct if the scalar part of the student's answer is within this % of correct value.", "input_type": "code", "default_value": "0.2", "evaluate": true}, {"name": "close", "label": "% Accuracy for close.", "help_url": "", "hint": "Question will be considered close if the scalar part of the student's answer is within this % of correct value.", "input_type": "code", "default_value": "1.0", "evaluate": true}, {"name": "C1", "label": "Close with units.", "help_url": "", "hint": "Partial Credit for close value with appropriate units. &nbsp;if correct answer is 100 N and close is &plusmn;1%,<br />99 &nbsp;N is accepted.", "input_type": "percent", "default_value": "75"}, {"name": "C2", "label": "No units or wrong sign", "help_url": "", "hint": "Partial credit for forgetting units or using wrong sign.<br />If the correct answer is 100 N, both 100 and -100 N are accepted.", "input_type": "percent", "default_value": "50"}, {"name": "C3", "label": "Close, no units.", "help_url": "", "hint": "Partial Credit for close value but forgotten units.<br />This value would be close&nbsp;if the expected units were provided. &nbsp;If the correct answer is 100 N, and close is &plusmn;1%,<br />99 is accepted.", "input_type": "percent", "default_value": "25"}], "public_availability": "always", "published": true, "extensions": ["quantities"]}, {"source": {"pk": 242, "author": {"name": "Christian Lawson-Perfect", "pk": 7}, "edit_page": "/part_type/242/edit"}, "name": "Spreadsheet", "short_name": "spreadsheet", "description": "<p>An editable spreadsheet. Ranges of cells can be disabled, and you can specify ranges of cells to be marked. A cell is marked correct if its value is equal to the value in the expected answer spreadsheet.</p>", "help_url": "", "input_widget": "spread-sheet", "input_options": {"correctAnswer": "settings[\"correct_answer\"]", "hint": {"static": true, "value": ""}, "initial_sheet": {"static": false, "value": "disable_cells(settings[\"initial_sheet\"], settings[\"disable_ranges\"])"}}, "can_be_gap": true, "can_be_step": true, "marking_script": "mark:\nif(sum(mark_ranges)=0,\n  incorrect(),\n  apply(mark_ranges)\n)\n\ninterpreted_answer:\nstudentAnswer\n\nrange_cells:\nmap(parse_range(ref),ref,values(settings[\"mark_ranges\"]))\n\ntotal_cells:\nlen(flatten(range_cells))\n\nrange_weights:\nswitch(\n  settings[\"marking_method\"]=\"per_cell\",\n    map(len(r)/total_cells, r, range_cells),\n  // otherwise, mark per range\n    repeat(1/len(range_cells), len(range_cells))\n)\n\nmark_ranges:\nmap(\n  let(\n    range_credit,\n      sum(map(\n        let(\n          correctCellString, correctAnswer[c],\n          correctCellNumber, parsenumber(correctCellString, notation_styles),\n          studentCellString, studentAnswer[c],\n          studentCellNumber, parsenumber(studentCellString, notation_styles),\n          award(\n            1/len(cells), \n            switch(\n              correctCellString=\"\",\n                isnan(studentCellNumber) or studentCellString=\"\",\n              isnan(correctCellNumber),\n                lower(correctCellString) = lower(studentCellString)\n              ,\n                abs(studentCellNumber - if(isnan(correctCellNumber),0,correctCellNumber)) <= settings[\"tolerance\"]\n            )\n          )\n        ),\n        c,\n        cells\n      )),\n    message,\n      switch(\n        range_credit=0,\n          if(len(cells)=1, \"This entry is incorrect.\", \"All entries in this range are incorrect.\"),\n        range_credit=1,\n          if(len(cells)=1, \"This entry is correct.\", \"All entries in this range are correct.\"),\n        //otherwise\n          \"Some entries in this range are correct.\"\n      ),\n    assert(len(cells)=0, add_credit(range_credit*w, \"<strong>{name}:</strong> \"+message)); \n    range_credit\n  ),\n  [cells,w,name],\n  zip(range_cells, range_weights, keys(settings[\"mark_ranges\"]))\n)\n\nnotation_styles:\n[\"plain\",\"si-en\"]\n\ncorrectAnswer:\nsettings[\"correct_answer\"]", "marking_notes": [{"name": "mark", "description": "This is the main marking note. It should award credit and provide feedback based on the student's answer.", "definition": "if(sum(mark_ranges)=0,\n  incorrect(),\n  apply(mark_ranges)\n)"}, {"name": "interpreted_answer", "description": "A value representing the student's answer to this part.", "definition": "studentAnswer"}, {"name": "range_cells", "description": "<p>For each range to be marked, the addresses of the cells in that range.</p>", "definition": "map(parse_range(ref),ref,values(settings[\"mark_ranges\"]))"}, {"name": "total_cells", "description": "<p>The total number of cells to be marked. Cells in overlapping ranges will be counted once for each range they're in.</p>", "definition": "len(flatten(range_cells))"}, {"name": "range_weights", "description": "<p>The weight of each range, as a proportion of the available credit.</p>", "definition": "switch(\n  settings[\"marking_method\"]=\"per_cell\",\n    map(len(r)/total_cells, r, range_cells),\n  // otherwise, mark per range\n    repeat(1/len(range_cells), len(range_cells))\n)"}, {"name": "mark_ranges", "description": "<p>Mark each of the ranges specified by the question author.</p>", "definition": "map(\n  let(\n    range_credit,\n      sum(map(\n        let(\n          correctCellString, correctAnswer[c],\n          correctCellNumber, parsenumber(correctCellString, notation_styles),\n          studentCellString, studentAnswer[c],\n          studentCellNumber, parsenumber(studentCellString, notation_styles),\n          award(\n            1/len(cells), \n            switch(\n              correctCellString=\"\",\n                isnan(studentCellNumber) or studentCellString=\"\",\n              isnan(correctCellNumber),\n                lower(correctCellString) = lower(studentCellString)\n              ,\n                abs(studentCellNumber - if(isnan(correctCellNumber),0,correctCellNumber)) <= settings[\"tolerance\"]\n            )\n          )\n        ),\n        c,\n        cells\n      )),\n    message,\n      switch(\n        range_credit=0,\n          if(len(cells)=1, \"This entry is incorrect.\", \"All entries in this range are incorrect.\"),\n        range_credit=1,\n          if(len(cells)=1, \"This entry is correct.\", \"All entries in this range are correct.\"),\n        //otherwise\n          \"Some entries in this range are correct.\"\n      ),\n    assert(len(cells)=0, add_credit(range_credit*w, \"<strong>{name}:</strong> \"+message)); \n    range_credit\n  ),\n  [cells,w,name],\n  zip(range_cells, range_weights, keys(settings[\"mark_ranges\"]))\n)"}, {"name": "notation_styles", "description": "<p>Accepted number notation styles for a value in an individual cell.</p>", "definition": "[\"plain\",\"si-en\"]"}, {"name": "correctAnswer", "description": "", "definition": "settings[\"correct_answer\"]"}], "settings": [{"name": "initial_sheet", "label": "Initial sheet", "help_url": "", "hint": "A <code>spreadsheet</code> object giving the initial state of the sheet that the student should fill in.", "input_type": "code", "default_value": "", "evaluate": true}, {"name": "correct_answer", "label": "Correct answer", "help_url": "", "hint": "A <code>spreadsheet</code> object representing a correct answer to the part.", "input_type": "code", "default_value": "", "evaluate": true}, {"name": "disable_ranges", "label": "Ranges to disable", "help_url": "", "hint": "A list of cell or range references, denoting the cells that should not be editable.", "input_type": "code", "default_value": "[]", "evaluate": true}, {"name": "mark_ranges", "label": "Ranges to mark", "help_url": "", "hint": "A dictionary of cell or range references, mapping names to ranges of cells, denoting the cells that should be compared for equality with the expected answer.", "input_type": "code", "default_value": "dict()", "evaluate": true}, {"name": "marking_method", "label": "Marking method", "help_url": "", "hint": "", "input_type": "dropdown", "default_value": "per_cell", "choices": [{"value": "per_cell", "label": "Each cell has the same weight"}, {"value": "per_range", "label": "Each range has the same weight"}]}, {"name": "tolerance", "label": "Allowed margin of error", "help_url": "", "hint": "", "input_type": "code", "default_value": "0", "evaluate": true}], "public_availability": "always", "published": true, "extensions": ["sheets"]}], "resources": [], "navigation": {"allowregen": true, "showfrontpage": false, "preventleave": false, "typeendtoleave": false}, "contributors": [{"name": "William Haynes", "profile_url": "https://numbas.mathcentre.ac.uk/accounts/profile/2530/"}], "tags": ["centroids", "composite area method", "mechanics", "Mechanics", "statics", "Statics"], "metadata": {"description": "<p>Find the centroid of&nbsp;a shape made from&nbsp;a rectangle, triangle, and circle.</p>", "licence": "Creative Commons Attribution-NonCommercial 4.0 International"}, "statement": "<p>Complete the table below and detemine the coordinates of the centroid of the composite shape shown.</p>\n<p>Consider the shape to be made up of a {if (m=1,'large','')} rectangle {if (m=0, 'plus a triangle', 'with a triangle removed')}, with a {if(random(true,false), &nbsp;radius + \" \" + units &nbsp;+ \" radius\" , &nbsp;2 * radius + \" \" &nbsp;+ units + \" diameter\")} circular hole centered at ({(center+A)[0]}, {(center+A)[1]}).</p>\n<table style=\"margin-left: auto; margin-right: auto;\">\n<tbody>\n<tr>\n<td>{geogebra_applet('fcfsjuv9',[ ['A',A],['b_1',b1],['h_1',h1],['h_t',ht],['n',n],['Center',center],['radius',radius]])}</td>\n</tr>\n</tbody>\n</table>\n<p><span data-jme-visible=\"debug\">{table_add_q}</span></p>", "advice": "<p>{geogebra_applet('fcfsjuv9',[ ['A',A],['b_1',b1],['h_1',h1],['h_t',ht],['n',n],['Center',center],['radius',radius],['visibility',m]])}</p>\n<p>1. Divide the shape into three subshapes as described in the problem statement.&nbsp;</p>\n<p>2. Know how to set up a table to collect the information, since it will not normally be provided.</p>\n<p>3. Determine and enter&nbsp;the area and centroidal coordinates for each subshape into the table</p>\n<p style=\"padding-left: 30px;\">$\\qquad A_i, \\bar{x}_i,\\bar{y}_i$</p>\n<p>4. Multiply area by the centroidal coordinates to&nbsp;get the moment of areas for the pieces.</p>\n<p style=\"padding-left: 30px;\">$\\qquad (Q_x)_i = A_i\\bar{y}_i ,\\quad(Q_y)_i=A_i\\bar{x}_i$.</p>\n<p>5. Sum columns 3, 6 and 7 to find the total area and moments of area: $ A, Q_x, Q_y$</p>\n<p>6. Find answers with &nbsp;</p>\n<p style=\"padding-left: 30px;\">$\\qquad &nbsp;\\bar{x} = \\dfrac{Q_y}{A} =\\dfrac{\\Sigma A_i \\bar{x}_i}{\\Sigma A_i} = \\dfrac{\\var{siground(Q_total[1],3)}}{\\var{siground(area_total,3)}} = &nbsp;\\var{siground(centroid[0],3)}\\, \\var{units}$</p>\n<p style=\"padding-left: 30px;\">$\\qquad &nbsp;\\bar{y} &nbsp;= \\dfrac{Q_x}{A} = \\dfrac{\\Sigma A_i \\bar{y}_i}{\\Sigma A_i}= \\dfrac{\\var{siground(Q_total[0],3)}}{\\var{siground(area_total,3)}}= \\var{siground(centroid[1],3)}\\, \\var{units} $</p>", "rulesets": {}, "builtin_constants": {"e": true, "pi,\u03c0": true, "i": true, "j": false}, "constants": [], "variables": {"ht": {"name": "ht", "group": "Input values", "definition": "random(3..9#3)", "description": "<p>\"height\" of triangle &nbsp;</p>\n<p>horizontal for n = 4,5,6,10,11,12</p>\n<p>vertical for n = 1,2,3,7,8,9</p>", "templateType": "anything", "can_override": false}, "C_rect": {"name": "C_rect", "group": "centroids", "definition": "[vector(b1/2,h1/2) + A,\n if(n in [1,2,3], vector(b1/2,(h1-ht)/2)+A,\n if(n in [4,5,6], vector((b1+ht)/2,h1/2)+A,\n if(n in [7,8,9], vector(b1/2,(h1+ht)/2)+A,\n vector((b1-ht)/2,h1/2)+A)))] ", "description": "", "templateType": "anything", "can_override": false}, "C_circ": {"name": "C_circ", "group": "centroids", "definition": "[center +A ,center +A]", "description": "", "templateType": "anything", "can_override": false}, "units": {"name": "units", "group": "Input values", "definition": "random('in', 'cm', 'ft' )", "description": "<p>Offset of bottom right corner from originl</p>", "templateType": "anything", "can_override": false}, "area_circ": {"name": "area_circ", "group": "Calculated areas", "definition": "[- pi * radius^2, - pi* radius^2]", "description": "", "templateType": "anything", "can_override": false}, "area_total": {"name": "area_total", "group": "Calculated areas", "definition": "area_rect[0]+area_tri[0]+area_circ[0]", "description": "", "templateType": "anything", "can_override": false}, "area_tri": {"name": "area_tri", "group": "Calculated areas", "definition": "[if(n in [1,2,3,7,8,9], b1*ht/2,h1*ht/2),\n-if(n in [1,2,3,7,8,9], b1*ht/2,h1*ht/2)]", "description": "", "templateType": "anything", "can_override": false}, "center": {"name": "center", "group": "Input values", "definition": "vector(b1/2,h1/2) + random(0..3) *\nvector(if(n<=3,[0,-1],\nif(n<=6,[1,0],\nif(n<=9,[0,1],\n[-1,0]))))\n\n\n\n\n", "description": "<p>center of the circle measured from bottom left of the rectangle</p>", "templateType": "anything", "can_override": false}, "Q_circ": {"name": "Q_circ", "group": "moments of area", "definition": "area_circ[m] * vector(C_circ[m][1],C_circ[m][0])", "description": "", "templateType": "anything", "can_override": false}, "radius": {"name": "radius", "group": "Input values", "definition": "random(1..(min(h1-1,b1-1)/2)#0.5)", "description": "<p>radius of the circle</p>", "templateType": "anything", "can_override": false}, "A": {"name": "A", "group": "Input values", "definition": "-vector(random([0,0],[b1,0],[b1,h1],[0,h1],[b1/2,h1/2],[0,h1/2],[center[0],center[1]]))", "description": "<p>This offsets the shape to one of the corners of the rect, the center of the rect, or the center of the circle.</p>", "templateType": "anything", "can_override": false}, "h1": {"name": "h1", "group": "Input values", "definition": "random(4..12#2)", "description": "<p>vertical height of rectangle</p>", "templateType": "anything", "can_override": false}, "b1": {"name": "b1", "group": "Input values", "definition": "random(4..12#2)", "description": "<p>horizontal base of rectangle</p>", "templateType": "anything", "can_override": false}, "n": {"name": "n", "group": "Input values", "definition": "random(1 .. 12#1)", "description": "<p>Selects the position of the triangle, index gives vertex location</p>\n<table>\n<tbody>\n<tr>\n<td style=\"text-align: center;\"></td>\n<td style=\"text-align: center;\">9</td>\n<td style=\"text-align: center;\">8</td>\n<td style=\"text-align: center;\">7</td>\n<td style=\"text-align: center;\"></td>\n</tr>\n<tr>\n<td style=\"text-align: center;\">10</td>\n<td style=\"text-align: center;\"></td>\n<td style=\"text-align: center;\"></td>\n<td style=\"text-align: center;\"></td>\n<td style=\"text-align: center;\">6</td>\n</tr>\n<tr>\n<td style=\"text-align: center;\">11</td>\n<td style=\"text-align: center;\"></td>\n<td style=\"text-align: center;\">rectangle</td>\n<td style=\"text-align: center;\"></td>\n<td style=\"text-align: center;\">5</td>\n</tr>\n<tr>\n<td style=\"text-align: center;\">12</td>\n<td style=\"text-align: center;\"></td>\n<td style=\"text-align: center;\"></td>\n<td style=\"text-align: center;\"></td>\n<td style=\"text-align: center;\">4</td>\n</tr>\n<tr>\n<td style=\"text-align: center;\"></td>\n<td style=\"text-align: center;\">1</td>\n<td style=\"text-align: center;\">2</td>\n<td style=\"text-align: center;\">3</td>\n<td style=\"text-align: center;\"></td>\n</tr>\n</tbody>\n</table>", "templateType": "randrange", "can_override": false}, "C_tri": {"name": "C_tri", "group": "centroids", "definition": "// determines location of centroid\n// returns array of centroid coordinates, first term for m=0 \n[\nswitch(\n  n=1, vector(b1/3,-ht/3),\n  n=2, vector(b1/2,-ht/3),\n  n=3, vector(2*b1/3,-ht/3),\n  n=4, vector(b1+ht/3,h1/3),\n  n=5, vector(b1+ht/3,h1/2),\n  n=6, vector(b1+ht/3,2*h1/3),\n  n=7, vector(2 * b1/3, h1+ht/3),\n  n=8, vector(b1/2, h1+ht/3),\n  n=9, vector(b1/3, h1+ht/3),\n  n=10, vector(-ht/3,2*h1/3),\n  n=11, vector(-ht/3,h1/2),\n  n=12, vector(-ht/3,h1/3)\n  ) + A\n  ,\n  switch(\n  n=3, vector(b1/3,-2*ht/3),\n  n=2, vector(b1/2,-2*ht/3),\n  n=1, vector(2*b1/3,-2*ht/3),\n  n=6, vector(b1+2*ht/3,h1/3),\n  n=5, vector(b1+2*ht/3,h1/2),\n  n=4, vector(b1+2*ht/3,2*h1/3),\n  n=9, vector(2 * b1/3, h1+2*ht/3),\n  n=8, vector(b1/2, h1+2*ht/3),\n  n=7, vector(b1/3, h1+2*ht/3),\n  n=12, vector(-2*ht/3,2*h1/3),\n  n=11, vector(-2*ht/3,h1/2),\n  n=10, vector(-2*ht/3,h1/3)\n  ) + A\n  ]", "description": "<p>determines location of centroid of triangle based on location and method<br />returns array of centroid coordinates, first term for m=0 <br /><br /></p>", "templateType": "anything", "can_override": false}, "m": {"name": "m", "group": "Input values", "definition": "if(n in [2,5,8,11],0,random(0..1))\n", "description": "<p>This is the method used to solve the problem:&nbsp;</p>\n<p>m=0: small rectangle + triangle - circle</p>\n<p>m=1: big rectangle - triangle - circle</p>\n<p>when n is in [2,5,8,11], use method 0, becauses otherwise it would require 2 negative triangles.</p>", "templateType": "anything", "can_override": false}, "Q_rect": {"name": "Q_rect", "group": "moments of area", "definition": "area_rect[m] * vector(C_rect[m][1],C_rect[m][0])", "description": "<p>[Q_x,Q_y]</p>", "templateType": "anything", "can_override": false}, "area_rect": {"name": "area_rect", "group": "Calculated areas", "definition": "[b1*h1,if(n in [1,2,3,7,8,9],b1*(h1+ht),h1*(b1+ht))]", "description": "", "templateType": "anything", "can_override": false}, "centroid": {"name": "centroid", "group": "moments of area", "definition": "vector(Q_total[1]/area_total,Q_total[0]/area_total)", "description": "", "templateType": "anything", "can_override": false}, "Q_tri": {"name": "Q_tri", "group": "moments of area", "definition": "area_tri[m] * vector(C_tri[m][1],C_tri[m][0])", "description": "", "templateType": "anything", "can_override": false}, "Q_total": {"name": "Q_total", "group": "moments of area", "definition": "Q_rect+Q_tri+Q_circ", "description": "", "templateType": "anything", "can_override": false}, "blank_table": {"name": "blank_table", "group": "Ungrouped variables", "definition": "spreadsheet_from_base64_file(safe(\"centroid_table.xlsx\"), safe(\"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\"))", "description": "", "templateType": "spreadsheet", "can_override": false}, "params": {"name": "params", "group": "Ungrouped variables", "definition": "[ ['A',A],['b_1',b1],['h_1',h1],['h_t',ht],['n',n],['Center',center],['radius',radius]]", "description": "", "templateType": "anything", "can_override": false}, "applet": {"name": "applet", "group": "Ungrouped variables", "definition": "geogebra_applet('fcfsjuv9',params)", "description": "", "templateType": "anything", "can_override": false}, "table_add_centroids": {"name": "table_add_centroids", "group": "Ungrouped variables", "definition": "fill_range(table_add_areas, \"D2:E4\", map((x)->[siground(x[m][0],3),siground(x[m][1],3)], [C_rect,c_tri, c_circ]))", "description": "", "templateType": "anything", "can_override": false}, "table_add_areas": {"name": "table_add_areas", "group": "Ungrouped variables", "definition": "fill_range(blank_table,\"C2:C5\",map(v->siground(v[m],3), [area_rect,area_tri, area_circ])+ [precround(area_total,2)])\n", "description": "", "templateType": "anything", "can_override": false}, "table_add_q": {"name": "table_add_q", "group": "Ungrouped variables", "definition": "fill_range(table_add_centroids, \"F2:G5\",  map((x)->[siground(x[1],3),siground(x[0],3)],[Q_rect,Q_tri,Q_circ])+ [list(precround(q_total,1))])", "description": "", "templateType": "anything", "can_override": false}, "debug": {"name": "debug", "group": "Ungrouped variables", "definition": "false", "description": "", "templateType": "anything", "can_override": false}}, "variablesTest": {"condition": "// tries to prevent the circle from extending beyond the perimiter.\n\nif (n<=3,  center[1]-2*radius   > -(h1+ht/2),\nif (n<=6, (center[0]+2*radius) <  (b1+ht/2),\nif (n<=9, (center[1]+2*radius) <  (h1+ht/2),\n          (center[0]-2*radius) > -(b1-ht/2))))\n", "maxRuns": 100}, "ungrouped_variables": ["blank_table", "table_add_areas", "table_add_centroids", "table_add_q", "params", "applet", "debug"], "variable_groups": [{"name": "Input values", "variables": ["A", "b1", "h1", "ht", "center", "units", "radius", "n", "m"]}, {"name": "Calculated areas", "variables": ["area_rect", "area_tri", "area_circ", "area_total"]}, {"name": "centroids", "variables": ["C_rect", "C_circ", "C_tri"]}, {"name": "moments of area", "variables": ["Q_rect", "Q_tri", "Q_circ", "Q_total", "centroid"]}], "functions": {}, "preamble": {"js": "\n", "css": "table.centroid{margin:auto;}\n\ntable.centroid td {\n  width:6em; \n  vertical-align:center; \n  text-align:center;}\ntable.centroid *.underline {border-bottom: 2px solid black;}\n\n"}, "parts": [{"type": "spreadsheet", "useCustomName": true, "customName": "Centroid Table", "marks": "36", "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": true, "showFeedbackIcon": true, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "settings": {"initial_sheet": "blank_table", "correct_answer": "table_add_q", "disable_ranges": "[\"A1:B5\", \"A1:G1\", \"D5:E5\"]", "mark_ranges": "[\"$A_i$\": \"C2:C4\", \"$\\\\bar{x}_i$\": \"D2:D4\", \"$\\\\bar{y}_i$\": \"E2:E4\",\"$A_i\\\\bar{x}_i$\": \"F2:F4\", \"$A_i\\\\bar{y}_i$\": \"G2:G4\", \"$A$\": \"C5\", \"$Q_y$\": \"F5\",\"$Q_x$\": \"G5\"]", "marking_method": "per_cell", "tolerance": "0.05"}}, {"type": "gapfill", "useCustomName": true, "customName": "Centroid", "marks": 0, "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": true, "showFeedbackIcon": true, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "prompt": "<p style=\"padding-left: 40px;\">$\\bar{x} =\\dfrac{Q_y}{A} = $ [[0]]</p>\n<p style=\"padding-left: 40px;\">$\\bar{y} =\\dfrac{Q_x}{A} = $ [[1]]<br/><br/></p>", "gaps": [{"type": "engineering-answer", "useCustomName": true, "customName": "xbar", "marks": "2", "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": true, "showFeedbackIcon": true, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "settings": {"correctAnswer": "qty(siground(centroid[0],3),units)", "right": "0.2", "close": "1.0", "C1": "75", "C2": "50", "C3": "25"}}, {"type": "engineering-answer", "useCustomName": true, "customName": "ybar", "marks": "2", "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": true, "showFeedbackIcon": true, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "settings": {"correctAnswer": "siground(quantity(centroid[1],units),3)", "right": "0.2", "close": "1.0", "C1": "75", "C2": "50", "C3": "25"}}], "sortAnswers": false}], "partsMode": "all", "maxMarks": 0, "objectives": [], "penalties": [], "objectiveVisibility": "always", "penaltyVisibility": "always"}, {"name": "Centroid of a composite area: rectangles and triangles", "extensions": ["geogebra", "quantities", "sheets"], "custom_part_types": [{"source": {"pk": 19, "author": {"name": "William Haynes", "pk": 2530}, "edit_page": "/part_type/19/edit"}, "name": "Engineering Accuracy with units", "short_name": "engineering-answer", "description": "<p>A value with units marked right if within an adjustable % error of the correct value. &nbsp;Marked close if within a wider margin of error.</p>", "help_url": "", "input_widget": "string", "input_options": {"correctAnswer": "siground(settings['correctAnswer'],4)", "hint": {"static": true, "value": ""}, "allowEmpty": {"static": true, "value": true}}, "can_be_gap": true, "can_be_step": true, "marking_script": "mark:\nswitch( \n  right and good_units and right_sign, add_credit(1.0,'Correct.'),\n  right and good_units and not right_sign, add_credit(settings['C2'],'Wrong sign.'),\n  right and right_sign and not good_units, add_credit(settings['C2'],'Correct value, but wrong or missing units.'),\n  close and good_units, add_credit(settings['C1'],'Close.'),\n  close and not good_units, add_credit(settings['C3'],'Answer is close, but wrong or missing units.'),\n  incorrect('Wrong answer.')\n)\n\ninterpreted_answer:\nqty(student_scalar, student_units)\n\n\n\ncorrect_quantity:\nsettings[\"correctAnswer\"]\n\n\n\ncorrect_units:\nunits(correct_quantity)\n\n\nallowed_notation_styles:\n[\"plain\",\"en\"]\n\nmatch_student_number:\nmatchnumber(studentAnswer,allowed_notation_styles)\n\nstudent_scalar:\nmatch_student_number[1]\n\nstudent_units:\nreplace_regex('ohms','ohm',\n  replace_regex('\u00b0', ' deg',\n    replace_regex('-', ' ' ,\n      studentAnswer[len(match_student_number[0])..len(studentAnswer)])),\"i\")\n\ngood_units:\ntry(\ncompatible(quantity(1, student_units),correct_units),\nmsg,\nfeedback(msg);false)\n\n\nstudent_quantity:\nswitch(not good_units, \n       student_scalar * correct_units, \n       not right_sign,\n       -quantity(student_scalar, student_units),\n       quantity(student_scalar,student_units)\n)\n  \n\n\npercent_error:\ntry(\nscalar(abs((correct_quantity - student_quantity)/correct_quantity))*100  \n,msg,\nif(student_quantity=correct_quantity,0,100))\n   \n\nright:\npercent_error <= settings['right']\n\n\nclose:\nright_sign and percent_error <= settings['close']\n\nright_sign:\nsign(student_scalar) = sign(correct_quantity)", "marking_notes": [{"name": "mark", "description": "This is the main marking note. It should award credit and provide feedback based on the student's answer.", "definition": "switch( \n  right and good_units and right_sign, add_credit(1.0,'Correct.'),\n  right and good_units and not right_sign, add_credit(settings['C2'],'Wrong sign.'),\n  right and right_sign and not good_units, add_credit(settings['C2'],'Correct value, but wrong or missing units.'),\n  close and good_units, add_credit(settings['C1'],'Close.'),\n  close and not good_units, add_credit(settings['C3'],'Answer is close, but wrong or missing units.'),\n  incorrect('Wrong answer.')\n)"}, {"name": "interpreted_answer", "description": "A value representing the student's answer to this part.", "definition": "qty(student_scalar, student_units)\n\n"}, {"name": "correct_quantity", "description": "", "definition": "settings[\"correctAnswer\"]\n\n"}, {"name": "correct_units", "description": "", "definition": "units(correct_quantity)\n"}, {"name": "allowed_notation_styles", "description": "", "definition": "[\"plain\",\"en\"]"}, {"name": "match_student_number", "description": "", "definition": "matchnumber(studentAnswer,allowed_notation_styles)"}, {"name": "student_scalar", "description": "", "definition": "match_student_number[1]"}, {"name": "student_units", "description": "<p>Modify&nbsp;the&nbsp;unit portion of&nbsp;the student's answer by</p>\n<p>1. replacing \"ohms\" with \"ohm\" &nbsp;case insensitive</p>\n<p>2.&nbsp;replacing '-'&nbsp;with ' '&nbsp;</p>\n<p>3. replacing '&deg;' with ' deg'&nbsp;</p>\n<p>to allow answers like 10 ft-lb and 30&deg;</p>", "definition": "replace_regex('ohms','ohm',\n  replace_regex('\u00b0', ' deg',\n    replace_regex('-', ' ' ,\n      studentAnswer[len(match_student_number[0])..len(studentAnswer)])),\"i\")"}, {"name": "good_units", "description": "", "definition": "try(\ncompatible(quantity(1, student_units),correct_units),\nmsg,\nfeedback(msg);false)\n"}, {"name": "student_quantity", "description": "<p>This fixes the student answer for two common errors. &nbsp;</p>\n<p>If student_units are wrong&nbsp;&nbsp;- replace with correct units</p>\n<p>If student_scalar has the wrong sign - replace with right sign</p>\n<p>If student makes both errors, only one gets fixed.</p>", "definition": "switch(not good_units, \n       student_scalar * correct_units, \n       not right_sign,\n       -quantity(student_scalar, student_units),\n       quantity(student_scalar,student_units)\n)\n  \n"}, {"name": "percent_error", "description": "", "definition": "try(\nscalar(abs((correct_quantity - student_quantity)/correct_quantity))*100  \n,msg,\nif(student_quantity=correct_quantity,0,100))\n   "}, {"name": "right", "description": "", "definition": "percent_error <= settings['right']\n"}, {"name": "close", "description": "<p>Only marked close if the student actually has the right sign.</p>", "definition": "right_sign and percent_error <= settings['close']"}, {"name": "right_sign", "description": "", "definition": "sign(student_scalar) = sign(correct_quantity) "}], "settings": [{"name": "correctAnswer", "label": "Correct Quantity.", "help_url": "", "hint": "The correct answer given as a JME quantity.", "input_type": "code", "default_value": "", "evaluate": true}, {"name": "right", "label": "% Accuracy for right.", "help_url": "", "hint": "Question will be considered correct if the scalar part of the student's answer is within this % of correct value.", "input_type": "code", "default_value": "0.2", "evaluate": true}, {"name": "close", "label": "% Accuracy for close.", "help_url": "", "hint": "Question will be considered close if the scalar part of the student's answer is within this % of correct value.", "input_type": "code", "default_value": "1.0", "evaluate": true}, {"name": "C1", "label": "Close with units.", "help_url": "", "hint": "Partial Credit for close value with appropriate units. &nbsp;if correct answer is 100 N and close is &plusmn;1%,<br />99 &nbsp;N is accepted.", "input_type": "percent", "default_value": "75"}, {"name": "C2", "label": "No units or wrong sign", "help_url": "", "hint": "Partial credit for forgetting units or using wrong sign.<br />If the correct answer is 100 N, both 100 and -100 N are accepted.", "input_type": "percent", "default_value": "50"}, {"name": "C3", "label": "Close, no units.", "help_url": "", "hint": "Partial Credit for close value but forgotten units.<br />This value would be close&nbsp;if the expected units were provided. &nbsp;If the correct answer is 100 N, and close is &plusmn;1%,<br />99 is accepted.", "input_type": "percent", "default_value": "25"}], "public_availability": "always", "published": true, "extensions": ["quantities"]}, {"source": {"pk": 242, "author": {"name": "Christian Lawson-Perfect", "pk": 7}, "edit_page": "/part_type/242/edit"}, "name": "Spreadsheet", "short_name": "spreadsheet", "description": "<p>An editable spreadsheet. Ranges of cells can be disabled, and you can specify ranges of cells to be marked. A cell is marked correct if its value is equal to the value in the expected answer spreadsheet.</p>", "help_url": "", "input_widget": "spread-sheet", "input_options": {"correctAnswer": "settings[\"correct_answer\"]", "hint": {"static": true, "value": ""}, "initial_sheet": {"static": false, "value": "disable_cells(settings[\"initial_sheet\"], settings[\"disable_ranges\"])"}}, "can_be_gap": true, "can_be_step": true, "marking_script": "mark:\nif(sum(mark_ranges)=0,\n  incorrect(),\n  apply(mark_ranges)\n)\n\ninterpreted_answer:\nstudentAnswer\n\nrange_cells:\nmap(parse_range(ref),ref,values(settings[\"mark_ranges\"]))\n\ntotal_cells:\nlen(flatten(range_cells))\n\nrange_weights:\nswitch(\n  settings[\"marking_method\"]=\"per_cell\",\n    map(len(r)/total_cells, r, range_cells),\n  // otherwise, mark per range\n    repeat(1/len(range_cells), len(range_cells))\n)\n\nmark_ranges:\nmap(\n  let(\n    range_credit,\n      sum(map(\n        let(\n          correctCellString, correctAnswer[c],\n          correctCellNumber, parsenumber(correctCellString, notation_styles),\n          studentCellString, studentAnswer[c],\n          studentCellNumber, parsenumber(studentCellString, notation_styles),\n          award(\n            1/len(cells), \n            switch(\n              correctCellString=\"\",\n                isnan(studentCellNumber) or studentCellString=\"\",\n              isnan(correctCellNumber),\n                lower(correctCellString) = lower(studentCellString)\n              ,\n                abs(studentCellNumber - if(isnan(correctCellNumber),0,correctCellNumber)) <= settings[\"tolerance\"]\n            )\n          )\n        ),\n        c,\n        cells\n      )),\n    message,\n      switch(\n        range_credit=0,\n          if(len(cells)=1, \"This entry is incorrect.\", \"All entries in this range are incorrect.\"),\n        range_credit=1,\n          if(len(cells)=1, \"This entry is correct.\", \"All entries in this range are correct.\"),\n        //otherwise\n          \"Some entries in this range are correct.\"\n      ),\n    assert(len(cells)=0, add_credit(range_credit*w, \"<strong>{name}:</strong> \"+message)); \n    range_credit\n  ),\n  [cells,w,name],\n  zip(range_cells, range_weights, keys(settings[\"mark_ranges\"]))\n)\n\nnotation_styles:\n[\"plain\",\"si-en\"]\n\ncorrectAnswer:\nsettings[\"correct_answer\"]", "marking_notes": [{"name": "mark", "description": "This is the main marking note. It should award credit and provide feedback based on the student's answer.", "definition": "if(sum(mark_ranges)=0,\n  incorrect(),\n  apply(mark_ranges)\n)"}, {"name": "interpreted_answer", "description": "A value representing the student's answer to this part.", "definition": "studentAnswer"}, {"name": "range_cells", "description": "<p>For each range to be marked, the addresses of the cells in that range.</p>", "definition": "map(parse_range(ref),ref,values(settings[\"mark_ranges\"]))"}, {"name": "total_cells", "description": "<p>The total number of cells to be marked. Cells in overlapping ranges will be counted once for each range they're in.</p>", "definition": "len(flatten(range_cells))"}, {"name": "range_weights", "description": "<p>The weight of each range, as a proportion of the available credit.</p>", "definition": "switch(\n  settings[\"marking_method\"]=\"per_cell\",\n    map(len(r)/total_cells, r, range_cells),\n  // otherwise, mark per range\n    repeat(1/len(range_cells), len(range_cells))\n)"}, {"name": "mark_ranges", "description": "<p>Mark each of the ranges specified by the question author.</p>", "definition": "map(\n  let(\n    range_credit,\n      sum(map(\n        let(\n          correctCellString, correctAnswer[c],\n          correctCellNumber, parsenumber(correctCellString, notation_styles),\n          studentCellString, studentAnswer[c],\n          studentCellNumber, parsenumber(studentCellString, notation_styles),\n          award(\n            1/len(cells), \n            switch(\n              correctCellString=\"\",\n                isnan(studentCellNumber) or studentCellString=\"\",\n              isnan(correctCellNumber),\n                lower(correctCellString) = lower(studentCellString)\n              ,\n                abs(studentCellNumber - if(isnan(correctCellNumber),0,correctCellNumber)) <= settings[\"tolerance\"]\n            )\n          )\n        ),\n        c,\n        cells\n      )),\n    message,\n      switch(\n        range_credit=0,\n          if(len(cells)=1, \"This entry is incorrect.\", \"All entries in this range are incorrect.\"),\n        range_credit=1,\n          if(len(cells)=1, \"This entry is correct.\", \"All entries in this range are correct.\"),\n        //otherwise\n          \"Some entries in this range are correct.\"\n      ),\n    assert(len(cells)=0, add_credit(range_credit*w, \"<strong>{name}:</strong> \"+message)); \n    range_credit\n  ),\n  [cells,w,name],\n  zip(range_cells, range_weights, keys(settings[\"mark_ranges\"]))\n)"}, {"name": "notation_styles", "description": "<p>Accepted number notation styles for a value in an individual cell.</p>", "definition": "[\"plain\",\"si-en\"]"}, {"name": "correctAnswer", "description": "", "definition": "settings[\"correct_answer\"]"}], "settings": [{"name": "initial_sheet", "label": "Initial sheet", "help_url": "", "hint": "A <code>spreadsheet</code> object giving the initial state of the sheet that the student should fill in.", "input_type": "code", "default_value": "", "evaluate": true}, {"name": "correct_answer", "label": "Correct answer", "help_url": "", "hint": "A <code>spreadsheet</code> object representing a correct answer to the part.", "input_type": "code", "default_value": "", "evaluate": true}, {"name": "disable_ranges", "label": "Ranges to disable", "help_url": "", "hint": "A list of cell or range references, denoting the cells that should not be editable.", "input_type": "code", "default_value": "[]", "evaluate": true}, {"name": "mark_ranges", "label": "Ranges to mark", "help_url": "", "hint": "A dictionary of cell or range references, mapping names to ranges of cells, denoting the cells that should be compared for equality with the expected answer.", "input_type": "code", "default_value": "dict()", "evaluate": true}, {"name": "marking_method", "label": "Marking method", "help_url": "", "hint": "", "input_type": "dropdown", "default_value": "per_cell", "choices": [{"value": "per_cell", "label": "Each cell has the same weight"}, {"value": "per_range", "label": "Each range has the same weight"}]}, {"name": "tolerance", "label": "Allowed margin of error", "help_url": "", "hint": "", "input_type": "code", "default_value": "0", "evaluate": true}], "public_availability": "always", "published": true, "extensions": ["sheets"]}], "resources": ["question-resources/centroid-t-r.ggb"], "navigation": {"allowregen": true, "showfrontpage": false, "preventleave": false, "typeendtoleave": false}, "contributors": [{"name": "Christian Lawson-Perfect", "profile_url": "https://numbas.mathcentre.ac.uk/accounts/profile/7/"}, {"name": "William Haynes", "profile_url": "https://numbas.mathcentre.ac.uk/accounts/profile/2530/"}], "tags": ["centroids", "first moment of area", "mechanics", "Mechanics", "statics", "Statics"], "metadata": {"description": "<p>Find the centroid of a shape made up of a rectangle and two triangles.</p>", "licence": "Creative Commons Attribution-NonCommercial 4.0 International"}, "statement": "<p>Determine the coordinates of the centroid of a polygon made up of a ({b0} $\\times$ {h0}) rectangle, {if(sign1='+', 'plus', 'minus')} a ({b1} $\\times$ {h1}) triangle, {if(sign2='+', 'plus', 'minus')} a ({b2} $\\times$ {h2}) triangle. &nbsp;Length units are [{units}].</p>\n<table style=\"margin-left: auto; margin-right: auto;\">\n<tbody>\n<tr>\n<td>{applet()}</td>\n</tr>\n</tbody>\n</table>\n<p><span data-jme-visible=\"debug\">{answer_sheet}</span></p>", "advice": "<div>\n<p>$\\qquad\\bar{x} = \\dfrac{Q_y}{A} = &nbsp;\\dfrac{\\Sigma A_i\\bar{x}_i}{\\Sigma A_i}= &nbsp; \\dfrac{\\var{siground(QT[0],4)}}{\\var{AT}} &nbsp;=\\var{display(xbar)}$</p>\n<p>$\\qquad \\bar{y} = \\dfrac{Q_x}{A} = &nbsp;\\dfrac{\\Sigma A_i \\bar{y}_i}{\\Sigma A_i}= &nbsp;\\dfrac{\\var{siground(QT[1],4)}}{\\var{AT}} &nbsp;=\\var{display(ybar)}$</p>\n</div>", "rulesets": {}, "builtin_constants": {"e": true, "pi,\u03c0": true, "i": true, "j": false}, "constants": [], "variables": {"A": {"name": "A", "group": "Ungrouped variables", "definition": "vector(0,random(2..12))", "description": "", "templateType": "anything", "can_override": false}, "C2": {"name": "C2", "group": "geometry", "definition": "vector(A[0],B[1])+(vector(B[0],A[1])-vector(A[0],B[1]))/3  ", "description": "", "templateType": "anything", "can_override": false}, "A0": {"name": "A0", "group": "geometry", "definition": "b0 h0", "description": "", "templateType": "anything", "can_override": false}, "A2": {"name": "A2", "group": "geometry", "definition": "b2 h2/2 if(sign2='+',1,-1)", "description": "", "templateType": "anything", "can_override": false}, "b0": {"name": "b0", "group": "geometry", "definition": "B[0]", "description": "", "templateType": "anything", "can_override": false}, "C": {"name": "C", "group": "Ungrouped variables", "definition": "vector(random(2..12),0)", "description": "", "templateType": "anything", "can_override": false}, "b2": {"name": "b2", "group": "geometry", "definition": "b0", "description": "", "templateType": "anything", "can_override": false}, "C1": {"name": "C1", "group": "geometry", "definition": "vector(B[0],C[1])+(vector(C[0],B[1])-vector(B[0],C[1]))/3  ", "description": "", "templateType": "anything", "can_override": false}, "A1": {"name": "A1", "group": "geometry", "definition": "b1 h1 /2 if(sign1='+',1,-1)", "description": "", "templateType": "anything", "can_override": false}, "ybar": {"name": "ybar", "group": "Unnamed group", "definition": "(a0 c0[1] + a1 c1[1] + a2 c2[1])/AT qty(1,units)", "description": "", "templateType": "anything", "can_override": false}, "h1": {"name": "h1", "group": "geometry", "definition": "h0", "description": "", "templateType": "anything", "can_override": false}, "B": {"name": "B", "group": "Ungrouped variables", "definition": "vector(random(2..12),random(2..12))", "description": "", "templateType": "anything", "can_override": false}, "h0": {"name": "h0", "group": "geometry", "definition": "B[1]", "description": "", "templateType": "anything", "can_override": false}, "sign2": {"name": "sign2", "group": "geometry", "definition": "if(b[1]<a[1],'+','-')", "description": "", "templateType": "anything", "can_override": false}, "C0": {"name": "C0", "group": "geometry", "definition": "(B/2)", "description": "", "templateType": "anything", "can_override": false}, "AT": {"name": "AT", "group": "geometry", "definition": "A0+A1+A2", "description": "", "templateType": "anything", "can_override": false}, "h2": {"name": "h2", "group": "geometry", "definition": "abs(b[1]-A[1])", "description": "", "templateType": "anything", "can_override": false}, "xbar": {"name": "xbar", "group": "Unnamed group", "definition": "(a0 c0[0] + a1 c1[0] + a2 c2[0])/AT qty(1,units)", "description": "", "templateType": "anything", "can_override": false}, "b1": {"name": "b1", "group": "geometry", "definition": "abs(b[0]-c[0])", "description": "", "templateType": "anything", "can_override": false}, "units": {"name": "units", "group": "Ungrouped variables", "definition": "random('in','cm','ft','m')", "description": "", "templateType": "anything", "can_override": false}, "sign1": {"name": "sign1", "group": "geometry", "definition": "if(b[0]<c[0],'+','-')", "description": "", "templateType": "anything", "can_override": false}, "debug": {"name": "debug", "group": "Ungrouped variables", "definition": "false", "description": "", "templateType": "anything", "can_override": false}, "D": {"name": "D", "group": "Ungrouped variables", "definition": "vector(0,0)", "description": "", "templateType": "anything", "can_override": false}, "blank_sheet": {"name": "blank_sheet", "group": "Ungrouped variables", "definition": "spreadsheet_from_base64_file(safe(\"centroid_table.xlsx\"), safe(\"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\"))", "description": "", "templateType": "spreadsheet", "can_override": false}, "areas_sheet": {"name": "areas_sheet", "group": "Ungrouped variables", "definition": "fill_range(blank_sheet,\"B2:B5\", [a0,a1,a2,at])", "description": "", "templateType": "anything", "can_override": false}, "centroids_sheet": {"name": "centroids_sheet", "group": "Ungrouped variables", "definition": "fill_range(areas_sheet, \"C2:D4\", map(v-> [siground(v[0],4), siground(v[1],4)], [C0,C1,C2]))", "description": "", "templateType": "anything", "can_override": false}, "Q0": {"name": "Q0", "group": "geometry", "definition": "a0 c0", "description": "<p>[ai xbari, ai ybari]</p>", "templateType": "anything", "can_override": false}, "Q1": {"name": "Q1", "group": "geometry", "definition": "a1 c1", "description": "", "templateType": "anything", "can_override": false}, "Q2": {"name": "Q2", "group": "geometry", "definition": "a2 c2", "description": "", "templateType": "anything", "can_override": false}, "QT": {"name": "QT", "group": "geometry", "definition": "Q0+Q1+Q2", "description": "", "templateType": "anything", "can_override": false}, "answer_sheet": {"name": "answer_sheet", "group": "Ungrouped variables", "definition": "fill_range(centroids_sheet,\"E2:F5\",map(v->[siground(v[0],4),siground(v[1],4)],[Q0,Q1,Q2,QT]))", "description": "", "templateType": "anything", "can_override": false}, "xbar2": {"name": "xbar2", "group": "Unnamed group", "definition": "Qt[0]/(At)", "description": "", "templateType": "anything", "can_override": false}}, "variablesTest": {"condition": "B[1]<>A[1] and B[0]<>C[0]", "maxRuns": "100"}, "ungrouped_variables": ["A", "B", "C", "D", "units", "debug", "blank_sheet", "areas_sheet", "centroids_sheet", "answer_sheet"], "variable_groups": [{"name": "geometry", "variables": ["b0", "h0", "b2", "h1", "b1", "h2", "sign1", "sign2", "A0", "A1", "A2", "AT", "C0", "C2", "C1", "Q0", "Q1", "Q2", "QT"]}, {"name": "Unnamed group", "variables": ["xbar", "ybar", "xbar2"]}], "functions": {"Q": {"parameters": [["area", "?"], ["distance", "?"]], "type": "quantity", "language": "jme", "definition": "display(area*distance*qty(1,units)*qty(1,units)*qty(1,units))"}, "display": {"parameters": [["q", "quantity"]], "type": "quantity", "language": "jme", "definition": "string(siground(q,4))"}, "bar": {"parameters": [["coord", "number"]], "type": "quantity", "language": "jme", "definition": "display(quantity(coord,units))"}, "applet": {"parameters": [], "type": "ggbapplet", "language": "javascript", "definition": "\n// Create the worksheet. \n// This function returns an object with a container `element` and a `promise` resolving to a GeoGebra applet.\nvar params = {\n  material_id: 'ftkm8mfx',\n  //alternate method, load from file.\n  //filename: \"resources/question-resources/centroid-t-r.ggb\",\n  //width:400,\n  //height:300\n  // was geogebra_applet('ftkm8mfx',[['A',A],['B',B],['C',C]])\n}\n\nvar result = Numbas.extensions.geogebra.createGeogebraApplet(params);\n\n// Once the applet has loaded, run some commands to manipulate the worksheet.\nresult.promise.then(function(d) {\n  var app = d.app;\n  question.applet = d;\n  \n  \nfunction setGGBPoint(name) {\n    // moves point in GGB to location of Numbas Vector Variable\n    var pt = question.scope.evaluate(name).value\n    app.setFixed(name,false,false);\n    app.setCoords(name, pt[0], pt[1]);\n    app.setFixed(name,true,true);\n  }\n\n  setGGBPoint(\"A\");\n  setGGBPoint(\"B\");\n  setGGBPoint(\"C\");\n  setGGBPoint(\"D\");\n  app.setVisible(\"Centroid\",false);\n  \n});\n\n// This function returns the result of `createGeogebraApplet` as an object \n// with the JME data type 'ggbapplet', which can be substituted into the question's content.\nreturn new Numbas.jme.types.ggbapplet(result);"}}, "preamble": {"js": "question.signals.on('adviceDisplayed',function() {\n   try{\n    var app = question.applet.app;\n    app.setVisible(\"Centroid\",true);\n  }\n  catch(err){}  \n})\n\n\n\n", "css": "table.centroid{margin-left:0;}\n\ntable.centroid td {\n  width:6em; \n  vertical-align:center; \n  text-align:center;}\ntable.centroid *.underline {border-bottom: 2px solid black;}\n\n"}, "parts": [{"type": "spreadsheet", "useCustomName": true, "customName": "Centroid Table", "marks": "36", "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": true, "showFeedbackIcon": true, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "settings": {"initial_sheet": "blank_sheet", "correct_answer": "answer_sheet", "disable_ranges": "[\"A1:F1\", \"A1:A5\", \"C5:D5\"]", "mark_ranges": "[\"$A_i$\": \"B2:B4\", \"$\\\\bar{x}$\": \"C2:C4\", \"$\\\\bar{y}$\": \"D2:D4\", \"$A_i\\\\bar{x}_i$\": \"E2:E4\", \"$A_i\\\\bar{y}_i$\": \"F2:F4\",\"$A$\":\"B5\", \"$Q_y$\": \"E5\", \"$Q_x$\":\"F5\"]", "marking_method": "per_cell", "tolerance": "0.05"}}, {"type": "gapfill", "useCustomName": true, "customName": "Results", "marks": 0, "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": true, "showFeedbackIcon": true, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "prompt": "<p style=\"padding-left: 40px;\">$\\bar{x} =\\dfrac{Q_y}{A} = $&nbsp;[[0]]&nbsp;</p>\n<p style=\"padding-left: 40px;\">$\\bar{y} =\\dfrac{Q_x}{A} = $ [[1]]</p>", "gaps": [{"type": "engineering-answer", "useCustomName": true, "customName": "$\\bar{x}$", "marks": "2", "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": true, "showFeedbackIcon": true, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "settings": {"correctAnswer": "xbar", "right": "0.2", "close": "1.0", "C1": "75", "C2": "50", "C3": "25"}}, {"type": "engineering-answer", "useCustomName": true, "customName": "$\\bar{y}$", "marks": "2", "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": true, "showFeedbackIcon": true, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "settings": {"correctAnswer": "ybar", "right": "0.2", "close": "1.0", "C1": "75", "C2": "50", "C3": "25"}}], "sortAnswers": false}], "partsMode": "all", "maxMarks": 0, "objectives": [], "penalties": [], "objectiveVisibility": "always", "penaltyVisibility": "always"}]}, {"name": "Centroids by Integration", "pickingStrategy": "all-ordered", "pickQuestions": 1, "questionNames": ["", "Area under a curve", "", "Upper and lower bounds are functions"], "variable_overrides": [[], [], [], []], "questions": [{"name": "Differential Elements", "extensions": ["geogebra"], "custom_part_types": [], "resources": [], "navigation": {"allowregen": true, "showfrontpage": false, "preventleave": false, "typeendtoleave": false}, "contributors": [{"name": "William Haynes", "profile_url": "https://numbas.mathcentre.ac.uk/accounts/profile/2530/"}], "tags": ["centroids", "centroids by integration", "Mechanics", "mechanics", "Statics", "statics"], "metadata": {"description": "<p>Given a random spandrel, find the expressions for the differential elements of area and the coordinates of its centroid needed to determine the location of the&nbsp;centroid by integration.&nbsp;</p>", "licence": "Creative Commons Attribution-NonCommercial 4.0 International"}, "statement": "<p>Determine the properties of the differential strip in terms of the known coordinates.</p>\n<table style=\"margin-left: auto; margin-right: auto;\">\n<tbody>\n<tr>\n<td>{geogebra_applet('tpndhsyt',[['version',version]])}</td>\n</tr>\n</tbody>\n</table>\n<p></p>", "advice": "<p>The area of the strip, dA is the width times the height of the strip.</p>\n<p>The narrow width of the element is either $dx$ or $dy$&nbsp;</p>\n<p>The coordinates of the centroid are found by averaging the coordinates of the top and bottom of the strip.</p>", "rulesets": {}, "builtin_constants": {"e": true, "pi,\u03c0": true, "i": true, "j": false}, "constants": [], "variables": {"dA": {"name": "dA", "group": "Ungrouped variables", "definition": "expression(['y*dx',\"(y'-y)*dx\",\"(b-y)*dx\", \"(x-x')*dy\",\"x*dy\",\"(a-x)*dy\"][version-1\n])", "description": "", "templateType": "anything", "can_override": false}, "ybar": {"name": "ybar", "group": "Ungrouped variables", "definition": "expression([\"y/2\",\"(y+y')/2\",\"(y+b)/2\",\"y\",\"y\",\"y\"][version-1])", "description": "", "templateType": "anything", "can_override": false}, "xbar": {"name": "xbar", "group": "Ungrouped variables", "definition": "expression([\"x\",\"x\",\"x\",\"(x+x')/2\",\"x/2\",\"(x+a)/2\"][version-1])", "description": "", "templateType": "anything", "can_override": false}, "version": {"name": "version", "group": "Ungrouped variables", "definition": "random(1..6)", "description": "", "templateType": "anything", "can_override": false}}, "variablesTest": {"condition": "", "maxRuns": 100}, "ungrouped_variables": ["version", "dA", "xbar", "ybar"], "variable_groups": [], "functions": {}, "preamble": {"js": "", "css": ""}, "parts": [{"type": "gapfill", "useCustomName": false, "customName": "", "marks": 0, "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": true, "showFeedbackIcon": true, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "prompt": "<p style=\"padding-left: 40px;\">$dA$ =&nbsp;[[0]]</p>\n<p style=\"padding-left: 40px;\">$\\bar{x}_{el}$ =&nbsp;[[1]]&nbsp;</p>\n<p style=\"padding-left: 40px;\">$\\bar{y}_{el}$ = [[2]]&nbsp;&nbsp;</p>", "gaps": [{"type": "jme", "useCustomName": true, "customName": "da", "marks": "10", "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": true, "showFeedbackIcon": true, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "answer": "{dA}", "showPreview": true, "checkingType": "absdiff", "checkingAccuracy": 0.001, "failureRate": 1, "vsetRangePoints": 5, "vsetRange": [0, 1], "checkVariableNames": false, "singleLetterVariables": false, "allowUnknownFunctions": true, "implicitFunctionComposition": false, "caseSensitive": false, "valuegenerators": []}, {"type": "jme", "useCustomName": true, "customName": "xbar", "marks": "10", "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": true, "showFeedbackIcon": true, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "answer": "{xbar}", "showPreview": true, "checkingType": "absdiff", "checkingAccuracy": 0.001, "failureRate": 1, "vsetRangePoints": 5, "vsetRange": [0, 1], "checkVariableNames": false, "singleLetterVariables": false, "allowUnknownFunctions": true, "implicitFunctionComposition": false, "caseSensitive": false, "valuegenerators": []}, {"type": "jme", "useCustomName": true, "customName": "ybar", "marks": "10", "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": true, "showFeedbackIcon": true, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "answer": "{ybar}", "showPreview": true, "checkingType": "absdiff", "checkingAccuracy": 0.001, "failureRate": 1, "vsetRangePoints": 5, "vsetRange": [0, 1], "checkVariableNames": false, "singleLetterVariables": false, "allowUnknownFunctions": true, "implicitFunctionComposition": false, "caseSensitive": false, "valuegenerators": []}], "sortAnswers": false}], "partsMode": "all", "maxMarks": 0, "objectives": [], "penalties": [], "objectiveVisibility": "always", "penaltyVisibility": "always"}, {"name": "Area under a curve by integration", "extensions": ["geogebra", "quantities"], "custom_part_types": [{"source": {"pk": 19, "author": {"name": "William Haynes", "pk": 2530}, "edit_page": "/part_type/19/edit"}, "name": "Engineering Accuracy with units", "short_name": "engineering-answer", "description": "<p>A value with units marked right if within an adjustable % error of the correct value. &nbsp;Marked close if within a wider margin of error.</p>", "help_url": "", "input_widget": "string", "input_options": {"correctAnswer": "siground(settings['correctAnswer'],4)", "hint": {"static": true, "value": ""}, "allowEmpty": {"static": true, "value": true}}, "can_be_gap": true, "can_be_step": true, "marking_script": "mark:\nswitch( \n  right and good_units and right_sign, add_credit(1.0,'Correct.'),\n  right and good_units and not right_sign, add_credit(settings['C2'],'Wrong sign.'),\n  right and right_sign and not good_units, add_credit(settings['C2'],'Correct value, but wrong or missing units.'),\n  close and good_units, add_credit(settings['C1'],'Close.'),\n  close and not good_units, add_credit(settings['C3'],'Answer is close, but wrong or missing units.'),\n  incorrect('Wrong answer.')\n)\n\ninterpreted_answer:\nqty(student_scalar, student_units)\n\n\n\ncorrect_quantity:\nsettings[\"correctAnswer\"]\n\n\n\ncorrect_units:\nunits(correct_quantity)\n\n\nallowed_notation_styles:\n[\"plain\",\"en\"]\n\nmatch_student_number:\nmatchnumber(studentAnswer,allowed_notation_styles)\n\nstudent_scalar:\nmatch_student_number[1]\n\nstudent_units:\nreplace_regex('ohms','ohm',\n  replace_regex('\u00b0', ' deg',\n    replace_regex('-', ' ' ,\n      studentAnswer[len(match_student_number[0])..len(studentAnswer)])),\"i\")\n\ngood_units:\ntry(\ncompatible(quantity(1, student_units),correct_units),\nmsg,\nfeedback(msg);false)\n\n\nstudent_quantity:\nswitch(not good_units, \n       student_scalar * correct_units, \n       not right_sign,\n       -quantity(student_scalar, student_units),\n       quantity(student_scalar,student_units)\n)\n  \n\n\npercent_error:\ntry(\nscalar(abs((correct_quantity - student_quantity)/correct_quantity))*100  \n,msg,\nif(student_quantity=correct_quantity,0,100))\n   \n\nright:\npercent_error <= settings['right']\n\n\nclose:\nright_sign and percent_error <= settings['close']\n\nright_sign:\nsign(student_scalar) = sign(correct_quantity)", "marking_notes": [{"name": "mark", "description": "This is the main marking note. It should award credit and provide feedback based on the student's answer.", "definition": "switch( \n  right and good_units and right_sign, add_credit(1.0,'Correct.'),\n  right and good_units and not right_sign, add_credit(settings['C2'],'Wrong sign.'),\n  right and right_sign and not good_units, add_credit(settings['C2'],'Correct value, but wrong or missing units.'),\n  close and good_units, add_credit(settings['C1'],'Close.'),\n  close and not good_units, add_credit(settings['C3'],'Answer is close, but wrong or missing units.'),\n  incorrect('Wrong answer.')\n)"}, {"name": "interpreted_answer", "description": "A value representing the student's answer to this part.", "definition": "qty(student_scalar, student_units)\n\n"}, {"name": "correct_quantity", "description": "", "definition": "settings[\"correctAnswer\"]\n\n"}, {"name": "correct_units", "description": "", "definition": "units(correct_quantity)\n"}, {"name": "allowed_notation_styles", "description": "", "definition": "[\"plain\",\"en\"]"}, {"name": "match_student_number", "description": "", "definition": "matchnumber(studentAnswer,allowed_notation_styles)"}, {"name": "student_scalar", "description": "", "definition": "match_student_number[1]"}, {"name": "student_units", "description": "<p>Modify&nbsp;the&nbsp;unit portion of&nbsp;the student's answer by</p>\n<p>1. replacing \"ohms\" with \"ohm\" &nbsp;case insensitive</p>\n<p>2.&nbsp;replacing '-'&nbsp;with ' '&nbsp;</p>\n<p>3. replacing '&deg;' with ' deg'&nbsp;</p>\n<p>to allow answers like 10 ft-lb and 30&deg;</p>", "definition": "replace_regex('ohms','ohm',\n  replace_regex('\u00b0', ' deg',\n    replace_regex('-', ' ' ,\n      studentAnswer[len(match_student_number[0])..len(studentAnswer)])),\"i\")"}, {"name": "good_units", "description": "", "definition": "try(\ncompatible(quantity(1, student_units),correct_units),\nmsg,\nfeedback(msg);false)\n"}, {"name": "student_quantity", "description": "<p>This fixes the student answer for two common errors. &nbsp;</p>\n<p>If student_units are wrong&nbsp;&nbsp;- replace with correct units</p>\n<p>If student_scalar has the wrong sign - replace with right sign</p>\n<p>If student makes both errors, only one gets fixed.</p>", "definition": "switch(not good_units, \n       student_scalar * correct_units, \n       not right_sign,\n       -quantity(student_scalar, student_units),\n       quantity(student_scalar,student_units)\n)\n  \n"}, {"name": "percent_error", "description": "", "definition": "try(\nscalar(abs((correct_quantity - student_quantity)/correct_quantity))*100  \n,msg,\nif(student_quantity=correct_quantity,0,100))\n   "}, {"name": "right", "description": "", "definition": "percent_error <= settings['right']\n"}, {"name": "close", "description": "<p>Only marked close if the student actually has the right sign.</p>", "definition": "right_sign and percent_error <= settings['close']"}, {"name": "right_sign", "description": "", "definition": "sign(student_scalar) = sign(correct_quantity) "}], "settings": [{"name": "correctAnswer", "label": "Correct Quantity.", "help_url": "", "hint": "The correct answer given as a JME quantity.", "input_type": "code", "default_value": "", "evaluate": true}, {"name": "right", "label": "% Accuracy for right.", "help_url": "", "hint": "Question will be considered correct if the scalar part of the student's answer is within this % of correct value.", "input_type": "code", "default_value": "0.2", "evaluate": true}, {"name": "close", "label": "% Accuracy for close.", "help_url": "", "hint": "Question will be considered close if the scalar part of the student's answer is within this % of correct value.", "input_type": "code", "default_value": "1.0", "evaluate": true}, {"name": "C1", "label": "Close with units.", "help_url": "", "hint": "Partial Credit for close value with appropriate units. &nbsp;if correct answer is 100 N and close is &plusmn;1%,<br />99 &nbsp;N is accepted.", "input_type": "percent", "default_value": "75"}, {"name": "C2", "label": "No units or wrong sign", "help_url": "", "hint": "Partial credit for forgetting units or using wrong sign.<br />If the correct answer is 100 N, both 100 and -100 N are accepted.", "input_type": "percent", "default_value": "50"}, {"name": "C3", "label": "Close, no units.", "help_url": "", "hint": "Partial Credit for close value but forgotten units.<br />This value would be close&nbsp;if the expected units were provided. &nbsp;If the correct answer is 100 N, and close is &plusmn;1%,<br />99 is accepted.", "input_type": "percent", "default_value": "25"}], "public_availability": "always", "published": true, "extensions": ["quantities"]}], "resources": ["question-resources/centroid-integration.ggb"], "navigation": {"allowregen": true, "showfrontpage": false, "preventleave": false, "typeendtoleave": false}, "contributors": [{"name": "William Haynes", "profile_url": "https://numbas.mathcentre.ac.uk/accounts/profile/2530/"}], "tags": ["Area", "area", "definite integral", "Mechanics", "mechanics", "Statics", "statics"], "metadata": {"description": "<p>Find roots and the area under a parabola</p>", "licence": "Creative Commons Attribution-NonCommercial 4.0 International"}, "statement": "<p>Given the function $\\color{darkred}{y=\\simplify[!noleadingminus,unitfactor]{{A} x^2 + {B} x + {C}}}$, determine the area under the curve from the $y$-axis to the point where the curve crosses the positive $x$-axis. &nbsp;The $x$- and $y$- coordinates are in [{units}].&nbsp;</p>\n<table style=\"margin-right: auto; margin-left: auto;\">\n<tbody>\n<tr>\n<td>{applet()}</td>\n</tr>\n</tbody>\n</table>\n<ol>\n<li>Determine $a$ and $h$, where the curve crosses the axes.</li>\n<li>Use integration to determine the area of the shaded region.</li>\n</ol>\n<p>You may not use a graphing calculator or other technology to solve this problem.</p>", "advice": "<ol>\n<li>To find the point where the curve crosses the <em>y</em>-axis, set <em>x</em> = 0 and solve for <em>y</em>.</li>\n<li>To find the point where the curve crosses the positive <em>x</em>-axis, set <em>y</em> to zero and solve for <em>x</em> using the quadratic formula. Take the positive root.</li>\n<li>To find the area under the curve, divide the shaded area into vertical differential strips where&nbsp;$dA = y\\, dx$ then integrate between the horizontal limits to find the area.</li>\n</ol>\n<p style=\"padding-left: 30px;\">$\\begin{align}A &amp;= \\int dA \\\\&amp;= \\int_0^a y\\,dx \\\\&amp;= \\int_0^a(\\simplify[!noleadingminus,unitfactor]{{A} x^2 + {B} x + {C}})\\, dx\\\\&amp; = \\left[&nbsp;\\simplify[unitfactor,collectnumbers]{{A}&nbsp;x^3/3&nbsp;+ {B} x^2/2 + {C}x}\\right]_0^\\var{scalar(siground(root1,4))}\\\\&amp;=\\var{siground(area,4)}\\end{align}$</p>", "rulesets": {}, "builtin_constants": {"e": true, "pi,\u03c0": true, "i": true, "j": false}, "constants": [], "variables": {"area": {"name": "area", "group": "Ungrouped variables", "definition": "let(x,scalar(root1), qty(A x^3/3 + B x^2/2 + C x,units)) qty(units)", "description": "", "templateType": "anything", "can_override": false}, "A": {"name": "A", "group": "Ungrouped variables", "definition": "random(-0.5..-2#0.5)", "description": "", "templateType": "anything", "can_override": false}, "debug": {"name": "debug", "group": "Ungrouped variables", "definition": "false", "description": "", "templateType": "anything", "can_override": false}, "C": {"name": "C", "group": "Ungrouped variables", "definition": "random(0..3)+0.5", "description": "", "templateType": "anything", "can_override": false}, "B": {"name": "B", "group": "Ungrouped variables", "definition": "random(1..4)", "description": "", "templateType": "anything", "can_override": false}, "units": {"name": "units", "group": "Ungrouped variables", "definition": "random('in','ft','mm','cm')", "description": "", "templateType": "anything", "can_override": false}, "root1": {"name": "root1", "group": "Ungrouped variables", "definition": "qty((-b - sqrt(b^2-4 a c))/(2 a),units)", "description": "", "templateType": "anything", "can_override": false}}, "variablesTest": {"condition": "", "maxRuns": 100}, "ungrouped_variables": ["A", "B", "C", "root1", "area", "units", "debug"], "variable_groups": [], "functions": {"applet": {"parameters": [], "type": "ggbapplet", "language": "javascript", "definition": "\n// Create the worksheet. \n// This function returns an object with a container `element` and a `promise` resolving to a GeoGebra applet.\nvar params = {\n  filename: 'resources/question-resources/centroid-integration.ggb',\n  width: 300,\n  height: 300\n  // was {geogebra_applet('nuhzkzqp',[['a',A],['b',B],['c',C]])}\n}\n\nvar result = Numbas.extensions.geogebra.createGeogebraApplet(params);\n\n// Once the applet has loaded, run some commands to manipulate the worksheet.\nresult.promise.then(function(d) {\n  var app = d.app;\n  question.applet = d;\n  \n function setGGBNumber(name) {\n    // Sets number in GGB to a Numbas Variable\n    var n = question.scope.evaluate(name).value;\n    app.setValue(name,n);\n  }\n  \nfunction setGGBPoint(name) {\n    // moves point in GGB to location of Numbas Vector Variable\n    var pt = question.scope.evaluate(name).value\n    app.setFixed(name,false,false);\n    app.setCoords(name, pt[0], pt[1]);\n    app.setFixed(name,true,true);\n  }\n\n  setGGBPoint(\"a\");\n  setGGBPoint(\"b\");\n  setGGBPoint(\"c\");\n  app.setGridVisible(false);\n  app.recalculateEnvironments();\n\n  \n});\n\n// This function returns the result of `createGeogebraApplet` as an object \n// with the JME data type 'ggbapplet', which can be substituted into the question's content.\nreturn new Numbas.jme.types.ggbapplet(result);"}}, "preamble": {"js": "", "css": ""}, "parts": [{"type": "gapfill", "useCustomName": false, "customName": "", "marks": 0, "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": true, "showFeedbackIcon": true, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "prompt": "<p style=\"padding-left: 40px;\">$h$ =&nbsp;[[0]] <span data-jme-visible=\"debug\">{qty(C,units)}</span></p>\n<p style=\"padding-left: 40px;\">$a$ =&nbsp;[[1]] <span data-jme-visible=\"debug\">{siground(root1,4)}</span></p>\n<p>Set up and evaluate&nbsp;the integral equation below to find the area under the curve.</p>\n<p style=\"padding-left: 40px;\">$\\begin{align} A &amp;= \\int{dA}\\\\&amp;=\\int_0^a y\\, dx \\\\ \\vdots\\end{align}$</p>\n<p style=\"padding-left: 40px;\">$A$ = [[2]] <span data-jme-visible=\"debug\">&nbsp;{siground(area,4)}</span></p>", "gaps": [{"type": "engineering-answer", "useCustomName": true, "customName": "h", "marks": "5", "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": true, "showFeedbackIcon": true, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "settings": {"correctAnswer": "qty(C,units)", "right": "0.2", "close": "1.0", "C1": "75", "C2": "50", "C3": "25"}}, {"type": "engineering-answer", "useCustomName": true, "customName": "a", "marks": "5", "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": true, "showFeedbackIcon": true, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "settings": {"correctAnswer": "root1", "right": "0.2", "close": "1.0", "C1": "75", "C2": "50", "C3": "25"}}, {"type": "engineering-answer", "useCustomName": true, "customName": "Area", "marks": "10", "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": true, "showFeedbackIcon": true, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "settings": {"correctAnswer": "area", "right": "0.2", "close": "1.0", "C1": "75", "C2": "50", "C3": "25"}}], "sortAnswers": false}], "partsMode": "all", "maxMarks": 0, "objectives": [], "penalties": [], "objectiveVisibility": "always", "penaltyVisibility": "always"}, {"name": "Centroids by integration ", "extensions": ["geogebra"], "custom_part_types": [], "resources": [], "navigation": {"allowregen": true, "showfrontpage": false, "preventleave": false, "typeendtoleave": false}, "contributors": [{"name": "William Haynes", "profile_url": "https://numbas.mathcentre.ac.uk/accounts/profile/2530/"}], "tags": ["area under curve", "centroidal coordinates", "centroids by integration", "first moment of area", "integration", "Mechanics", "mechanics", "Statics", "statics"], "metadata": {"description": "<p>Find the area, first moment of area, and coordinates of a general spandrel. &nbsp;The area&nbsp;may be above or below the function.</p>", "licence": "Creative Commons Attribution-NonCommercial 4.0 International"}, "statement": "<p>Use integration with {if(Vertical=1,'vertical','horizontal')} strips to determine the area of the spandrel bounded by the function $\\color{#CC0000}{y = f(x) = h - k \\simplify[all,fractionnumbers]{x^{n}}}$ and $\\var{if(Above=1, 'the lines $y=h$ and $x=b$','the $x$- and $y$-axes')}$, and also find the coordinates of its centroid. Note: $b$ and $h$ are constants.</p>\n<table style=\"margin-left: auto; margin-right: auto;\">\n<tbody>\n<tr>\n<td>{applet}</td>\n</tr>\n</tbody>\n</table>", "advice": "<div data-jme-visible=\"vertical = 0\" style=\"background: yellow; border: 1px solid black; padding: 1em; margin: 1em;\">\n<p>Note: The solutions below is&nbsp;for Vertical Strips. &nbsp;</p>\n<p>The procedure&nbsp;for horizontal strips is similar, but with these strip properties and limits:</p>\n<p>Strip properties: &nbsp;<span data-jme-visible=\"Above = 1\">$dA = (b-x)\\,dy$, $\\bar{x}_{el} = \\dfrac{x+b}{y}$, $\\bar{y}_{el} = y&nbsp;$</span><span>&nbsp;</span><span data-jme-visible=\"above = 0\">$dA = x&nbsp;\\,dy$, $\\bar{x}_{el} = x/2$, $\\bar{y}_{el} =y$</span></p>\n<p>Limits: &nbsp;$x= 0 \\text{ to } h$</p>\n<p>You will get the same results for $A, Q_x, Q_y, \\bar{x} \\text{ and } \\bar{y}$, which ever strips you choose.</p>\n</div>\n<p>1. Bounding function: $y = f(x) = h - k \\simplify[all,fractionnumbers]{x^{n}}$</p>\n<p>2. Constant&nbsp;$k$ in terms of $b$:&nbsp;at $x=b, y=0&nbsp;\\therefore&nbsp;h - k&nbsp;\\simplify[all,fractionnumbers]{b^{n}} &nbsp;= 0 \\therefore k = \\dfrac{h}{\\simplify[all,fractionnumbers]{b^{n}}}$</p>\n<p>3. Strip properties: &nbsp;<span data-jme-visible=\"Above = 0\">$dA = y\\,dx$, $\\bar{x}_{el} = x$, $\\bar{y}_{el} = y/2$</span><span>&nbsp;</span><span data-jme-visible=\"above = 1\">$dA = (h-y)\\,dx$, $\\bar{x}_{el} = x$, $\\bar{y}_{el} = (h+y)/2$</span></p>\n<p>4. Limits: &nbsp;$x= 0 \\text{ to } b$</p>\n<p>5. Area under the curve:</p>\n<p><span data-jme-visible=\"above=0\">$\\begin{align} A &amp;= \\int dA\\\\&amp;= \\int_0^b y\\, dx\\\\&amp;= \\int_0^b &nbsp;(h - k \\simplify[all,fractionnumbers]{x^{n}})\\, dx\\\\&amp;= \\left[ hx - k \\dfrac{\\simplify[all,fractionnumbers]{x^{n+1}}}{\\simplify[all,fractionnumbers]{{n+1}}}\\right]_0^b\\\\&amp;= \\left[ hb - \\left(\\dfrac{h}{\\simplify[all,fractionnumbers]{b^{n}}}\\right)&nbsp;\\dfrac{\\simplify[all,fractionnumbers]{b^{n+1}}}{\\simplify[all,fractionnumbers]{{n+1}}}\\right]\\\\&amp;=hb-\\dfrac{hb}{\\simplify[all,fractionnumbers]{{n}+1}}\\\\&amp;=\\var[all,fractionnumbers]{{n}/({n}+1)} h b\\end{align}$</span></p>\n<p><span data-jme-visible=\"above=1\">$\\begin{align} A &amp;= \\int dA\\\\&amp;= \\int_0^b (h-y)\\, dx\\\\&amp;= \\int_0^b &nbsp;h - (h - k \\simplify[all,fractionnumbers]{x^{n}})\\, dx\\\\&amp;=\\int_0^bk \\simplify[all,fractionnumbers]{x^{n}}dx\\\\&amp;= \\left[k \\dfrac{\\simplify[all,fractionnumbers]{x^{n+1}}}{\\simplify[all,fractionnumbers]{{n+1}}}\\right]_0^b\\\\&amp;= \\left[ \\left(\\dfrac{h}{\\simplify[all,fractionnumbers]{b^{n}}}\\right)&nbsp;\\dfrac{\\simplify[all,fractionnumbers]{b^{n+1}}}{\\simplify[all,fractionnumbers]{{n+1}}}\\right]\\\\&amp;=\\dfrac{hb}{\\simplify[all,fractionnumbers]{{n}+1}}\\\\&amp;=\\var[all,fractionnumbers]{1/({n}+1)} h b\\end{align}$</span></p>\n<p>6. $Q_x$ and $Q_y$ &nbsp;Perform similar integrations to get:&nbsp;</p>\n<p><span data-jme-visible=\"above=0\">$Q_x = \\int \\bar{y}_{el}\\,dA &nbsp;= \\simplify[all,simplifyfractions,fractionnumbers]{{n}^2&nbsp;/(2{n}^2+3{n}+1) h^2b} &nbsp;\\qquad&nbsp;Q_y = \\int \\bar{x}_{el}\\,dA &nbsp;= \\simplify[all,fractionnumbers,simplifyfractions]{{n}/(2{n}+4)} hb^2$</span></p>\n<p><span data-jme-visible=\"above=1\">$Q_x = \\int \\bar{y}_{el}\\,dA &nbsp;= \\simplify[all,simplifyfractions,fractionnumbers]{(3{n}+1)/(2({n}+1)(2{n}+1))}h^2b&nbsp;\\qquad&nbsp;Q_y = \\int \\bar{x}_{el}\\,dA &nbsp;= \\simplify[all,fractionnumbers,simplifyfractions]{1/({n}+2)} hb^2$</span></p>\n<p>7. Centroid:</p>\n<p><span data-jme-visible=\"above=0\">$\\bar{x} = \\dfrac{Q_y}{A} = \\dfrac{\\simplify[all,fractionnumbers,simplifyfractions]{{n}/(2{n}+4)} hb^2}{\\var[all,fractionnumbers]{{n}/({n}+1)} h b} = \\simplify[all,collectnumbers]{({n}+1)/(2{n}+4)}b&nbsp;\\qquad&nbsp;\\bar{y} = \\dfrac{Q_x}{A} = \\dfrac{\\simplify[all,fractionnumbers,simplifyfractions]{{n^2}/(({n}+1)(2{n}+1))} h^2b}{\\var[all,fractionnumbers]{{n}/({n}+1)} h b}&nbsp;= \\simplify[all,collectnumbers,simplifyfractions]{{n}/(2{n}+1)}h&nbsp;$</span></p>\n<p><span data-jme-visible=\"above=1\">$\\bar{x} = \\dfrac{Q_y}{A} = \\dfrac{\\simplify[all,fractionnumbers,simplifyfractions]{1/({n}+2)} hb^2}{\\var[all,fractionnumbers]{1/({n}+1)} h b} = \\simplify[all,collectnumbers]{({n}+1)/({n}+2)}b&nbsp;\\qquad&nbsp;\\bar{y} = \\dfrac{Q_x}{A} = \\dfrac{\\simplify[all,simplifyfractions,fractionnumbers]{(3{n}+1)/(2({n}+1)(2{n}+1))}h^2b}{\\var[all,fractionnumbers]{1/({n}+1)} h b}&nbsp;= \\simplify[all,collectnumbers,simplifyfractions]{(3{n}+1)/(4{n}+2)}h&nbsp;$</span></p>", "rulesets": {}, "builtin_constants": {"e": true, "pi,\u03c0": true, "i": true, "j": false}, "constants": [], "variables": {"Qy": {"name": "Qy", "group": "answers", "definition": " simplify(substitute([\"n\" :n],\n if(Above=1, \n    expression('h b^2 / (n+2)'),\n    expression('h b^2 n / (2 n + 4 )'))),\"basic,collectNumbers,simplifyFractions,constantsFirst\")", "description": "", "templateType": "anything", "can_override": false}, "ybar_el": {"name": "ybar_el", "group": "answers", "definition": "expression(['y','y/2','y','(h+y)/2'][version])", "description": "", "templateType": "anything", "can_override": false}, "xbar": {"name": "xbar", "group": "answers", "definition": " simplify(substitute([\"n\" :n],\n  if(Above=1,\n    expression('b* (n+1)/(n+2)'),\n    expression('b * (n+1)/(2n+4)'))),\"basic,collectNumbers,simplifyFractions,cancelTerms\")", "description": "<p>expression(\"(\"+ string(Qy) +\")/(\"+ string(area) +\")\")</p>", "templateType": "anything", "can_override": false}, "debug": {"name": "debug", "group": "inputs", "definition": "false", "description": "", "templateType": "anything", "can_override": false}, "k": {"name": "k", "group": "inputs", "definition": "expression(if(vertical=1,'h/b^n','b/h^(1/n)'))", "description": "", "templateType": "anything", "can_override": false}, "Qx": {"name": "Qx", "group": "answers", "definition": " simplify(substitute([\"n\" :n],\n  if(Above=1,\n    expression('(b h^2 /2)(3n+1)/((n+1) (2n+1))'),\n    expression('h^2 b n^2/((n+1)(2n+1))'))),\"basic,collectNumbers,simplifyFractions,constantsFirst\")", "description": "", "templateType": "anything", "can_override": false}, "Above": {"name": "Above", "group": "inputs", "definition": "random(0,1)", "description": "<p>area above or below the curve?</p>", "templateType": "anything", "can_override": false}, "version": {"name": "version", "group": "inputs", "definition": "2 above + vertical\n", "description": "<p>0 = below horizontal</p>\n<p>1 = below vertical</p>\n<p>2 = above horizontal</p>\n<p>3 = above vertical</p>\n<p>horizontal strips not implemented</p>", "templateType": "anything", "can_override": false}, "Vertical": {"name": "Vertical", "group": "inputs", "definition": "random(0,1)", "description": "<p>0 = horizontal strips</p>\n<p>1 = vertical strips? &nbsp;Horizontal strips not currently implemented.</p>\n<p></p>\n<p>&nbsp;Can't figure out how to pass a boolean to geogebra, so using {0,1} instead. Only exponents &lt; 2 can be horizontal &nbsp;</p>", "templateType": "anything", "can_override": false}, "ybar": {"name": "ybar", "group": "answers", "definition": " simplify(substitute([\"n\" :n],if(Above=1,\n    expression('h * (3 n +1)/(4 n+2)'),\n    expression('h n / (2 n+1)'))),\"basic,collectNumbers,simplifyFractions\")", "description": "<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</p>", "templateType": "anything", "can_override": false}, "area": {"name": "area", "group": "answers", "definition": "simplify(substitute([\"n\" :n], if(Above=1,\n    expression('b h / (n+1)'),\n    expression('b h n /(n +1)'))),\"basic,collectNumbers,simplifyFractions,cancelTerms\")", "description": "<p>ok</p>", "templateType": "anything", "can_override": false}, "lower_limit": {"name": "lower_limit", "group": "answers", "definition": "0", "description": "", "templateType": "anything", "can_override": false}, "n": {"name": "n", "group": "inputs", "definition": "random(1/3,1/2,1,3/2,2,3)", "description": "<p>the exponent of the function (1-kx^n) (0.5 .. 5#0.5)</p>", "templateType": "anything", "can_override": false}, "upper_limit": {"name": "upper_limit", "group": "answers", "definition": "if(Vertical=1,'b','h')", "description": "", "templateType": "anything", "can_override": false}, "xbar_el": {"name": "xbar_el", "group": "answers", "definition": "expression(['x/2','x','(b+x)/2','x'][version])", "description": "", "templateType": "anything", "can_override": false}, "dA": {"name": "dA", "group": "answers", "definition": "expression(['x dy','y dx','(b-x) dy','(h-y) dx'][version])", "description": "", "templateType": "anything", "can_override": false}, "applet": {"name": "applet", "group": "Ungrouped variables", "definition": "geogebra_applet('bqnqgpfp',[['n',n],['h',random(1,1.5)],['b',random(0.8,1.3)],['Above', above],['Vertical',vertical]])", "description": "", "templateType": "anything", "can_override": false}}, "variablesTest": {"condition": "", "maxRuns": 100}, "ungrouped_variables": ["applet"], "variable_groups": [{"name": "inputs", "variables": ["n", "version", "Vertical", "Above", "k", "debug"]}, {"name": "answers", "variables": ["dA", "xbar_el", "ybar_el", "upper_limit", "lower_limit", "area", "Qy", "xbar", "ybar", "Qx"]}], "functions": {}, "preamble": {"js": "", "css": ""}, "parts": [{"type": "gapfill", "useCustomName": true, "customName": "Bounding function", "marks": 0, "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": true, "showFeedbackIcon": true, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "prompt": "<p>The bounding funtion&nbsp;contains a constant $k$ which can be expressed in terms of&nbsp;$b$ and $h$. &nbsp;Determine the value of $k$ in terms of <em>b</em> and <em>h&nbsp;</em>by substituting in the coordinates of a point which is on the curve into the bounding function.</p>\n<p style=\"padding-left: 40px;\">$k$ =&nbsp;[[0]] <span data-jme-visible=\"debug\">{k}</span></p>\n<p></p>", "gaps": [{"type": "jme", "useCustomName": true, "customName": "k", "marks": "5", "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": true, "showFeedbackIcon": true, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "answer": "h/b^{n}", "showPreview": true, "checkingType": "absdiff", "checkingAccuracy": 0.001, "failureRate": 1, "vsetRangePoints": 5, "vsetRange": [0, 1], "checkVariableNames": false, "singleLetterVariables": false, "allowUnknownFunctions": true, "implicitFunctionComposition": false, "caseSensitive": false, "valuegenerators": [{"name": "b", "value": ""}, {"name": "h", "value": ""}]}], "sortAnswers": false}, {"type": "gapfill", "useCustomName": true, "customName": "Strip", "marks": 0, "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": true, "showFeedbackIcon": true, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "prompt": "<p>Determine the area of the rectangular differential strip.</p>\n<p style=\"padding-left: 40px;\">$dA$ =&nbsp;[[0]] <span data-jme-visible=\"debug\">{da}</span></p>\n<p>Determine expressions for the coordinates of the centroid of the strip.</p>\n<p style=\"padding-left: 40px;\">$\\bar{x}_{el} = $ [[1]]</p>\n<p style=\"padding-left: 40px;\">$\\bar{y}_{el} = $&nbsp;[[2]]&nbsp;&nbsp;<span data-jme-visible=\"debug\">xbar= {xbar_el} &nbsp;ybar = {ybar_el}</span></p>", "gaps": [{"type": "jme", "useCustomName": true, "customName": "$dA$", "marks": "5", "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": true, "showFeedbackIcon": true, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "answer": "{dA}", "showPreview": true, "checkingType": "absdiff", "checkingAccuracy": 0.001, "failureRate": 1, "vsetRangePoints": 5, "vsetRange": [0, 1], "checkVariableNames": false, "singleLetterVariables": false, "allowUnknownFunctions": true, "implicitFunctionComposition": false, "caseSensitive": false, "valuegenerators": []}, {"type": "jme", "useCustomName": true, "customName": "$\\bar{x}$", "marks": "5", "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": true, "showFeedbackIcon": true, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "answer": "{xbar_el}", "showPreview": true, "checkingType": "absdiff", "checkingAccuracy": 0.001, "failureRate": 1, "vsetRangePoints": 5, "vsetRange": [0, 1], "checkVariableNames": false, "singleLetterVariables": false, "allowUnknownFunctions": true, "implicitFunctionComposition": false, "caseSensitive": false, "valuegenerators": []}, {"type": "jme", "useCustomName": true, "customName": "$\\bar{y}$", "marks": "5", "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": true, "showFeedbackIcon": true, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "answer": "{ybar_el}", "showPreview": true, "checkingType": "absdiff", "checkingAccuracy": 0.001, "failureRate": 1, "vsetRangePoints": 5, "vsetRange": [0, 1], "checkVariableNames": false, "singleLetterVariables": false, "allowUnknownFunctions": true, "implicitFunctionComposition": false, "caseSensitive": false, "valuegenerators": []}], "sortAnswers": false}, {"type": "gapfill", "useCustomName": true, "customName": "Limits", "marks": 0, "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": true, "showFeedbackIcon": true, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "prompt": "<p>Determine the limits of integration for these strips.</p>\n<p style=\"padding-left: 40px;\">Lower limit is:&nbsp;[[0]]<span data-jme-visible=\"debug\">{0}</span></p>\n<p style=\"padding-left: 40px;\">Upper limit is: [[1]]<span data-jme-visible=\"debug\">{upper_limit}</span></p>", "gaps": [{"type": "patternmatch", "useCustomName": true, "customName": "lower", "marks": "5", "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": true, "showFeedbackIcon": true, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "answer": "0", "displayAnswer": "", "matchMode": "exact", "allowEmpty": false}, {"type": "patternmatch", "useCustomName": true, "customName": "upper", "marks": "5", "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": true, "showFeedbackIcon": true, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "answer": "{upper_limit}", "displayAnswer": "", "matchMode": "exact", "allowEmpty": false}], "sortAnswers": false}, {"type": "gapfill", "useCustomName": true, "customName": "Area", "marks": 0, "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": true, "showFeedbackIcon": true, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "prompt": "<p>With the information determined above, evaluate this integral to find the area of the spandrel in terms of constants $b$ and $h$.</p>\n<p style=\"padding-left: 40px;\">$A = &nbsp;\\int dA &nbsp;= $&nbsp;[[0]]&nbsp; &nbsp;<span data-jme-visible=\"debug\">area = {area}</span></p>", "gaps": [{"type": "jme", "useCustomName": true, "customName": "area", "marks": "10", "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": true, "showFeedbackIcon": true, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "answer": "{area}", "showPreview": true, "checkingType": "absdiff", "checkingAccuracy": 0.001, "failureRate": 1, "vsetRangePoints": 5, "vsetRange": [0, 1], "checkVariableNames": false, "singleLetterVariables": true, "allowUnknownFunctions": true, "implicitFunctionComposition": false, "caseSensitive": false, "valuegenerators": []}], "sortAnswers": false}, {"type": "gapfill", "useCustomName": true, "customName": "First Moments", "marks": 0, "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": true, "showFeedbackIcon": true, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "prompt": "<p>Perform the following integrals to determine the first moments of area with respect to the x- and y-axis.</p>\n<p style=\"padding-left: 40px;\">$Q_x = \\int \\bar{y}_{el} dA =$ [[0]] <span data-jme-visible=\"debug\">{Qx}</span></p>\n<p style=\"padding-left: 40px;\">$Q_y = \\int \\bar{x}_{el} dA =$ [[1]]&nbsp;<span data-jme-visible=\"debug\">{Qy}</span></p>\n<p style=\"padding-left: 40px;\"></p>", "gaps": [{"type": "jme", "useCustomName": true, "customName": "qx", "marks": "5", "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": true, "showFeedbackIcon": true, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "answer": "{Qx}", "showPreview": true, "checkingType": "absdiff", "checkingAccuracy": 0.001, "failureRate": 1, "vsetRangePoints": 5, "vsetRange": [0, 1], "checkVariableNames": false, "singleLetterVariables": true, "allowUnknownFunctions": false, "implicitFunctionComposition": false, "caseSensitive": false, "valuegenerators": []}, {"type": "jme", "useCustomName": true, "customName": "qy", "marks": "5", "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": true, "showFeedbackIcon": true, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "answer": "{Qy}", "showPreview": true, "checkingType": "absdiff", "checkingAccuracy": 0.001, "failureRate": 1, "vsetRangePoints": 5, "vsetRange": [0, 1], "checkVariableNames": false, "singleLetterVariables": true, "allowUnknownFunctions": false, "implicitFunctionComposition": false, "caseSensitive": false, "valuegenerators": []}], "sortAnswers": false}, {"type": "gapfill", "useCustomName": true, "customName": "Centroid", "marks": 0, "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": true, "showFeedbackIcon": true, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "prompt": "<p>Use the information you found above to determine the coordinates of the centroid of the shaded spandrel.</p>\n<p style=\"padding-left: 40px;\">$\\bar{x}&nbsp;= \\dfrac{Q_y}{A} = $ &nbsp;[[0]]&nbsp;&nbsp;<span data-jme-visible=\"debug\">{xbar} &nbsp;</span></p>\n<p style=\"padding-left: 40px;\">$\\bar{y} = \\dfrac{Q_x}{A} = $ &nbsp;[[1]]&nbsp;&nbsp;<span data-jme-visible=\"debug\">{ybar} &nbsp;</span></p>", "gaps": [{"type": "jme", "useCustomName": true, "customName": "xbar", "marks": "5", "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": true, "showFeedbackIcon": true, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "answer": "{xbar}", "showPreview": true, "checkingType": "absdiff", "checkingAccuracy": 0.001, "failureRate": 1, "vsetRangePoints": 5, "vsetRange": [0, 1], "checkVariableNames": false, "singleLetterVariables": true, "allowUnknownFunctions": false, "implicitFunctionComposition": false, "caseSensitive": false, "valuegenerators": []}, {"type": "jme", "useCustomName": true, "customName": "ybar", "marks": "5", "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": true, "showFeedbackIcon": true, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "answer": "{ybar}", "showPreview": true, "checkingType": "absdiff", "checkingAccuracy": 0.001, "failureRate": 1, "vsetRangePoints": 5, "vsetRange": [0, 1], "checkVariableNames": false, "singleLetterVariables": true, "allowUnknownFunctions": false, "implicitFunctionComposition": false, "caseSensitive": false, "valuegenerators": []}], "sortAnswers": false}], "partsMode": "all", "maxMarks": 0, "objectives": [], "penalties": [], "objectiveVisibility": "always", "penaltyVisibility": "always"}, {"name": "Centroid by integration: upper and lower bounds are functions", "extensions": ["geogebra", "quantities"], "custom_part_types": [{"source": {"pk": 19, "author": {"name": "William Haynes", "pk": 2530}, "edit_page": "/part_type/19/edit"}, "name": "Engineering Accuracy with units", "short_name": "engineering-answer", "description": "<p>A value with units marked right if within an adjustable % error of the correct value. &nbsp;Marked close if within a wider margin of error.</p>", "help_url": "", "input_widget": "string", "input_options": {"correctAnswer": "siground(settings['correctAnswer'],4)", "hint": {"static": true, "value": ""}, "allowEmpty": {"static": true, "value": true}}, "can_be_gap": true, "can_be_step": true, "marking_script": "mark:\nswitch( \n  right and good_units and right_sign, add_credit(1.0,'Correct.'),\n  right and good_units and not right_sign, add_credit(settings['C2'],'Wrong sign.'),\n  right and right_sign and not good_units, add_credit(settings['C2'],'Correct value, but wrong or missing units.'),\n  close and good_units, add_credit(settings['C1'],'Close.'),\n  close and not good_units, add_credit(settings['C3'],'Answer is close, but wrong or missing units.'),\n  incorrect('Wrong answer.')\n)\n\ninterpreted_answer:\nqty(student_scalar, student_units)\n\n\n\ncorrect_quantity:\nsettings[\"correctAnswer\"]\n\n\n\ncorrect_units:\nunits(correct_quantity)\n\n\nallowed_notation_styles:\n[\"plain\",\"en\"]\n\nmatch_student_number:\nmatchnumber(studentAnswer,allowed_notation_styles)\n\nstudent_scalar:\nmatch_student_number[1]\n\nstudent_units:\nreplace_regex('ohms','ohm',\n  replace_regex('\u00b0', ' deg',\n    replace_regex('-', ' ' ,\n      studentAnswer[len(match_student_number[0])..len(studentAnswer)])),\"i\")\n\ngood_units:\ntry(\ncompatible(quantity(1, student_units),correct_units),\nmsg,\nfeedback(msg);false)\n\n\nstudent_quantity:\nswitch(not good_units, \n       student_scalar * correct_units, \n       not right_sign,\n       -quantity(student_scalar, student_units),\n       quantity(student_scalar,student_units)\n)\n  \n\n\npercent_error:\ntry(\nscalar(abs((correct_quantity - student_quantity)/correct_quantity))*100  \n,msg,\nif(student_quantity=correct_quantity,0,100))\n   \n\nright:\npercent_error <= settings['right']\n\n\nclose:\nright_sign and percent_error <= settings['close']\n\nright_sign:\nsign(student_scalar) = sign(correct_quantity)", "marking_notes": [{"name": "mark", "description": "This is the main marking note. It should award credit and provide feedback based on the student's answer.", "definition": "switch( \n  right and good_units and right_sign, add_credit(1.0,'Correct.'),\n  right and good_units and not right_sign, add_credit(settings['C2'],'Wrong sign.'),\n  right and right_sign and not good_units, add_credit(settings['C2'],'Correct value, but wrong or missing units.'),\n  close and good_units, add_credit(settings['C1'],'Close.'),\n  close and not good_units, add_credit(settings['C3'],'Answer is close, but wrong or missing units.'),\n  incorrect('Wrong answer.')\n)"}, {"name": "interpreted_answer", "description": "A value representing the student's answer to this part.", "definition": "qty(student_scalar, student_units)\n\n"}, {"name": "correct_quantity", "description": "", "definition": "settings[\"correctAnswer\"]\n\n"}, {"name": "correct_units", "description": "", "definition": "units(correct_quantity)\n"}, {"name": "allowed_notation_styles", "description": "", "definition": "[\"plain\",\"en\"]"}, {"name": "match_student_number", "description": "", "definition": "matchnumber(studentAnswer,allowed_notation_styles)"}, {"name": "student_scalar", "description": "", "definition": "match_student_number[1]"}, {"name": "student_units", "description": "<p>Modify&nbsp;the&nbsp;unit portion of&nbsp;the student's answer by</p>\n<p>1. replacing \"ohms\" with \"ohm\" &nbsp;case insensitive</p>\n<p>2.&nbsp;replacing '-'&nbsp;with ' '&nbsp;</p>\n<p>3. replacing '&deg;' with ' deg'&nbsp;</p>\n<p>to allow answers like 10 ft-lb and 30&deg;</p>", "definition": "replace_regex('ohms','ohm',\n  replace_regex('\u00b0', ' deg',\n    replace_regex('-', ' ' ,\n      studentAnswer[len(match_student_number[0])..len(studentAnswer)])),\"i\")"}, {"name": "good_units", "description": "", "definition": "try(\ncompatible(quantity(1, student_units),correct_units),\nmsg,\nfeedback(msg);false)\n"}, {"name": "student_quantity", "description": "<p>This fixes the student answer for two common errors. &nbsp;</p>\n<p>If student_units are wrong&nbsp;&nbsp;- replace with correct units</p>\n<p>If student_scalar has the wrong sign - replace with right sign</p>\n<p>If student makes both errors, only one gets fixed.</p>", "definition": "switch(not good_units, \n       student_scalar * correct_units, \n       not right_sign,\n       -quantity(student_scalar, student_units),\n       quantity(student_scalar,student_units)\n)\n  \n"}, {"name": "percent_error", "description": "", "definition": "try(\nscalar(abs((correct_quantity - student_quantity)/correct_quantity))*100  \n,msg,\nif(student_quantity=correct_quantity,0,100))\n   "}, {"name": "right", "description": "", "definition": "percent_error <= settings['right']\n"}, {"name": "close", "description": "<p>Only marked close if the student actually has the right sign.</p>", "definition": "right_sign and percent_error <= settings['close']"}, {"name": "right_sign", "description": "", "definition": "sign(student_scalar) = sign(correct_quantity) "}], "settings": [{"name": "correctAnswer", "label": "Correct Quantity.", "help_url": "", "hint": "The correct answer given as a JME quantity.", "input_type": "code", "default_value": "", "evaluate": true}, {"name": "right", "label": "% Accuracy for right.", "help_url": "", "hint": "Question will be considered correct if the scalar part of the student's answer is within this % of correct value.", "input_type": "code", "default_value": "0.2", "evaluate": true}, {"name": "close", "label": "% Accuracy for close.", "help_url": "", "hint": "Question will be considered close if the scalar part of the student's answer is within this % of correct value.", "input_type": "code", "default_value": "1.0", "evaluate": true}, {"name": "C1", "label": "Close with units.", "help_url": "", "hint": "Partial Credit for close value with appropriate units. &nbsp;if correct answer is 100 N and close is &plusmn;1%,<br />99 &nbsp;N is accepted.", "input_type": "percent", "default_value": "75"}, {"name": "C2", "label": "No units or wrong sign", "help_url": "", "hint": "Partial credit for forgetting units or using wrong sign.<br />If the correct answer is 100 N, both 100 and -100 N are accepted.", "input_type": "percent", "default_value": "50"}, {"name": "C3", "label": "Close, no units.", "help_url": "", "hint": "Partial Credit for close value but forgotten units.<br />This value would be close&nbsp;if the expected units were provided. &nbsp;If the correct answer is 100 N, and close is &plusmn;1%,<br />99 is accepted.", "input_type": "percent", "default_value": "25"}], "public_availability": "always", "published": true, "extensions": ["quantities"]}], "resources": [], "navigation": {"allowregen": true, "showfrontpage": false, "preventleave": false, "typeendtoleave": false}, "contributors": [{"name": "William Haynes", "profile_url": "https://numbas.mathcentre.ac.uk/accounts/profile/2530/"}], "tags": ["centroid", "integration", "Mechanics", "mechanics", "Statics", "statics"], "metadata": {"description": "<p>Use integration to find the centroid of an area bounded by a parabola, a sloping line, and the y-axis. &nbsp;</p>", "licence": "Creative Commons Attribution-ShareAlike 4.0 International"}, "statement": "<p>Determine the coordinates of the centroid of the shaded area bounded by the $y$-axis, a parabola passing throught the origin and point $A$, and a straight line passing through points $A$ and $B$.</p>\n<table style=\"margin-left: auto; margin-right: auto;\">\n<tbody>\n<tr>\n<td>{applet()}</td>\n</tr>\n</tbody>\n</table>\n<p></p>", "advice": "<p style=\"clear: both;\"><strong>Points</strong></p>\n<p style=\"clear: both; padding-left: 40px;\">From the diagram: &nbsp;$A = ( \\var{A[0]}, \\var{A[1]} ), B = (0, \\var{b}) $</p>\n<p style=\"clear: both;\"><strong>Bounding Functions</strong></p>\n<p style=\"padding-left: 30px;\">Parabola: $f(x) = k x^2$</p>\n<p style=\"padding-left: 60px;\">at $x=\\var{A[0]},&nbsp;f(x)=\\var{A[1]}$ , so $k = \\dfrac{\\var{A[1]}}{\\var{A[0]}^2}$</p>\n<p style=\"padding-left: 60px;\">so, $f(x) = \\var[fractionNumbers]{A[1]/A[0]^2} x^2$</p>\n<p style=\"padding-left: 30px;\">Line: $g(x) = m x + b$</p>\n<p style=\"padding-left: 60px;\">where $m = \\dfrac{(\\var{A[1]}-\\var{b})}{\\var{x}}$, and $b = \\var{b}$</p>\n<p style=\"padding-left: 60px;\">so, g(x) = $\\var[fractionNumbers]{(A[1]-b)&nbsp;/x} x + \\var{b}$</p>\n<p><strong>Strip Properties for Vertical strips</strong></p>\n<p style=\"padding-left: 30px;\">$dA = [g(x) - f(x)]\\; dx =\\left(\\simplify[all]{- {A[1]}/{A[0]}^2} x^2 +\\simplify{({A[1]}-{b}) /{x}} x + \\simplify{{b}} \\right )\\; dx $</p>\n<p style=\"padding-left: 30px;\">$\\bar{x}_{el} = x$</p>\n<p style=\"padding-left: 30px;\">$\\bar{y}_{el} = \\dfrac{g(x) + f(x)}{2}&nbsp;$</p>\n<p><strong>Integrals</strong></p>\n<p style=\"padding-left: 30px;\">$A = \\int_0^\\var{x}\\; dA =&nbsp;\\var{siground(area,4)} \\text{ units}^2$</p>\n<p style=\"padding-left: 30px;\">$Q_y = \\int_0^\\var{x} \\bar{x}_{el} \\; dA = \\var{siground(Qy,4)} \\text{ units}^3$</p>\n<p style=\"padding-left: 30px;\">$Q_x = \\int_0^\\var{x}&nbsp;\\bar{y}_{el} \\; dA = \\var{siground(Qx,4)}\\text{ units}^3$</p>\n<p><strong>Centroid</strong></p>\n<p style=\"padding-left: 30px;\">&nbsp;$\\bar{x} = \\dfrac{Q_y}{A} = \\var{siground(xbar,4)}$&nbsp;&nbsp;units</p>\n<p style=\"padding-left: 30px;\"><strong></strong>&nbsp;$\\bar{y} = \\dfrac{Q_x}{A} = \\var{siground(ybar,4)}$&nbsp;&nbsp;units</p>", "rulesets": {}, "builtin_constants": {"e": true, "pi,\u03c0": true, "i": true, "j": false}, "constants": [], "variables": {"A": {"name": "A", "group": "Ungrouped variables", "definition": "vector(random(1..10),random(3..12))", "description": "", "templateType": "anything", "can_override": false}, "b": {"name": "b", "group": "Ungrouped variables", "definition": "random(0..10)", "description": "<p>y&nbsp;component of point B</p>", "templateType": "anything", "can_override": false}, "k": {"name": "k", "group": "Ungrouped variables", "definition": "A[1]/A[0]^2", "description": "", "templateType": "anything", "can_override": false}, "m": {"name": "m", "group": "Ungrouped variables", "definition": "(A[1]-b)/A[0]", "description": "<p>slope</p>", "templateType": "anything", "can_override": false}, "area": {"name": "area", "group": "Unnamed group", "definition": "- k x^3/3 + m x^2/2 + b x", "description": "", "templateType": "anything", "can_override": false}, "x": {"name": "x", "group": "Ungrouped variables", "definition": "A[0]", "description": "", "templateType": "anything", "can_override": false}, "Qy": {"name": "Qy", "group": "Unnamed group", "definition": "- k x^4/4 + m x^3/3 + b x^2/2", "description": "", "templateType": "anything", "can_override": false}, "xbar": {"name": "xbar", "group": "Unnamed group", "definition": "Qy/area", "description": "", "templateType": "anything", "can_override": false}, "Qx": {"name": "Qx", "group": "Unnamed group", "definition": "(-k^2 x^5/5 + m^2 x^3/3 +  m b x^2 + b^2 x)/2", "description": "", "templateType": "anything", "can_override": false}, "ybar": {"name": "ybar", "group": "Unnamed group", "definition": "Qx/area", "description": "", "templateType": "anything", "can_override": false}}, "variablesTest": {"condition": "m <> 0 // don't want the line to be horizontal", "maxRuns": 100}, "ungrouped_variables": ["A", "b", "k", "m", "x"], "variable_groups": [{"name": "Unnamed group", "variables": ["area", "Qy", "xbar", "Qx", "ybar"]}], "functions": {"g": {"parameters": [["x", "number"]], "type": "number", "language": "jme", "definition": " m x + by"}, "applet": {"parameters": [], "type": "ggbapplet", "language": "javascript", "definition": "//{geogebra_applet('cpf7gyej',['A': A, 'by': b,  \"C\": [visible: false, label_style: 3]])}\n// Create the worksheet. \n// This function returns an object with a container `element` and a `promise` resolving to a GeoGebra applet.\nvar params = {\n  material_id: 'cpf7gyej'\n}\n\nvar result = Numbas.extensions.geogebra.createGeogebraApplet(params);\n\n// Once the applet has loaded, run some commands to manipulate the worksheet.\nresult.promise.then(function(d) {\n  var app = d.app;\n  question.applet = d;\n   \n  //initialize the dimensions and forces\n  \n   function setGGBPoint(g_name, n_name = g_name) {\n    // moves point in GGB to location of Numbas Vector Variable\n    // g_name = geogebra point, n_name = numbas vector\n    \n    //var pt = question.scope.evaluate(n_name).value\n    var pt = scope.getVariable(n_name).value\n    app.setFixed(g_name,false,false);\n    app.setCoords(g_name, pt[0], pt[1]);\n    app.setFixed(g_name,true,true);\n  }\n  \n  function setGGBNumber(gname, nname=gname) {\n    // Sets number in GGB to a Numbas Variable\n    var n = question.scope.evaluate(nname).value;\n    app.setValue(gname,n);\n  }\n    \n  setGGBPoint(\"A\");\n  setGGBNumber(\"by\", \"b\");\n  app.setVisible(\"C\",false);// centroid\n\n  \n});\n\n// This function returns the result of `createGeogebraApplet` as an object \n// with the JME data type 'ggbapplet', which can be substituted into the question's content.\nreturn new Numbas.jme.types.ggbapplet(result);\n"}}, "preamble": {"js": "question.signals.on('adviceDisplayed',function() {\n   try{\n    var app = question.applet.app;\n    app.setVisible(\"C\", true,false);\n  }\n  catch(err){} \n    \n})\n\n\n\n", "css": ""}, "parts": [{"type": "gapfill", "useCustomName": false, "customName": "", "marks": 0, "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": true, "showFeedbackIcon": true, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "prompt": "<p style=\"padding-left: 30px;\">$\\bar{x} = $ [[0]]&nbsp; units&nbsp;</p>\n<p style=\"padding-left: 30px;\">$\\bar{y} = $&nbsp; [[1]]&nbsp;units</p>", "gaps": [{"type": "engineering-answer", "useCustomName": true, "customName": "xbar", "marks": "10", "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": true, "showFeedbackIcon": true, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "settings": {"correctAnswer": "qty(xbar,'')", "right": "0.2", "close": "1.0", "C1": "75", "C2": "50", "C3": "25"}}, {"type": "engineering-answer", "useCustomName": true, "customName": "ybar", "marks": "10", "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": true, "showFeedbackIcon": true, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "settings": {"correctAnswer": "qty(ybar,'')", "right": "0.2", "close": "1.0", "C1": "75", "C2": "50", "C3": "25"}}], "sortAnswers": false}], "partsMode": "all", "maxMarks": 0, "objectives": [], "penalties": [], "objectiveVisibility": "always", "penaltyVisibility": "always"}]}, {"name": "Distributed Loads", "pickingStrategy": "all-ordered", "pickQuestions": 1, "questionNames": ["Uniformly distributed load", "Uniformly varying load", "Trapezoidal loading"], "variable_overrides": [[], [], []], "questions": [{"name": "Reactions for beam with uniformly distributed load", "extensions": ["jsxgraph", "quantities", "shear-and-bending-moment-diagrams"], "custom_part_types": [{"source": {"pk": 19, "author": {"name": "William Haynes", "pk": 2530}, "edit_page": "/part_type/19/edit"}, "name": "Engineering Accuracy with units", "short_name": "engineering-answer", "description": "<p>A value with units marked right if within an adjustable % error of the correct value. &nbsp;Marked close if within a wider margin of error.</p>", "help_url": "", "input_widget": "string", "input_options": {"correctAnswer": "siground(settings['correctAnswer'],4)", "hint": {"static": true, "value": ""}, "allowEmpty": {"static": true, "value": true}}, "can_be_gap": true, "can_be_step": true, "marking_script": "mark:\nswitch( \n  right and good_units and right_sign, add_credit(1.0,'Correct.'),\n  right and good_units and not right_sign, add_credit(settings['C2'],'Wrong sign.'),\n  right and right_sign and not good_units, add_credit(settings['C2'],'Correct value, but wrong or missing units.'),\n  close and good_units, add_credit(settings['C1'],'Close.'),\n  close and not good_units, add_credit(settings['C3'],'Answer is close, but wrong or missing units.'),\n  incorrect('Wrong answer.')\n)\n\ninterpreted_answer:\nqty(student_scalar, student_units)\n\n\n\ncorrect_quantity:\nsettings[\"correctAnswer\"]\n\n\n\ncorrect_units:\nunits(correct_quantity)\n\n\nallowed_notation_styles:\n[\"plain\",\"en\"]\n\nmatch_student_number:\nmatchnumber(studentAnswer,allowed_notation_styles)\n\nstudent_scalar:\nmatch_student_number[1]\n\nstudent_units:\nreplace_regex('ohms','ohm',\n  replace_regex('\u00b0', ' deg',\n    replace_regex('-', ' ' ,\n      studentAnswer[len(match_student_number[0])..len(studentAnswer)])),\"i\")\n\ngood_units:\ntry(\ncompatible(quantity(1, student_units),correct_units),\nmsg,\nfeedback(msg);false)\n\n\nstudent_quantity:\nswitch(not good_units, \n       student_scalar * correct_units, \n       not right_sign,\n       -quantity(student_scalar, student_units),\n       quantity(student_scalar,student_units)\n)\n  \n\n\npercent_error:\ntry(\nscalar(abs((correct_quantity - student_quantity)/correct_quantity))*100  \n,msg,\nif(student_quantity=correct_quantity,0,100))\n   \n\nright:\npercent_error <= settings['right']\n\n\nclose:\nright_sign and percent_error <= settings['close']\n\nright_sign:\nsign(student_scalar) = sign(correct_quantity)", "marking_notes": [{"name": "mark", "description": "This is the main marking note. It should award credit and provide feedback based on the student's answer.", "definition": "switch( \n  right and good_units and right_sign, add_credit(1.0,'Correct.'),\n  right and good_units and not right_sign, add_credit(settings['C2'],'Wrong sign.'),\n  right and right_sign and not good_units, add_credit(settings['C2'],'Correct value, but wrong or missing units.'),\n  close and good_units, add_credit(settings['C1'],'Close.'),\n  close and not good_units, add_credit(settings['C3'],'Answer is close, but wrong or missing units.'),\n  incorrect('Wrong answer.')\n)"}, {"name": "interpreted_answer", "description": "A value representing the student's answer to this part.", "definition": "qty(student_scalar, student_units)\n\n"}, {"name": "correct_quantity", "description": "", "definition": "settings[\"correctAnswer\"]\n\n"}, {"name": "correct_units", "description": "", "definition": "units(correct_quantity)\n"}, {"name": "allowed_notation_styles", "description": "", "definition": "[\"plain\",\"en\"]"}, {"name": "match_student_number", "description": "", "definition": "matchnumber(studentAnswer,allowed_notation_styles)"}, {"name": "student_scalar", "description": "", "definition": "match_student_number[1]"}, {"name": "student_units", "description": "<p>Modify&nbsp;the&nbsp;unit portion of&nbsp;the student's answer by</p>\n<p>1. replacing \"ohms\" with \"ohm\" &nbsp;case insensitive</p>\n<p>2.&nbsp;replacing '-'&nbsp;with ' '&nbsp;</p>\n<p>3. replacing '&deg;' with ' deg'&nbsp;</p>\n<p>to allow answers like 10 ft-lb and 30&deg;</p>", "definition": "replace_regex('ohms','ohm',\n  replace_regex('\u00b0', ' deg',\n    replace_regex('-', ' ' ,\n      studentAnswer[len(match_student_number[0])..len(studentAnswer)])),\"i\")"}, {"name": "good_units", "description": "", "definition": "try(\ncompatible(quantity(1, student_units),correct_units),\nmsg,\nfeedback(msg);false)\n"}, {"name": "student_quantity", "description": "<p>This fixes the student answer for two common errors. &nbsp;</p>\n<p>If student_units are wrong&nbsp;&nbsp;- replace with correct units</p>\n<p>If student_scalar has the wrong sign - replace with right sign</p>\n<p>If student makes both errors, only one gets fixed.</p>", "definition": "switch(not good_units, \n       student_scalar * correct_units, \n       not right_sign,\n       -quantity(student_scalar, student_units),\n       quantity(student_scalar,student_units)\n)\n  \n"}, {"name": "percent_error", "description": "", "definition": "try(\nscalar(abs((correct_quantity - student_quantity)/correct_quantity))*100  \n,msg,\nif(student_quantity=correct_quantity,0,100))\n   "}, {"name": "right", "description": "", "definition": "percent_error <= settings['right']\n"}, {"name": "close", "description": "<p>Only marked close if the student actually has the right sign.</p>", "definition": "right_sign and percent_error <= settings['close']"}, {"name": "right_sign", "description": "", "definition": "sign(student_scalar) = sign(correct_quantity) "}], "settings": [{"name": "correctAnswer", "label": "Correct Quantity.", "help_url": "", "hint": "The correct answer given as a JME quantity.", "input_type": "code", "default_value": "", "evaluate": true}, {"name": "right", "label": "% Accuracy for right.", "help_url": "", "hint": "Question will be considered correct if the scalar part of the student's answer is within this % of correct value.", "input_type": "code", "default_value": "0.2", "evaluate": true}, {"name": "close", "label": "% Accuracy for close.", "help_url": "", "hint": "Question will be considered close if the scalar part of the student's answer is within this % of correct value.", "input_type": "code", "default_value": "1.0", "evaluate": true}, {"name": "C1", "label": "Close with units.", "help_url": "", "hint": "Partial Credit for close value with appropriate units. &nbsp;if correct answer is 100 N and close is &plusmn;1%,<br />99 &nbsp;N is accepted.", "input_type": "percent", "default_value": "75"}, {"name": "C2", "label": "No units or wrong sign", "help_url": "", "hint": "Partial credit for forgetting units or using wrong sign.<br />If the correct answer is 100 N, both 100 and -100 N are accepted.", "input_type": "percent", "default_value": "50"}, {"name": "C3", "label": "Close, no units.", "help_url": "", "hint": "Partial Credit for close value but forgotten units.<br />This value would be close&nbsp;if the expected units were provided. &nbsp;If the correct answer is 100 N, and close is &plusmn;1%,<br />99 is accepted.", "input_type": "percent", "default_value": "25"}], "public_availability": "always", "published": true, "extensions": ["quantities"]}], "resources": [], "navigation": {"allowregen": true, "showfrontpage": false, "preventleave": false, "typeendtoleave": false}, "contributors": [{"name": "William Haynes", "profile_url": "https://numbas.mathcentre.ac.uk/accounts/profile/2530/"}], "tags": [], "metadata": {"description": "<p>Find the reactions for a beam with a uniformly distributed load.</p>", "licence": "Creative Commons Attribution-NonCommercial 4.0 International"}, "statement": "<p>A $\\var{distance(L)}$ long beam is subjected uniformly distributed load, as shown. Assume the weight of the beam is negligible. Determine the reactions at $A$ and $B$.</p>\n<p>{loadDiagram}</p>\n<p><span data-jme-visible=\"debug\">w: {loading} W: {w} &nbsp;$F_A$: {FA} &nbsp;$F_B$ {FB}</span></p>", "advice": "<ol>\n<li>To solve, replace the distributed load with an equivalent concentrated load. &nbsp;The equivalent concentrated load acts at the centroid of the rectangle, and its magnitude is the \"area\" of the rectangle. &nbsp;\\[ W_R = \\var{udl(loading)} \\times \\var{distance((D-C))} = \\var{force(w)} \\]</li>\n<li>Once replaced, draw a free body diagram; {fbd}</li>\n<li>Take moments at $A$ to find $B$ and vice-versa. &nbsp;</li>\n<li>Check your work by applying $\\Sigma F_y = 0$.</li>\n</ol>", "rulesets": {}, "builtin_constants": {"e": true, "pi,\u03c0": true, "i": true, "j": false}, "constants": [], "variables": {"x": {"name": "x", "group": "Ungrouped variables", "definition": "(C+D)/2", "description": "<p>midpoint of load</p>", "templateType": "anything", "can_override": false}, "loading": {"name": "loading", "group": "inputs", "definition": "random(1,2,3,4,5,6)* random(10, 20, 50, 100)", "description": "<p>magnitude of distributed loading [force/length]</p>", "templateType": "anything", "can_override": false}, "D": {"name": "D", "group": "inputs", "definition": "random(C..L)", "description": "<p>distributed load ends here</p>\n<p>D-C &gt; 3 and B-A &gt; L/2 and A&lt;&gt;C and B&lt;&gt;D</p>", "templateType": "anything", "can_override": false}, "C": {"name": "C", "group": "inputs", "definition": "random(0..L/2)", "description": "<p>distributed load starts here</p>", "templateType": "anything", "can_override": false}, "FA": {"name": "FA", "group": "Ungrouped variables", "definition": "W-FB", "description": "<p>reaction at A</p>", "templateType": "anything", "can_override": false}, "B": {"name": "B", "group": "inputs", "definition": "random(L/2..L)", "description": "<p>location of right hand support</p>", "templateType": "anything", "can_override": false}, "W": {"name": "W", "group": "Ungrouped variables", "definition": "loading * (D-C)", "description": "<p>Downward force</p>", "templateType": "anything", "can_override": false}, "L": {"name": "L", "group": "inputs", "definition": "random(8,10,12,14,16)", "description": "<p>length of beam</p>", "templateType": "anything", "can_override": false}, "debug": {"name": "debug", "group": "Ungrouped variables", "definition": "false", "description": "", "templateType": "anything", "can_override": false}, "FB": {"name": "FB", "group": "Ungrouped variables", "definition": "(x-A) * W / (B-A)\n", "description": "<p>reaction at B</p>", "templateType": "anything", "can_override": false}, "units": {"name": "units", "group": "inputs", "definition": "random(['lb','ft', 'lb/ft'],['N','m', 'N/m'])", "description": "", "templateType": "anything", "can_override": false}, "A": {"name": "A", "group": "inputs", "definition": "random(0..L/2)", "description": "<p>location of left hand support</p>", "templateType": "anything", "can_override": false}, "Force": {"name": "Force", "group": "Ungrouped variables", "definition": "(f)-> siground(qty(F,units[0]),4)", "description": "", "templateType": "anything", "can_override": false}, "distance": {"name": "distance", "group": "Ungrouped variables", "definition": "(d)-> siground(qty(d,units[1]),4)", "description": "", "templateType": "anything", "can_override": false}, "udl": {"name": "udl", "group": "Ungrouped variables", "definition": "(w)->siground(qty(w,units[2]),4)", "description": "", "templateType": "anything", "can_override": false}, "loadProperties": {"name": "loadProperties", "group": "diagrams", "definition": "[ beamLength: L, symbols: LoadSymbols, loads: loads, reactions: [], forces: [], moments: []]", "description": "", "templateType": "anything", "can_override": false}, "loadDiagram": {"name": "loadDiagram", "group": "diagrams", "definition": "vmloaddiagram(loadProperties)", "description": "", "templateType": "anything", "can_override": false}, "loadSymbols": {"name": "loadSymbols", "group": "diagrams", "definition": "[[type: \"pin\", x: A ,label: \"$A$\", visible: true], [type: \"roller\", x: b, label: \"$B$\", visible: true]]", "description": "", "templateType": "anything", "can_override": false}, "fbdproperties": {"name": "fbdproperties", "group": "diagrams", "definition": "[beamLength: L, reactions: FBDreactions, forces: FBDforces,  moments: [], loads: fbdLoads, symbols: [[type: \"dot\", x: x ,label: string(distance(x)), visible: true]]]", "description": "", "templateType": "anything", "can_override": false}, "FBDforces": {"name": "FBDforces", "group": "diagrams", "definition": "[[x: x, value: W, label: \"$W_R$\", visible: true]]", "description": "", "templateType": "anything", "can_override": false}, "FBDreactions": {"name": "FBDreactions", "group": "diagrams", "definition": "[[x: A, value: FA, label: \"$A$\", visible: true],[x: B, value: FB, label: \"$B$\", visible: true]]", "description": "", "templateType": "anything", "can_override": false}, "fbd": {"name": "fbd", "group": "diagrams", "definition": "vmloaddiagram(fbdproperties)", "description": "", "templateType": "anything", "can_override": false}, "fbdLoads": {"name": "fbdLoads", "group": "diagrams", "definition": "[[[x: C, value: 1, label:\"\", visible: false],[x: D, value: 1, label: \"\", visible: false]]]", "description": "", "templateType": "anything", "can_override": false}, "loads": {"name": "loads", "group": "diagrams", "definition": "[[[x: C, value: 1, label: string(udl(loading)), visible: true],[x: D, value: 1, label: \"\", visible: true]]]", "description": "", "templateType": "anything", "can_override": false}}, "variablesTest": {"condition": "D-C > 3 and B-A > L/2 and A<>C and B<>D", "maxRuns": 100}, "ungrouped_variables": ["W", "FB", "x", "FA", "debug", "Force", "distance", "udl"], "variable_groups": [{"name": "inputs", "variables": ["A", "B", "C", "D", "loading", "units", "L"]}, {"name": "diagrams", "variables": ["loadProperties", "loads", "loadDiagram", "loadSymbols", "fbdproperties", "FBDforces", "FBDreactions", "fbd", "fbdLoads"]}, {"name": "Unnamed group", "variables": []}], "functions": {}, "preamble": {"js": "", "css": ".jsxgraph-board {width: 200px; height: 100px;}"}, "parts": [{"type": "gapfill", "useCustomName": false, "customName": "", "marks": 0, "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": true, "showFeedbackIcon": true, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "prompt": "<p style=\"padding-left: 40px;\">$A$ =&nbsp;[[0]]&nbsp;&nbsp;</p>\n<p style=\"padding-left: 40px;\">$B$ =&nbsp;[[1]]&nbsp;</p>", "gaps": [{"type": "engineering-answer", "useCustomName": true, "customName": "A", "marks": "10", "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": true, "showFeedbackIcon": true, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "settings": {"correctAnswer": "force(FA)", "right": "0.1", "close": "1.0", "C1": "80", "C2": "80", "C3": "60"}}, {"type": "engineering-answer", "useCustomName": true, "customName": "B", "marks": "10", "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": true, "showFeedbackIcon": true, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "settings": {"correctAnswer": "force(FB)", "right": "0.1", "close": "1.0", "C1": "80", "C2": "80", "C3": "60"}}], "sortAnswers": false}], "partsMode": "all", "maxMarks": 0, "objectives": [], "penalties": [], "objectiveVisibility": "always", "penaltyVisibility": "always"}, {"name": "Reactions for beam with uniformly varying load", "extensions": ["jsxgraph", "quantities", "shear-and-bending-moment-diagrams"], "custom_part_types": [{"source": {"pk": 19, "author": {"name": "William Haynes", "pk": 2530}, "edit_page": "/part_type/19/edit"}, "name": "Engineering Accuracy with units", "short_name": "engineering-answer", "description": "<p>A value with units marked right if within an adjustable % error of the correct value. &nbsp;Marked close if within a wider margin of error.</p>", "help_url": "", "input_widget": "string", "input_options": {"correctAnswer": "siground(settings['correctAnswer'],4)", "hint": {"static": true, "value": ""}, "allowEmpty": {"static": true, "value": true}}, "can_be_gap": true, "can_be_step": true, "marking_script": "mark:\nswitch( \n  right and good_units and right_sign, add_credit(1.0,'Correct.'),\n  right and good_units and not right_sign, add_credit(settings['C2'],'Wrong sign.'),\n  right and right_sign and not good_units, add_credit(settings['C2'],'Correct value, but wrong or missing units.'),\n  close and good_units, add_credit(settings['C1'],'Close.'),\n  close and not good_units, add_credit(settings['C3'],'Answer is close, but wrong or missing units.'),\n  incorrect('Wrong answer.')\n)\n\ninterpreted_answer:\nqty(student_scalar, student_units)\n\n\n\ncorrect_quantity:\nsettings[\"correctAnswer\"]\n\n\n\ncorrect_units:\nunits(correct_quantity)\n\n\nallowed_notation_styles:\n[\"plain\",\"en\"]\n\nmatch_student_number:\nmatchnumber(studentAnswer,allowed_notation_styles)\n\nstudent_scalar:\nmatch_student_number[1]\n\nstudent_units:\nreplace_regex('ohms','ohm',\n  replace_regex('\u00b0', ' deg',\n    replace_regex('-', ' ' ,\n      studentAnswer[len(match_student_number[0])..len(studentAnswer)])),\"i\")\n\ngood_units:\ntry(\ncompatible(quantity(1, student_units),correct_units),\nmsg,\nfeedback(msg);false)\n\n\nstudent_quantity:\nswitch(not good_units, \n       student_scalar * correct_units, \n       not right_sign,\n       -quantity(student_scalar, student_units),\n       quantity(student_scalar,student_units)\n)\n  \n\n\npercent_error:\ntry(\nscalar(abs((correct_quantity - student_quantity)/correct_quantity))*100  \n,msg,\nif(student_quantity=correct_quantity,0,100))\n   \n\nright:\npercent_error <= settings['right']\n\n\nclose:\nright_sign and percent_error <= settings['close']\n\nright_sign:\nsign(student_scalar) = sign(correct_quantity)", "marking_notes": [{"name": "mark", "description": "This is the main marking note. It should award credit and provide feedback based on the student's answer.", "definition": "switch( \n  right and good_units and right_sign, add_credit(1.0,'Correct.'),\n  right and good_units and not right_sign, add_credit(settings['C2'],'Wrong sign.'),\n  right and right_sign and not good_units, add_credit(settings['C2'],'Correct value, but wrong or missing units.'),\n  close and good_units, add_credit(settings['C1'],'Close.'),\n  close and not good_units, add_credit(settings['C3'],'Answer is close, but wrong or missing units.'),\n  incorrect('Wrong answer.')\n)"}, {"name": "interpreted_answer", "description": "A value representing the student's answer to this part.", "definition": "qty(student_scalar, student_units)\n\n"}, {"name": "correct_quantity", "description": "", "definition": "settings[\"correctAnswer\"]\n\n"}, {"name": "correct_units", "description": "", "definition": "units(correct_quantity)\n"}, {"name": "allowed_notation_styles", "description": "", "definition": "[\"plain\",\"en\"]"}, {"name": "match_student_number", "description": "", "definition": "matchnumber(studentAnswer,allowed_notation_styles)"}, {"name": "student_scalar", "description": "", "definition": "match_student_number[1]"}, {"name": "student_units", "description": "<p>Modify&nbsp;the&nbsp;unit portion of&nbsp;the student's answer by</p>\n<p>1. replacing \"ohms\" with \"ohm\" &nbsp;case insensitive</p>\n<p>2.&nbsp;replacing '-'&nbsp;with ' '&nbsp;</p>\n<p>3. replacing '&deg;' with ' deg'&nbsp;</p>\n<p>to allow answers like 10 ft-lb and 30&deg;</p>", "definition": "replace_regex('ohms','ohm',\n  replace_regex('\u00b0', ' deg',\n    replace_regex('-', ' ' ,\n      studentAnswer[len(match_student_number[0])..len(studentAnswer)])),\"i\")"}, {"name": "good_units", "description": "", "definition": "try(\ncompatible(quantity(1, student_units),correct_units),\nmsg,\nfeedback(msg);false)\n"}, {"name": "student_quantity", "description": "<p>This fixes the student answer for two common errors. &nbsp;</p>\n<p>If student_units are wrong&nbsp;&nbsp;- replace with correct units</p>\n<p>If student_scalar has the wrong sign - replace with right sign</p>\n<p>If student makes both errors, only one gets fixed.</p>", "definition": "switch(not good_units, \n       student_scalar * correct_units, \n       not right_sign,\n       -quantity(student_scalar, student_units),\n       quantity(student_scalar,student_units)\n)\n  \n"}, {"name": "percent_error", "description": "", "definition": "try(\nscalar(abs((correct_quantity - student_quantity)/correct_quantity))*100  \n,msg,\nif(student_quantity=correct_quantity,0,100))\n   "}, {"name": "right", "description": "", "definition": "percent_error <= settings['right']\n"}, {"name": "close", "description": "<p>Only marked close if the student actually has the right sign.</p>", "definition": "right_sign and percent_error <= settings['close']"}, {"name": "right_sign", "description": "", "definition": "sign(student_scalar) = sign(correct_quantity) "}], "settings": [{"name": "correctAnswer", "label": "Correct Quantity.", "help_url": "", "hint": "The correct answer given as a JME quantity.", "input_type": "code", "default_value": "", "evaluate": true}, {"name": "right", "label": "% Accuracy for right.", "help_url": "", "hint": "Question will be considered correct if the scalar part of the student's answer is within this % of correct value.", "input_type": "code", "default_value": "0.2", "evaluate": true}, {"name": "close", "label": "% Accuracy for close.", "help_url": "", "hint": "Question will be considered close if the scalar part of the student's answer is within this % of correct value.", "input_type": "code", "default_value": "1.0", "evaluate": true}, {"name": "C1", "label": "Close with units.", "help_url": "", "hint": "Partial Credit for close value with appropriate units. &nbsp;if correct answer is 100 N and close is &plusmn;1%,<br />99 &nbsp;N is accepted.", "input_type": "percent", "default_value": "75"}, {"name": "C2", "label": "No units or wrong sign", "help_url": "", "hint": "Partial credit for forgetting units or using wrong sign.<br />If the correct answer is 100 N, both 100 and -100 N are accepted.", "input_type": "percent", "default_value": "50"}, {"name": "C3", "label": "Close, no units.", "help_url": "", "hint": "Partial Credit for close value but forgotten units.<br />This value would be close&nbsp;if the expected units were provided. &nbsp;If the correct answer is 100 N, and close is &plusmn;1%,<br />99 is accepted.", "input_type": "percent", "default_value": "25"}], "public_availability": "always", "published": true, "extensions": ["quantities"]}], "resources": ["question-resources/dist-load.ggb"], "navigation": {"allowregen": true, "showfrontpage": false, "preventleave": false, "typeendtoleave": false}, "contributors": [{"name": "William Haynes", "profile_url": "https://numbas.mathcentre.ac.uk/accounts/profile/2530/"}], "tags": ["mechanics, statics, reactions, distributed load, uniformly varying load"], "metadata": {"description": "<p>Find the reactions for a beam with a uniformly varying distributed load.</p>", "licence": "Creative Commons Attribution-NonCommercial 4.0 International"}, "statement": "<p>A {qty(L, units[1]) } long beam is subjected to a load that varies uniformly from $\\var{uvl(wc)}$ at $C$ to $\\var{uvl(wd)}$ at $D$. The beam itself weighs $\\var{uvl(w_b)}$.</p>\n<p>Determine the reactions at $A$ and $B$.</p>\n<p>{loadDiagram}.</p>\n<p><span data-jme-visible=\"debug\">W: {w} &nbsp;beam: {wb} xbar: {x} check: {check}</span></p>\n<p><span data-jme-visible=\"debug\">$F_A$: {precround(FA,4)} &nbsp;$F_B$ {precround(FB,4)}</span></p>", "advice": "<ol>\n<li>To solve, divide the trapazoid into a rectangle and a triangle or two triangles, then replace each&nbsp;with an equivalent concentrated load. &nbsp;The equivalent concentrated load acts at the centroid of each&nbsp;shape, and its magnitude is the \"area\" of the shape. &nbsp;</li>\n<li>Treat the beam as a uniformly distributed load, and place the weight of the beam at the&nbsp;center.</li>\n<li>Once replaced, draw a free body diagram; then take moments at $A$ to find $B$ and vice-versa. &nbsp;Check your work by applying $\\Sigma F_y = 0$.</li>\n</ol>", "rulesets": {}, "builtin_constants": {"e": true, "pi,\u03c0": true, "i": true, "j": false}, "constants": [], "variables": {"D": {"name": "D", "group": "inputs", "definition": "random(L-3.. L)", "description": "<p>distributed load ends here</p>", "templateType": "anything", "can_override": false}, "L": {"name": "L", "group": "inputs", "definition": "random(10,15, 18)", "description": "<p>length of beam</p>\n<p></p>", "templateType": "anything", "can_override": false}, "units": {"name": "units", "group": "inputs", "definition": "random(['lb', 'ft', 'lb/ft'],['kN', 'm', 'kN/m'])", "description": "", "templateType": "anything", "can_override": false}, "loading": {"name": "loading", "group": "inputs", "definition": "random(10..50#10)", "description": "<p>distributed loading [force/length]</p>", "templateType": "anything", "can_override": false}, "FA": {"name": "FA", "group": "Ungrouped variables", "definition": "(W + WB)-FB", "description": "<p>reaction at A</p>", "templateType": "anything", "can_override": false}, "debug": {"name": "debug", "group": "Ungrouped variables", "definition": "false", "description": "", "templateType": "anything", "can_override": false}, "wc": {"name": "wc", "group": "inputs", "definition": "random(0..2#0.5 except 0.5) loading", "description": "", "templateType": "anything", "can_override": false}, "W": {"name": "W", "group": "Ungrouped variables", "definition": "precround((wc+wd)/2 * (D-C),5)", "description": "<p>Downward force due to load</p>", "templateType": "anything", "can_override": false}, "B": {"name": "B", "group": "inputs", "definition": "if(D=L, random(L-1..L-4), L)", "description": "<p>location of right hand support</p>", "templateType": "anything", "can_override": false}, "C": {"name": "C", "group": "inputs", "definition": "random(0..5)", "description": "<p>distributed load starts here</p>", "templateType": "anything", "can_override": false}, "A": {"name": "A", "group": "inputs", "definition": "if(C=0, random(1..4), 0)", "description": "<p>location of left hand support</p>", "templateType": "anything", "can_override": false}, "wd": {"name": "wd", "group": "inputs", "definition": "random(0..2#0.5 except 0.5) loading", "description": "", "templateType": "anything", "can_override": false}, "x": {"name": "x", "group": "Ungrouped variables", "definition": "C + (wc / 6 + wd/ 3)(D-C) * 2/(wc+wd)", "description": "<p>midpoint of load</p>", "templateType": "anything", "can_override": false}, "FB": {"name": "FB", "group": "Ungrouped variables", "definition": "precround(((x-A) * W + (CG-A) *  WB) / (B-A),5)\n", "description": "<p>reaction at B</p>", "templateType": "anything", "can_override": false}, "w_b": {"name": "w_b", "group": "inputs", "definition": "siground(random(0.1..1 #0.1) loading,3)", "description": "<p>Weight of the beam in W/L units</p>", "templateType": "anything", "can_override": false}, "CG": {"name": "CG", "group": "Ungrouped variables", "definition": "L/2", "description": "<p>center of the beam</p>", "templateType": "anything", "can_override": false}, "WB": {"name": "WB", "group": "Ungrouped variables", "definition": "w_b L ", "description": "<p>Weight of the beam itself</p>", "templateType": "anything", "can_override": false}, "check": {"name": "check", "group": "Ungrouped variables", "definition": "(W + WB)= (FA+FB)", "description": "", "templateType": "anything", "can_override": false}, "points": {"name": "points", "group": "inputs", "definition": "sort(deal(L)[0..2])", "description": "", "templateType": "anything", "can_override": false}, "properties": {"name": "properties", "group": "Unnamed group", "definition": "[beamLength: L, loads: distributedLoad, symbols: symbols, forces: [], moments: [], reactions: []]", "description": "", "templateType": "anything", "can_override": false}, "loadDiagram": {"name": "loadDiagram", "group": "Unnamed group", "definition": "vmloaddiagram(properties)", "description": "", "templateType": "anything", "can_override": false}, "symbols": {"name": "symbols", "group": "Unnamed group", "definition": "[[x: A, type: \"pin\", label: \"$A$\", visible: true],[x: B, type: \"roller\", label: \"$B$\", visible: true], [x: C, type: \"dot\", label: \"$C$\", visible: true], [x: D, type: \"dot\", label: \"$D$\", visible: true]]\n", "description": "", "templateType": "anything", "can_override": false}, "distributedLoad": {"name": "distributedLoad", "group": "Unnamed group", "definition": "[[[x: C, value: wC ,  label: loadWords(wc,wd), visible: true], [x: D, value: wd , label: \"\", visible: true]]]", "description": "", "templateType": "anything", "can_override": false}, "loadWords": {"name": "loadWords", "group": "Unnamed group", "definition": "(w1,w2) -> w1 + \" to \" + w2  + \" \"  + units[2]", "description": "", "templateType": "anything", "can_override": false}, "UVL": {"name": "UVL", "group": "Unnamed group", "definition": "w -> qty(w, units[2])", "description": "", "templateType": "anything", "can_override": false}}, "variablesTest": {"condition": "D-C > L/3 and \nwc<>wd", "maxRuns": 100}, "ungrouped_variables": ["W", "FB", "x", "FA", "debug", "CG", "WB", "check"], "variable_groups": [{"name": "inputs", "variables": ["A", "B", "C", "D", "loading", "units", "L", "wc", "wd", "w_b", "points"]}, {"name": "ggb", "variables": []}, {"name": "Unnamed group", "variables": ["properties", "loadDiagram", "symbols", "distributedLoad", "loadWords", "UVL"]}], "functions": {}, "preamble": {"js": "", "css": ""}, "parts": [{"type": "gapfill", "useCustomName": false, "customName": "", "marks": 0, "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": true, "showFeedbackIcon": true, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "prompt": "<p style=\"padding-left: 40px;\">$A$ =&nbsp;[[0]]&nbsp;</p>\n<p style=\"padding-left: 40px;\">$B$ =&nbsp;[[1]]&nbsp;&nbsp;</p>", "gaps": [{"type": "engineering-answer", "useCustomName": true, "customName": "A", "marks": "10", "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": true, "showFeedbackIcon": true, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "settings": {"correctAnswer": "qty(precround(FA,4),units[0])", "right": "0.1", "close": "1.0", "C1": "80", "C2": "80", "C3": "60"}}, {"type": "engineering-answer", "useCustomName": true, "customName": "B", "marks": "10", "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": true, "showFeedbackIcon": true, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "settings": {"correctAnswer": "qty(siground(FB,4),units[0])", "right": "0.1", "close": "1.0", "C1": "80", "C2": "80", "C3": "60"}}], "sortAnswers": false}], "partsMode": "all", "maxMarks": 0, "objectives": [], "penalties": [], "objectiveVisibility": "always", "penaltyVisibility": "always"}, {"name": "Distributed Loads: trapezoidal loading", "extensions": ["jsxgraph", "quantities", "shear-and-bending-moment-diagrams"], "custom_part_types": [{"source": {"pk": 19, "author": {"name": "William Haynes", "pk": 2530}, "edit_page": "/part_type/19/edit"}, "name": "Engineering Accuracy with units", "short_name": "engineering-answer", "description": "<p>A value with units marked right if within an adjustable % error of the correct value. &nbsp;Marked close if within a wider margin of error.</p>", "help_url": "", "input_widget": "string", "input_options": {"correctAnswer": "siground(settings['correctAnswer'],4)", "hint": {"static": true, "value": ""}, "allowEmpty": {"static": true, "value": true}}, "can_be_gap": true, "can_be_step": true, "marking_script": "mark:\nswitch( \n  right and good_units and right_sign, add_credit(1.0,'Correct.'),\n  right and good_units and not right_sign, add_credit(settings['C2'],'Wrong sign.'),\n  right and right_sign and not good_units, add_credit(settings['C2'],'Correct value, but wrong or missing units.'),\n  close and good_units, add_credit(settings['C1'],'Close.'),\n  close and not good_units, add_credit(settings['C3'],'Answer is close, but wrong or missing units.'),\n  incorrect('Wrong answer.')\n)\n\ninterpreted_answer:\nqty(student_scalar, student_units)\n\n\n\ncorrect_quantity:\nsettings[\"correctAnswer\"]\n\n\n\ncorrect_units:\nunits(correct_quantity)\n\n\nallowed_notation_styles:\n[\"plain\",\"en\"]\n\nmatch_student_number:\nmatchnumber(studentAnswer,allowed_notation_styles)\n\nstudent_scalar:\nmatch_student_number[1]\n\nstudent_units:\nreplace_regex('ohms','ohm',\n  replace_regex('\u00b0', ' deg',\n    replace_regex('-', ' ' ,\n      studentAnswer[len(match_student_number[0])..len(studentAnswer)])),\"i\")\n\ngood_units:\ntry(\ncompatible(quantity(1, student_units),correct_units),\nmsg,\nfeedback(msg);false)\n\n\nstudent_quantity:\nswitch(not good_units, \n       student_scalar * correct_units, \n       not right_sign,\n       -quantity(student_scalar, student_units),\n       quantity(student_scalar,student_units)\n)\n  \n\n\npercent_error:\ntry(\nscalar(abs((correct_quantity - student_quantity)/correct_quantity))*100  \n,msg,\nif(student_quantity=correct_quantity,0,100))\n   \n\nright:\npercent_error <= settings['right']\n\n\nclose:\nright_sign and percent_error <= settings['close']\n\nright_sign:\nsign(student_scalar) = sign(correct_quantity)", "marking_notes": [{"name": "mark", "description": "This is the main marking note. It should award credit and provide feedback based on the student's answer.", "definition": "switch( \n  right and good_units and right_sign, add_credit(1.0,'Correct.'),\n  right and good_units and not right_sign, add_credit(settings['C2'],'Wrong sign.'),\n  right and right_sign and not good_units, add_credit(settings['C2'],'Correct value, but wrong or missing units.'),\n  close and good_units, add_credit(settings['C1'],'Close.'),\n  close and not good_units, add_credit(settings['C3'],'Answer is close, but wrong or missing units.'),\n  incorrect('Wrong answer.')\n)"}, {"name": "interpreted_answer", "description": "A value representing the student's answer to this part.", "definition": "qty(student_scalar, student_units)\n\n"}, {"name": "correct_quantity", "description": "", "definition": "settings[\"correctAnswer\"]\n\n"}, {"name": "correct_units", "description": "", "definition": "units(correct_quantity)\n"}, {"name": "allowed_notation_styles", "description": "", "definition": "[\"plain\",\"en\"]"}, {"name": "match_student_number", "description": "", "definition": "matchnumber(studentAnswer,allowed_notation_styles)"}, {"name": "student_scalar", "description": "", "definition": "match_student_number[1]"}, {"name": "student_units", "description": "<p>Modify&nbsp;the&nbsp;unit portion of&nbsp;the student's answer by</p>\n<p>1. replacing \"ohms\" with \"ohm\" &nbsp;case insensitive</p>\n<p>2.&nbsp;replacing '-'&nbsp;with ' '&nbsp;</p>\n<p>3. replacing '&deg;' with ' deg'&nbsp;</p>\n<p>to allow answers like 10 ft-lb and 30&deg;</p>", "definition": "replace_regex('ohms','ohm',\n  replace_regex('\u00b0', ' deg',\n    replace_regex('-', ' ' ,\n      studentAnswer[len(match_student_number[0])..len(studentAnswer)])),\"i\")"}, {"name": "good_units", "description": "", "definition": "try(\ncompatible(quantity(1, student_units),correct_units),\nmsg,\nfeedback(msg);false)\n"}, {"name": "student_quantity", "description": "<p>This fixes the student answer for two common errors. &nbsp;</p>\n<p>If student_units are wrong&nbsp;&nbsp;- replace with correct units</p>\n<p>If student_scalar has the wrong sign - replace with right sign</p>\n<p>If student makes both errors, only one gets fixed.</p>", "definition": "switch(not good_units, \n       student_scalar * correct_units, \n       not right_sign,\n       -quantity(student_scalar, student_units),\n       quantity(student_scalar,student_units)\n)\n  \n"}, {"name": "percent_error", "description": "", "definition": "try(\nscalar(abs((correct_quantity - student_quantity)/correct_quantity))*100  \n,msg,\nif(student_quantity=correct_quantity,0,100))\n   "}, {"name": "right", "description": "", "definition": "percent_error <= settings['right']\n"}, {"name": "close", "description": "<p>Only marked close if the student actually has the right sign.</p>", "definition": "right_sign and percent_error <= settings['close']"}, {"name": "right_sign", "description": "", "definition": "sign(student_scalar) = sign(correct_quantity) "}], "settings": [{"name": "correctAnswer", "label": "Correct Quantity.", "help_url": "", "hint": "The correct answer given as a JME quantity.", "input_type": "code", "default_value": "", "evaluate": true}, {"name": "right", "label": "% Accuracy for right.", "help_url": "", "hint": "Question will be considered correct if the scalar part of the student's answer is within this % of correct value.", "input_type": "code", "default_value": "0.2", "evaluate": true}, {"name": "close", "label": "% Accuracy for close.", "help_url": "", "hint": "Question will be considered close if the scalar part of the student's answer is within this % of correct value.", "input_type": "code", "default_value": "1.0", "evaluate": true}, {"name": "C1", "label": "Close with units.", "help_url": "", "hint": "Partial Credit for close value with appropriate units. &nbsp;if correct answer is 100 N and close is &plusmn;1%,<br />99 &nbsp;N is accepted.", "input_type": "percent", "default_value": "75"}, {"name": "C2", "label": "No units or wrong sign", "help_url": "", "hint": "Partial credit for forgetting units or using wrong sign.<br />If the correct answer is 100 N, both 100 and -100 N are accepted.", "input_type": "percent", "default_value": "50"}, {"name": "C3", "label": "Close, no units.", "help_url": "", "hint": "Partial Credit for close value but forgotten units.<br />This value would be close&nbsp;if the expected units were provided. &nbsp;If the correct answer is 100 N, and close is &plusmn;1%,<br />99 is accepted.", "input_type": "percent", "default_value": "25"}], "public_availability": "always", "published": true, "extensions": ["quantities"]}], "resources": [], "navigation": {"allowregen": true, "showfrontpage": false, "preventleave": false, "typeendtoleave": false}, "contributors": [{"name": "William Haynes", "profile_url": "https://numbas.mathcentre.ac.uk/accounts/profile/2530/"}], "tags": ["beam", "distributed load", "Equilibrium", "equilibrium", "Mechanics", "mechanics", "Statics", "statics"], "metadata": {"description": "<p>Find the reactions of a simply-supported beam with a trapazoidal distributed load.</p>", "licence": "Creative Commons Attribution-ShareAlike 4.0 International"}, "statement": "<p>$\\var{distance(L)}$ long beam $AB$ is subjected to a distributed load that varies as shown. Determine the reactions at $A$ and $B$.</p>\n<p>{loadDiagram}</p>", "advice": "<p></p>\n<ol>\n<li>Determine locations of the centroids and the 'area' under the loading curve for each part.\n<p>$\\begin{align}\\\\ L &amp;= \\var{distance(L)}\\\\W_R &amp;= \\var{force(xr)} &amp; x_R &amp;= \\var{distance(xr)} \\\\<br/>&nbsp;W_T &amp;= \\var{force(wt)} &amp;x_T &amp;= \\var{distance(xt)}\\end{align}$</p>\n</li>\n<li>\n<p>Draw a free body diagram of the beam, replacing the distributed loads with equivalent concentrated loads at the centroids of the triangle and rectangle.</p>\n<p>{fbd}</p>\n</li>\n<li>Find the reactions\n<p>$\\begin{align}\\\\ <br/>\\Sigma M_A &amp;= 0 &nbsp;\\\\<br/>W_R (x_r) + W_T (x_T) &amp;=&nbsp;&nbsp;B (L )\\\\<br/>B &amp;= \\frac{W_R( x_r) + W_T( x_T)}{L} &nbsp;\\\\<br/>&amp;= \\var{force(rb)} \\\\ \\\\ <br/>\\Sigma F_y &amp;= 0 \\\\ A + B &amp;= W_T + W_R \\\\ A &amp;= W_T + W_R - B \\\\ <br/>&amp;= \\var{force(ra)} \\end{align}$</p>\n</li>\n<li>You may check your answer by finding $A$ using $\\Sigma M_B = 0$. &nbsp;You should get the same result either way.</li>\n</ol>\n<p></p>", "rulesets": {}, "builtin_constants": {"e": true, "pi,\u03c0": true, "i": true, "j": false}, "constants": [], "variables": {"w": {"name": "w", "group": "Ungrouped variables", "definition": "random(50..150#10)", "description": "<p>Max value of loading &nbsp;in &nbsp;[force/distance]</p>", "templateType": "anything", "can_override": false}, "WT": {"name": "WT", "group": "solution", "definition": "triangle_base w /2", "description": "<p>weight of the triangular load</p>", "templateType": "anything", "can_override": false}, "WR": {"name": "WR", "group": "solution", "definition": "rectangle_base w", "description": "<p>weight of the rectangular load</p>", "templateType": "anything", "can_override": false}, "WTot": {"name": "WTot", "group": "solution", "definition": "WT + WR", "description": "<p>Total weight of load</p>", "templateType": "anything", "can_override": false}, "xR": {"name": "xR", "group": "solution", "definition": "rectangle_base/2 + rectangle[0]", "description": "<p>location of centroid of rect</p>", "templateType": "anything", "can_override": false}, "xT": {"name": "xT", "group": "solution", "definition": "if(type=0,triangle_base/3, 2 triangle_base/3) + triangle[0]\n ", "description": "<p>Centroid of triangle</p>", "templateType": "anything", "can_override": false}, "L": {"name": "L", "group": "Ungrouped variables", "definition": "random([16,20,24])", "description": "<p>length of beam</p>", "templateType": "anything", "can_override": false}, "units": {"name": "units", "group": "Ungrouped variables", "definition": "random([['ft','lb', 'lb/ft'],['m','kN', 'kN/m']])", "description": "", "templateType": "anything", "can_override": false}, "RB": {"name": "RB", "group": "solution", "definition": "(WR xR + WT xT)/ L", "description": "", "templateType": "anything", "can_override": false}, "RA": {"name": "RA", "group": "solution", "definition": "(WT * (L-xT) + WR * (L-xR ))/ L", "description": "", "templateType": "anything", "can_override": false}, "check": {"name": "check", "group": "solution", "definition": "RA + RB = Wtot", "description": "", "templateType": "anything", "can_override": false}, "properties": {"name": "properties", "group": "diagram", "definition": "[beamLength: L,  loads: loads, symbols: symbols ,  forces: [], moments: [], reactions: []]", "description": "", "templateType": "anything", "can_override": false}, "loads": {"name": "loads", "group": "diagram", "definition": "[\n[ [x: rectangle[0], value: w, label: w + \" \" + units[2], visible: true], \n  [x: rectangle[1], value: w, label: \"\" ] ],\n[ [x: triangle[0], value: if(type=0,w,0), label: \"\" , visible: true], \n  [x: triangle[1], value: if(type=0,0,w), label: \"\" ]\n]\n]\n", "description": "<p>choses between triangle-rectangle and rectangle triangle</p>", "templateType": "anything", "can_override": false}, "symbols": {"name": "symbols", "group": "diagram", "definition": "[[type: \"pin\", x: 0, label: \"$A$\", visible: true], [type: \"roller\", x: L, label: \"$B$\", visible: true]]", "description": "", "templateType": "anything", "can_override": false}, "LoadDiagram": {"name": "LoadDiagram", "group": "diagram", "definition": "vmloaddiagram(properties)", "description": "", "templateType": "anything", "can_override": false}, "uniquePoint": {"name": "uniquePoint", "group": "Ungrouped variables", "definition": "sort(shuffle(0..L)[0..3])", "description": "", "templateType": "anything", "can_override": false}, "type": {"name": "type", "group": "Ungrouped variables", "definition": "random(0,1)", "description": "<p>0 &nbsp;= rect then triangle</p>\n<p>1 = triangle then rect</p>", "templateType": "anything", "can_override": false}, "Rectangle": {"name": "Rectangle", "group": "Ungrouped variables", "definition": "if(type=0,\n  [load_start, load_start+ rectangle_base],\n  [load_start+triangle_base, load_start+triangle_base+rectangle_base])", "description": "", "templateType": "anything", "can_override": false}, "triangle": {"name": "triangle", "group": "Ungrouped variables", "definition": "if(type=0,\n  [load_start+rectangle_base, load_start+ rectangle_base + triangle_base],\n  [load_start, load_start+triangle_base])", "description": "", "templateType": "anything", "can_override": false}, "Triangle_base": {"name": "Triangle_base", "group": "Ungrouped variables", "definition": "6", "description": "", "templateType": "anything", "can_override": false}, "rectangle_base": {"name": "rectangle_base", "group": "Ungrouped variables", "definition": "random(4..L-triangle_base)", "description": "", "templateType": "anything", "can_override": false}, "Load_start": {"name": "Load_start", "group": "Ungrouped variables", "definition": "random(0..L-triangle_base-rectangle_base)", "description": "", "templateType": "anything", "can_override": false}, "distance": {"name": "distance", "group": "quantities", "definition": "d -> qty(d, units[0])", "description": "", "templateType": "anything", "can_override": false}, "force": {"name": "force", "group": "quantities", "definition": "f -> siground(qty(f,units[1]),4)", "description": "", "templateType": "anything", "can_override": false}, "load": {"name": "load", "group": "quantities", "definition": "w -> qty(w,units[2])", "description": "", "templateType": "anything", "can_override": false}, "FBDProperties": {"name": "FBDProperties", "group": "diagram", "definition": "[beamLength: L,  reactions: fbdReactions, loads: fbdloads, symbols: fbdsymbols, moments: [], forces: fbdEquivalentloads]", "description": "", "templateType": "anything", "can_override": false}, "FBDSymbols": {"name": "FBDSymbols", "group": "diagram", "definition": "[[type: \"dot\", x: xt, label: xt, visible: true], [type: \"dot\", x: xr, label: xr, visible: true]]", "description": "", "templateType": "anything", "can_override": false}, "fbd": {"name": "fbd", "group": "diagram", "definition": "vmloaddiagram(fbdproperties)", "description": "", "templateType": "anything", "can_override": false}, "fbdReactions": {"name": "fbdReactions", "group": "diagram", "definition": "[[x: 0, value: ra, label: \"$A$\", visible: true], [x: L, value: rb, label: \"$B$\", visible: true]]\n", "description": "", "templateType": "anything", "can_override": false}, "fbdEquivalentLoads": {"name": "fbdEquivalentLoads", "group": "diagram", "definition": "[[x: xr, value: wr, label: \"$W_R$\", visible: true], [x: xt, value: wt, label: \"$W_T$\", visible: true]]", "description": "", "templateType": "anything", "can_override": false}, "fbdLoads": {"name": "fbdLoads", "group": "diagram", "definition": "[\n[ [x: rectangle[0], value: w, label: \"\" , visible: false], \n  [x: rectangle[1], value: w, label: \"\" ] ],\n[ [x: triangle[0], value: if(type=0,w,0), label: \"\" , visible: false], \n  [x: triangle[1], value: if(type=0,0,w), label: \"\" ]\n]\n]\n", "description": "", "templateType": "anything", "can_override": false}}, "variablesTest": {"condition": "", "maxRuns": 100}, "ungrouped_variables": ["w", "L", "units", "uniquePoint", "type", "Rectangle", "triangle", "Triangle_base", "rectangle_base", "Load_start"], "variable_groups": [{"name": "solution", "variables": ["WT", "WR", "WTot", "xR", "xT", "RB", "RA", "check"]}, {"name": "quantities", "variables": ["distance", "force", "load"]}, {"name": "diagram", "variables": ["properties", "loads", "symbols", "FBDProperties", "FBDSymbols", "fbdReactions", "fbdEquivalentLoads", "fbdLoads", "fbd", "LoadDiagram"]}], "functions": {}, "preamble": {"js": "", "css": ""}, "parts": [{"type": "gapfill", "useCustomName": false, "customName": "", "marks": 0, "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": true, "showFeedbackIcon": true, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "prompt": "<p style=\"padding-left: 40px;\">$A = $&nbsp;[[0]]&nbsp; <br/><br/>$B = $&nbsp;[[1]]&nbsp;&nbsp;</p>", "gaps": [{"type": "engineering-answer", "useCustomName": true, "customName": "$A$", "marks": "10", "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": true, "showFeedbackIcon": true, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "settings": {"correctAnswer": "force(ra)", "right": "0.2", "close": "1.0", "C1": "80", "C2": "80", "C3": "65"}}, {"type": "engineering-answer", "useCustomName": true, "customName": "$B$", "marks": "10", "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": true, "showFeedbackIcon": true, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "settings": {"correctAnswer": "force(rb)", "right": "0.2", "close": "1.0", "C1": "80", "C2": "80", "C3": "65"}}], "sortAnswers": false}], "partsMode": "all", "maxMarks": 0, "objectives": [], "penalties": [], "objectiveVisibility": "always", "penaltyVisibility": "always"}]}], "allowPrinting": true, "navigation": {"allowregen": true, "reverse": true, "browse": true, "allowsteps": true, "showfrontpage": false, "navigatemode": "menu", "onleave": {"action": "none", "message": ""}, "preventleave": false, "typeendtoleave": false, "startpassword": "", "autoSubmit": true, "allowAttemptDownload": false, "downloadEncryptionKey": "", "showresultspage": "oncompletion"}, "timing": {"allowPause": true, "timeout": {"action": "none", "message": ""}, "timedwarning": {"action": "none", "message": ""}}, "feedback": {"enterreviewmodeimmediately": true, "showactualmarkwhen": "always", "showtotalmarkwhen": "always", "showanswerstatewhen": "always", "showpartfeedbackmessageswhen": "always", "showexpectedanswerswhen": "inreview", "showadvicewhen": "inreview", "allowrevealanswer": true, "intro": "", "end_message": "", "results_options": {"printquestions": true, "printadvice": true}, "feedbackmessages": [], "reviewshowexpectedanswer": true, "showanswerstate": true, "reviewshowfeedback": true, "showactualmark": true, "showtotalmark": true, "reviewshowscore": true, "reviewshowadvice": true}, "diagnostic": {"knowledge_graph": {"topics": [], "learning_objectives": []}, "script": "diagnosys", "customScript": ""}, "contributors": [{"name": "William Haynes", "profile_url": "https://numbas.mathcentre.ac.uk/accounts/profile/2530/"}], "extensions": ["geogebra", "jsxgraph", "quantities", "shear-and-bending-moment-diagrams", "sheets"], "custom_part_types": [{"source": {"pk": 19, "author": {"name": "William Haynes", "pk": 2530}, "edit_page": "/part_type/19/edit"}, "name": "Engineering Accuracy with units", "short_name": "engineering-answer", "description": "<p>A value with units marked right if within an adjustable % error of the correct value. &nbsp;Marked close if within a wider margin of error.</p>", "help_url": "", "input_widget": "string", "input_options": {"correctAnswer": "siground(settings['correctAnswer'],4)", "hint": {"static": true, "value": ""}, "allowEmpty": {"static": true, "value": true}}, "can_be_gap": true, "can_be_step": true, "marking_script": "mark:\nswitch( \n  right and good_units and right_sign, add_credit(1.0,'Correct.'),\n  right and good_units and not right_sign, add_credit(settings['C2'],'Wrong sign.'),\n  right and right_sign and not good_units, add_credit(settings['C2'],'Correct value, but wrong or missing units.'),\n  close and good_units, add_credit(settings['C1'],'Close.'),\n  close and not good_units, add_credit(settings['C3'],'Answer is close, but wrong or missing units.'),\n  incorrect('Wrong answer.')\n)\n\ninterpreted_answer:\nqty(student_scalar, student_units)\n\n\n\ncorrect_quantity:\nsettings[\"correctAnswer\"]\n\n\n\ncorrect_units:\nunits(correct_quantity)\n\n\nallowed_notation_styles:\n[\"plain\",\"en\"]\n\nmatch_student_number:\nmatchnumber(studentAnswer,allowed_notation_styles)\n\nstudent_scalar:\nmatch_student_number[1]\n\nstudent_units:\nreplace_regex('ohms','ohm',\n  replace_regex('\u00b0', ' deg',\n    replace_regex('-', ' ' ,\n      studentAnswer[len(match_student_number[0])..len(studentAnswer)])),\"i\")\n\ngood_units:\ntry(\ncompatible(quantity(1, student_units),correct_units),\nmsg,\nfeedback(msg);false)\n\n\nstudent_quantity:\nswitch(not good_units, \n       student_scalar * correct_units, \n       not right_sign,\n       -quantity(student_scalar, student_units),\n       quantity(student_scalar,student_units)\n)\n  \n\n\npercent_error:\ntry(\nscalar(abs((correct_quantity - student_quantity)/correct_quantity))*100  \n,msg,\nif(student_quantity=correct_quantity,0,100))\n   \n\nright:\npercent_error <= settings['right']\n\n\nclose:\nright_sign and percent_error <= settings['close']\n\nright_sign:\nsign(student_scalar) = sign(correct_quantity)", "marking_notes": [{"name": "mark", "description": "This is the main marking note. It should award credit and provide feedback based on the student's answer.", "definition": "switch( \n  right and good_units and right_sign, add_credit(1.0,'Correct.'),\n  right and good_units and not right_sign, add_credit(settings['C2'],'Wrong sign.'),\n  right and right_sign and not good_units, add_credit(settings['C2'],'Correct value, but wrong or missing units.'),\n  close and good_units, add_credit(settings['C1'],'Close.'),\n  close and not good_units, add_credit(settings['C3'],'Answer is close, but wrong or missing units.'),\n  incorrect('Wrong answer.')\n)"}, {"name": "interpreted_answer", "description": "A value representing the student's answer to this part.", "definition": "qty(student_scalar, student_units)\n\n"}, {"name": "correct_quantity", "description": "", "definition": "settings[\"correctAnswer\"]\n\n"}, {"name": "correct_units", "description": "", "definition": "units(correct_quantity)\n"}, {"name": "allowed_notation_styles", "description": "", "definition": "[\"plain\",\"en\"]"}, {"name": "match_student_number", "description": "", "definition": "matchnumber(studentAnswer,allowed_notation_styles)"}, {"name": "student_scalar", "description": "", "definition": "match_student_number[1]"}, {"name": "student_units", "description": "<p>Modify&nbsp;the&nbsp;unit portion of&nbsp;the student's answer by</p>\n<p>1. replacing \"ohms\" with \"ohm\" &nbsp;case insensitive</p>\n<p>2.&nbsp;replacing '-'&nbsp;with ' '&nbsp;</p>\n<p>3. replacing '&deg;' with ' deg'&nbsp;</p>\n<p>to allow answers like 10 ft-lb and 30&deg;</p>", "definition": "replace_regex('ohms','ohm',\n  replace_regex('\u00b0', ' deg',\n    replace_regex('-', ' ' ,\n      studentAnswer[len(match_student_number[0])..len(studentAnswer)])),\"i\")"}, {"name": "good_units", "description": "", "definition": "try(\ncompatible(quantity(1, student_units),correct_units),\nmsg,\nfeedback(msg);false)\n"}, {"name": "student_quantity", "description": "<p>This fixes the student answer for two common errors. &nbsp;</p>\n<p>If student_units are wrong&nbsp;&nbsp;- replace with correct units</p>\n<p>If student_scalar has the wrong sign - replace with right sign</p>\n<p>If student makes both errors, only one gets fixed.</p>", "definition": "switch(not good_units, \n       student_scalar * correct_units, \n       not right_sign,\n       -quantity(student_scalar, student_units),\n       quantity(student_scalar,student_units)\n)\n  \n"}, {"name": "percent_error", "description": "", "definition": "try(\nscalar(abs((correct_quantity - student_quantity)/correct_quantity))*100  \n,msg,\nif(student_quantity=correct_quantity,0,100))\n   "}, {"name": "right", "description": "", "definition": "percent_error <= settings['right']\n"}, {"name": "close", "description": "<p>Only marked close if the student actually has the right sign.</p>", "definition": "right_sign and percent_error <= settings['close']"}, {"name": "right_sign", "description": "", "definition": "sign(student_scalar) = sign(correct_quantity) "}], "settings": [{"name": "correctAnswer", "label": "Correct Quantity.", "help_url": "", "hint": "The correct answer given as a JME quantity.", "input_type": "code", "default_value": "", "evaluate": true}, {"name": "right", "label": "% Accuracy for right.", "help_url": "", "hint": "Question will be considered correct if the scalar part of the student's answer is within this % of correct value.", "input_type": "code", "default_value": "0.2", "evaluate": true}, {"name": "close", "label": "% Accuracy for close.", "help_url": "", "hint": "Question will be considered close if the scalar part of the student's answer is within this % of correct value.", "input_type": "code", "default_value": "1.0", "evaluate": true}, {"name": "C1", "label": "Close with units.", "help_url": "", "hint": "Partial Credit for close value with appropriate units. &nbsp;if correct answer is 100 N and close is &plusmn;1%,<br />99 &nbsp;N is accepted.", "input_type": "percent", "default_value": "75"}, {"name": "C2", "label": "No units or wrong sign", "help_url": "", "hint": "Partial credit for forgetting units or using wrong sign.<br />If the correct answer is 100 N, both 100 and -100 N are accepted.", "input_type": "percent", "default_value": "50"}, {"name": "C3", "label": "Close, no units.", "help_url": "", "hint": "Partial Credit for close value but forgotten units.<br />This value would be close&nbsp;if the expected units were provided. &nbsp;If the correct answer is 100 N, and close is &plusmn;1%,<br />99 is accepted.", "input_type": "percent", "default_value": "25"}], "public_availability": "always", "published": true, "extensions": ["quantities"]}, {"source": {"pk": 242, "author": {"name": "Christian Lawson-Perfect", "pk": 7}, "edit_page": "/part_type/242/edit"}, "name": "Spreadsheet", "short_name": "spreadsheet", "description": "<p>An editable spreadsheet. Ranges of cells can be disabled, and you can specify ranges of cells to be marked. A cell is marked correct if its value is equal to the value in the expected answer spreadsheet.</p>", "help_url": "", "input_widget": "spread-sheet", "input_options": {"correctAnswer": "settings[\"correct_answer\"]", "hint": {"static": true, "value": ""}, "initial_sheet": {"static": false, "value": "disable_cells(settings[\"initial_sheet\"], settings[\"disable_ranges\"])"}}, "can_be_gap": true, "can_be_step": true, "marking_script": "mark:\nif(sum(mark_ranges)=0,\n  incorrect(),\n  apply(mark_ranges)\n)\n\ninterpreted_answer:\nstudentAnswer\n\nrange_cells:\nmap(parse_range(ref),ref,values(settings[\"mark_ranges\"]))\n\ntotal_cells:\nlen(flatten(range_cells))\n\nrange_weights:\nswitch(\n  settings[\"marking_method\"]=\"per_cell\",\n    map(len(r)/total_cells, r, range_cells),\n  // otherwise, mark per range\n    repeat(1/len(range_cells), len(range_cells))\n)\n\nmark_ranges:\nmap(\n  let(\n    range_credit,\n      sum(map(\n        let(\n          correctCellString, correctAnswer[c],\n          correctCellNumber, parsenumber(correctCellString, notation_styles),\n          studentCellString, studentAnswer[c],\n          studentCellNumber, parsenumber(studentCellString, notation_styles),\n          award(\n            1/len(cells), \n            switch(\n              correctCellString=\"\",\n                isnan(studentCellNumber) or studentCellString=\"\",\n              isnan(correctCellNumber),\n                lower(correctCellString) = lower(studentCellString)\n              ,\n                abs(studentCellNumber - if(isnan(correctCellNumber),0,correctCellNumber)) <= settings[\"tolerance\"]\n            )\n          )\n        ),\n        c,\n        cells\n      )),\n    message,\n      switch(\n        range_credit=0,\n          if(len(cells)=1, \"This entry is incorrect.\", \"All entries in this range are incorrect.\"),\n        range_credit=1,\n          if(len(cells)=1, \"This entry is correct.\", \"All entries in this range are correct.\"),\n        //otherwise\n          \"Some entries in this range are correct.\"\n      ),\n    assert(len(cells)=0, add_credit(range_credit*w, \"<strong>{name}:</strong> \"+message)); \n    range_credit\n  ),\n  [cells,w,name],\n  zip(range_cells, range_weights, keys(settings[\"mark_ranges\"]))\n)\n\nnotation_styles:\n[\"plain\",\"si-en\"]\n\ncorrectAnswer:\nsettings[\"correct_answer\"]", "marking_notes": [{"name": "mark", "description": "This is the main marking note. It should award credit and provide feedback based on the student's answer.", "definition": "if(sum(mark_ranges)=0,\n  incorrect(),\n  apply(mark_ranges)\n)"}, {"name": "interpreted_answer", "description": "A value representing the student's answer to this part.", "definition": "studentAnswer"}, {"name": "range_cells", "description": "<p>For each range to be marked, the addresses of the cells in that range.</p>", "definition": "map(parse_range(ref),ref,values(settings[\"mark_ranges\"]))"}, {"name": "total_cells", "description": "<p>The total number of cells to be marked. Cells in overlapping ranges will be counted once for each range they're in.</p>", "definition": "len(flatten(range_cells))"}, {"name": "range_weights", "description": "<p>The weight of each range, as a proportion of the available credit.</p>", "definition": "switch(\n  settings[\"marking_method\"]=\"per_cell\",\n    map(len(r)/total_cells, r, range_cells),\n  // otherwise, mark per range\n    repeat(1/len(range_cells), len(range_cells))\n)"}, {"name": "mark_ranges", "description": "<p>Mark each of the ranges specified by the question author.</p>", "definition": "map(\n  let(\n    range_credit,\n      sum(map(\n        let(\n          correctCellString, correctAnswer[c],\n          correctCellNumber, parsenumber(correctCellString, notation_styles),\n          studentCellString, studentAnswer[c],\n          studentCellNumber, parsenumber(studentCellString, notation_styles),\n          award(\n            1/len(cells), \n            switch(\n              correctCellString=\"\",\n                isnan(studentCellNumber) or studentCellString=\"\",\n              isnan(correctCellNumber),\n                lower(correctCellString) = lower(studentCellString)\n              ,\n                abs(studentCellNumber - if(isnan(correctCellNumber),0,correctCellNumber)) <= settings[\"tolerance\"]\n            )\n          )\n        ),\n        c,\n        cells\n      )),\n    message,\n      switch(\n        range_credit=0,\n          if(len(cells)=1, \"This entry is incorrect.\", \"All entries in this range are incorrect.\"),\n        range_credit=1,\n          if(len(cells)=1, \"This entry is correct.\", \"All entries in this range are correct.\"),\n        //otherwise\n          \"Some entries in this range are correct.\"\n      ),\n    assert(len(cells)=0, add_credit(range_credit*w, \"<strong>{name}:</strong> \"+message)); \n    range_credit\n  ),\n  [cells,w,name],\n  zip(range_cells, range_weights, keys(settings[\"mark_ranges\"]))\n)"}, {"name": "notation_styles", "description": "<p>Accepted number notation styles for a value in an individual cell.</p>", "definition": "[\"plain\",\"si-en\"]"}, {"name": "correctAnswer", "description": "", "definition": "settings[\"correct_answer\"]"}], "settings": [{"name": "initial_sheet", "label": "Initial sheet", "help_url": "", "hint": "A <code>spreadsheet</code> object giving the initial state of the sheet that the student should fill in.", "input_type": "code", "default_value": "", "evaluate": true}, {"name": "correct_answer", "label": "Correct answer", "help_url": "", "hint": "A <code>spreadsheet</code> object representing a correct answer to the part.", "input_type": "code", "default_value": "", "evaluate": true}, {"name": "disable_ranges", "label": "Ranges to disable", "help_url": "", "hint": "A list of cell or range references, denoting the cells that should not be editable.", "input_type": "code", "default_value": "[]", "evaluate": true}, {"name": "mark_ranges", "label": "Ranges to mark", "help_url": "", "hint": "A dictionary of cell or range references, mapping names to ranges of cells, denoting the cells that should be compared for equality with the expected answer.", "input_type": "code", "default_value": "dict()", "evaluate": true}, {"name": "marking_method", "label": "Marking method", "help_url": "", "hint": "", "input_type": "dropdown", "default_value": "per_cell", "choices": [{"value": "per_cell", "label": "Each cell has the same weight"}, {"value": "per_range", "label": "Each range has the same weight"}]}, {"name": "tolerance", "label": "Allowed margin of error", "help_url": "", "hint": "", "input_type": "code", "default_value": "0", "evaluate": true}], "public_availability": "always", "published": true, "extensions": ["sheets"]}], "resources": [["question-resources/centroids.png", "/srv/numbas/media/question-resources/centroids.png"], ["question-resources/centroids_3A0rXlj.png", "/srv/numbas/media/question-resources/centroids_3A0rXlj.png"], ["question-resources/centroids_zSOgoBb.png", "/srv/numbas/media/question-resources/centroids_zSOgoBb.png"], ["question-resources/centroid-t-r.ggb", "/srv/numbas/media/question-resources/centroid-t-r.ggb"], ["question-resources/centroid-integration.ggb", "/srv/numbas/media/question-resources/centroid-integration.ggb"], ["question-resources/dist-load.ggb", "/srv/numbas/media/question-resources/dist-load.ggb"]]}