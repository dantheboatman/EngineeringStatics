// Numbas version: exam_results_page_options
{"name": "Chapter 5 Exercises", "metadata": {"description": "<p>End of chapter exercises for <a href=\"http://engineeringstatics.org\"><em>Engineering Statics: Open and Interactive</em></a>&nbsp;</p>", "licence": "Creative Commons Attribution-NonCommercial 4.0 International"}, "duration": 0, "percentPass": 0, "showQuestionGroupNames": false, "shuffleQuestionGroups": false, "showstudentname": true, "question_groups": [{"name": "Group", "pickingStrategy": "all-ordered", "pickQuestions": 1, "questionNames": ["Tension in a cable", "Raise pole", "Cantilever beam", "EquBeam and pulley", "Bell crank", "Car on a hill", "Hand truck", "Triangle", "Truss"], "variable_overrides": [[], [], [], [], [], [], [], [], []], "questions": [{"name": "Moment Balance: Tension in a cable", "extensions": ["geogebra", "quantities"], "custom_part_types": [{"source": {"pk": 19, "author": {"name": "William Haynes", "pk": 2530}, "edit_page": "/part_type/19/edit"}, "name": "Engineering Accuracy with units", "short_name": "engineering-answer", "description": "<p>A value with units marked right if within an adjustable % error of the correct value. &nbsp;Marked close if within a wider margin of error.</p>", "help_url": "", "input_widget": "string", "input_options": {"correctAnswer": "siground(settings['correctAnswer'],4)", "hint": {"static": true, "value": ""}, "allowEmpty": {"static": true, "value": true}}, "can_be_gap": true, "can_be_step": true, "marking_script": "mark:\nswitch( \n  right and good_units and right_sign, add_credit(1.0,'Correct.'),\n  right and good_units and not right_sign, add_credit(settings['C2'],'Wrong sign.'),\n  right and right_sign and not good_units, add_credit(settings['C2'],'Correct value, but wrong or missing units.'),\n  close and good_units, add_credit(settings['C1'],'Close.'),\n  close and not good_units, add_credit(settings['C3'],'Answer is close, but wrong or missing units.'),\n  incorrect('Wrong answer.')\n)\n\n\ninterpreted_answer:\nqty(student_scalar, student_units)\n\n\n\ncorrect_quantity:\nsettings[\"correctAnswer\"]\n\n\n\ncorrect_units:\nunits(correct_quantity)\n\n\nallowed_notation_styles:\n[\"plain\",\"en\"]\n\nmatch_student_number:\nmatchnumber(studentAnswer,allowed_notation_styles)\n\nstudent_scalar:\nmatch_student_number[1]\n\nstudent_units:\nreplace_regex('ohms','ohm',\n  replace_regex('\u00b0', ' deg',\n    replace_regex('-', ' ' ,\n      studentAnswer[len(match_student_number[0])..len(studentAnswer)])),\"i\")\n\ngood_units:\ntry(\ncompatible(quantity(1, student_units),correct_units),\nmsg,\nfeedback(msg);false)\n\n\nstudent_quantity:\nswitch(not good_units, \n       student_scalar * correct_units, \n       not right_sign,\n       -quantity(student_scalar, student_units),\n       quantity(student_scalar,student_units)\n)\n  \n\n\npercent_error:\ntry(\nscalar(abs((correct_quantity - student_quantity)/correct_quantity))*100  \n,msg,\nif(student_quantity=correct_quantity,0,100))\n   \n\nright:\npercent_error <= settings['right']\n\n\nclose:\nright_sign and percent_error <= settings['close']\n\nright_sign:\nsign(student_scalar) = sign(correct_quantity)", "marking_notes": [{"name": "mark", "description": "This is the main marking note. It should award credit and provide feedback based on the student's answer.", "definition": "switch( \n  right and good_units and right_sign, add_credit(1.0,'Correct.'),\n  right and good_units and not right_sign, add_credit(settings['C2'],'Wrong sign.'),\n  right and right_sign and not good_units, add_credit(settings['C2'],'Correct value, but wrong or missing units.'),\n  close and good_units, add_credit(settings['C1'],'Close.'),\n  close and not good_units, add_credit(settings['C3'],'Answer is close, but wrong or missing units.'),\n  incorrect('Wrong answer.')\n)\n"}, {"name": "interpreted_answer", "description": "A value representing the student's answer to this part.", "definition": "qty(student_scalar, student_units)\n\n"}, {"name": "correct_quantity", "description": "", "definition": "settings[\"correctAnswer\"]\n\n"}, {"name": "correct_units", "description": "", "definition": "units(correct_quantity)\n"}, {"name": "allowed_notation_styles", "description": "", "definition": "[\"plain\",\"en\"]"}, {"name": "match_student_number", "description": "", "definition": "matchnumber(studentAnswer,allowed_notation_styles)"}, {"name": "student_scalar", "description": "", "definition": "match_student_number[1]"}, {"name": "student_units", "description": "<p>Modify&nbsp;the&nbsp;unit portion of&nbsp;the student's answer by</p>\n<p>1. replacing \"ohms\" with \"ohm\" &nbsp;case insensitive</p>\n<p>2.&nbsp;replacing '-'&nbsp;with ' '&nbsp;</p>\n<p>3. replacing '&deg;' with ' deg'&nbsp;</p>\n<p>to allow answers like 10 ft-lb and 30&deg;</p>", "definition": "replace_regex('ohms','ohm',\n  replace_regex('\u00b0', ' deg',\n    replace_regex('-', ' ' ,\n      studentAnswer[len(match_student_number[0])..len(studentAnswer)])),\"i\")"}, {"name": "good_units", "description": "", "definition": "try(\ncompatible(quantity(1, student_units),correct_units),\nmsg,\nfeedback(msg);false)\n"}, {"name": "student_quantity", "description": "<p>This fixes the student answer for two common errors. &nbsp;</p>\n<p>If student_units are wrong&nbsp;&nbsp;- replace with correct units</p>\n<p>If student_scalar has the wrong sign - replace with right sign</p>\n<p>If student makes both errors, only one gets fixed.</p>", "definition": "switch(not good_units, \n       student_scalar * correct_units, \n       not right_sign,\n       -quantity(student_scalar, student_units),\n       quantity(student_scalar,student_units)\n)\n  \n"}, {"name": "percent_error", "description": "", "definition": "try(\nscalar(abs((correct_quantity - student_quantity)/correct_quantity))*100  \n,msg,\nif(student_quantity=correct_quantity,0,100))\n   "}, {"name": "right", "description": "", "definition": "percent_error <= settings['right']\n"}, {"name": "close", "description": "<p>Only marked close if the student actually has the right sign.</p>", "definition": "right_sign and percent_error <= settings['close']"}, {"name": "right_sign", "description": "", "definition": "sign(student_scalar) = sign(correct_quantity) "}], "settings": [{"name": "correctAnswer", "label": "Correct Quantity.", "help_url": "", "hint": "The correct answer given as a JME quantity.", "input_type": "code", "default_value": "", "evaluate": true}, {"name": "right", "label": "% Accuracy for right.", "help_url": "", "hint": "Question will be considered correct if the scalar part of the student's answer is within this % of correct value.", "input_type": "code", "default_value": "0.2", "evaluate": true}, {"name": "close", "label": "% Accuracy for close.", "help_url": "", "hint": "Question will be considered close if the scalar part of the student's answer is within this % of correct value.", "input_type": "code", "default_value": "1.0", "evaluate": true}, {"name": "C1", "label": "Close with units.", "help_url": "", "hint": "Partial Credit for close value with appropriate units. &nbsp;if correct answer is 100 N and close is &plusmn;1%,<br />99 &nbsp;N is accepted.", "input_type": "percent", "default_value": "75"}, {"name": "C2", "label": "No units or wrong sign", "help_url": "", "hint": "Partial credit for forgetting units or using wrong sign.<br />If the correct answer is 100 N, both 100 and -100 N are accepted.", "input_type": "percent", "default_value": "50"}, {"name": "C3", "label": "Close, no units.", "help_url": "", "hint": "Partial Credit for close value but forgotten units.<br />This value would be close&nbsp;if the expected units were provided. &nbsp;If the correct answer is 100 N, and close is &plusmn;1%,<br />99 is accepted.", "input_type": "percent", "default_value": "25"}], "public_availability": "always", "published": true, "extensions": ["quantities"]}], "resources": [], "navigation": {"allowregen": true, "showfrontpage": false, "preventleave": false, "typeendtoleave": false}, "contributors": [{"name": "William Haynes", "profile_url": "https://numbas.mathcentre.ac.uk/accounts/profile/2530/"}], "tags": ["Mechanics, statics, moment, 2-d, tension"], "metadata": {"description": "<p>Find the force required to produce a given moment, or vice-versa.</p>", "licence": "Creative Commons Attribution-NonCommercial 4.0 International"}, "statement": "<p>{applet}</p>\n<p>Control arm $AB$ is subjected to a {direction} moment $M$ and held in position by cable $AC$.&nbsp;</p>\n<p><span data-jme-visible=\"version=0\">Knowing that the moment&nbsp;is {M} {direction}, determine the tension in the cable.</span></p>\n<p><span data-jme-visible=\"version=1\">Knowing that the tension in the cable&nbsp;is {T}, determine the magnitude of the moment $M$.</span></p>", "advice": "<p>Equate the applied moment $M$ to the moment produced by the force.</p>\n<p>$\\Sigma M_B = 0 \\therefore&nbsp;M = F d_\\perp$</p>\n<p>Use geometry to find $d_\\perp$ then solve for the unknown quantity.</p>", "rulesets": {}, "builtin_constants": {"e": true, "pi,\u03c0": true, "i": true}, "constants": [], "variables": {"dperp": {"name": "dperp", "group": "Ungrouped variables", "definition": "L sin(radians(alpha))", "description": "", "templateType": "anything", "can_override": false}, "T": {"name": "T", "group": "Inputs", "definition": "qty(random(1..5)random(2,4,5,10),units[1])", "description": "<p>Used when T is given.</p>", "templateType": "anything", "can_override": false}, "debug": {"name": "debug", "group": "ggb", "definition": "false", "description": "", "templateType": "anything", "can_override": false}, "direction": {"name": "direction", "group": "Ungrouped variables", "definition": "if(A[0]>C[0],'clockwise','counterclockwise')", "description": "", "templateType": "anything", "can_override": false}, "C": {"name": "C", "group": "Inputs", "definition": "vector(random(0..24#4),random(0..32#4))", "description": "", "templateType": "anything", "can_override": false}, "L": {"name": "L", "group": "Ungrouped variables", "definition": "qty(abs(A),units[0])", "description": "", "templateType": "anything", "can_override": false}, "A": {"name": "A", "group": "Inputs", "definition": "vector(random(-28..28#4 except 0),random(8..28#4))", "description": "", "templateType": "anything", "can_override": false}, "answers": {"name": "answers", "group": "Inputs", "definition": "[['T', M/dperp], \n ['M', T*dperp]]\n\n", "description": "", "templateType": "anything", "can_override": false}, "M": {"name": "M", "group": "Inputs", "definition": "qty(random(1..9)random(12, 24,36,48), units[0] + \" \" + units[1])\n", "description": "<p>Used when M is given.</p>", "templateType": "anything", "can_override": false}, "units": {"name": "units", "group": "Inputs", "definition": "['in','lb']\n", "description": "", "templateType": "anything", "can_override": false}, "version": {"name": "version", "group": "Inputs", "definition": "random(0..1)", "description": "<p>Which version?</p>", "templateType": "anything", "can_override": false}, "alpha": {"name": "alpha", "group": "Ungrouped variables", "definition": "degrees(angle(-A,C-A))", "description": "", "templateType": "anything", "can_override": false}, "applet": {"name": "applet", "group": "ggb", "definition": "geogebra_applet('msspdvgu', params)", "description": "", "templateType": "anything", "can_override": false}, "params": {"name": "params", "group": "ggb", "definition": "[A: A, C: C, show: [definition: 'false', visible: false]]", "description": "", "templateType": "anything", "can_override": false}}, "variablesTest": {"condition": "abs(A) > 18 and abs(A-C) > 16 and abs(C) > 16", "maxRuns": 100}, "ungrouped_variables": ["L", "alpha", "dperp", "direction"], "variable_groups": [{"name": "Inputs", "variables": ["C", "A", "T", "M", "version", "answers", "units"]}, {"name": "ggb", "variables": ["applet", "params", "debug"]}], "functions": {}, "preamble": {"js": "question.signals.on('adviceDisplayed',function() {\n try{\n    var app = question.scope.variables.applet.app;  \n    app.setVisible(\"show\", true,false);\n    app.setValue(\"show\", 1);\n  }\n  catch(err){}  \n})", "css": ""}, "parts": [{"type": "gapfill", "useCustomName": true, "customName": "Answer", "marks": 0, "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": true, "showFeedbackIcon": true, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "prompt": "<p>{latex(answers[version][0])} =&nbsp;[[0]]</p>\n<div data-jme-visible=\"debug\">\n<p><em>{answers[version][0]}</em> = {siground(answers[version][1],5)}&nbsp;</p>\n<p></p>\n</div>", "gaps": [{"type": "engineering-answer", "useCustomName": true, "customName": "Answer", "marks": "4", "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": true, "showFeedbackIcon": true, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "settings": {"correctAnswer": "answers[version][1]", "right": "0.2", "close": "1.0", "C1": "75", "C2": "50", "C3": "25"}}], "sortAnswers": false}], "partsMode": "all", "maxMarks": 0, "objectives": [], "penalties": [], "objectiveVisibility": "always", "penaltyVisibility": "always"}, {"name": "Equilibrium of a rigid body: raise pole", "extensions": ["geogebra", "quantities"], "custom_part_types": [{"source": {"pk": 12, "author": {"name": "William Haynes", "pk": 2530}, "edit_page": "/part_type/12/edit"}, "name": "Angle quantity 2020", "short_name": "angle", "description": "<p>Adjusts all angles to 0 &lt; $\\theta$ &lt; 360.</p>\n<p>Accepts '&deg;' and 'deg' as units.</p>\n<p>Penalizes if not close enough or no units.</p>\n<p>90&deg; = -270&deg; = 450&deg;</p>", "help_url": "", "input_widget": "string", "input_options": {"correctAnswer": "plain_string(settings['expected_answer']) ", "hint": {"static": true, "value": ""}, "allowEmpty": {"static": true, "value": false}}, "can_be_gap": true, "can_be_step": true, "marking_script": "original_student_scalar:\nmatchnumber(studentAnswer,['plain','en'])[1]\n\nstudent_scalar:\nmod(original_student_scalar,360)\n\n\nstudent_unit:\nstudentAnswer[len(matchnumber(studentAnswer,['plain','en'])[0])..len(studentAnswer)]\n\ninterpreted_unit:\nif(trim(student_unit)='\u00b0','deg',student_unit)\n\ninterpreted_answer:\nqty(mod(student_scalar,360),'deg')\n\nclose:\nwithintolerance(student_scalar, correct_scalar,decimal(settings['close_tol']))\n\ncorrect_scalar:\nmod(scalar(settings['expected_answer']),360)\n\nright:\nwithintolerance(student_scalar, correct_scalar, decimal(settings['right_tol']))\n\ngood_unit:\nsame(qty(1,interpreted_unit),qty(1,'deg'))\n\nmark:\nassert(close,incorrect('Incorrect.');end());\nif(right,correct('Correct angle.'), set_credit(1 - settings['close_penalty'],'Angle is close.'));\nassert(good_unit,sub_credit(settings['unit_penalty'], 'Missing or incorrect units.'))", "marking_notes": [{"name": "original_student_scalar", "description": "<p>Retuns the scalar part of students answer (which is a quantity) as a number.</p>", "definition": "matchnumber(studentAnswer,['plain','en'])[1]"}, {"name": "student_scalar", "description": "<p>Normalize angle with mod 360</p>", "definition": "mod(original_student_scalar,360)\n"}, {"name": "student_unit", "description": "<p>matchnumber(studentAnswer,['plain','en'])[0] is a string \"12.34\"</p>", "definition": "studentAnswer[len(matchnumber(studentAnswer,['plain','en'])[0])..len(studentAnswer)]"}, {"name": "interpreted_unit", "description": "<p>Allows student to use degree symbol or 'deg' for units.</p>", "definition": "if(trim(student_unit)='\u00b0','deg',student_unit)"}, {"name": "interpreted_answer", "description": "A value representing the student's answer to this part.", "definition": "qty(mod(student_scalar,360),'deg')"}, {"name": "close", "description": "", "definition": "withintolerance(student_scalar, correct_scalar,decimal(settings['close_tol']))"}, {"name": "correct_scalar", "description": "<p>Normalize expected_answer with mod 360</p>", "definition": "mod(scalar(settings['expected_answer']),360)"}, {"name": "right", "description": "", "definition": "withintolerance(student_scalar, correct_scalar, decimal(settings['right_tol']))"}, {"name": "good_unit", "description": "", "definition": "same(qty(1,interpreted_unit),qty(1,'deg'))"}, {"name": "mark", "description": "This is the main marking note. It should award credit and provide feedback based on the student's answer.", "definition": "assert(close,incorrect('Incorrect.');end());\nif(right,correct('Correct angle.'), set_credit(1 - settings['close_penalty'],'Angle is close.'));\nassert(good_unit,sub_credit(settings['unit_penalty'], 'Missing or incorrect units.'))"}], "settings": [{"name": "expected_answer", "label": "Expected Answer", "help_url": "", "hint": "Expected angle as a quantity.", "input_type": "code", "default_value": "qty(30,'deg')", "evaluate": true}, {"name": "unit_penalty", "label": "Unit penalty", "help_url": "", "hint": "Penalty for not including degree sign or 'deg'.", "input_type": "percent", "default_value": "20"}, {"name": "close_penalty", "label": "Close Penalty", "help_url": "", "hint": "Penalty for close answer.", "input_type": "percent", "default_value": "20"}, {"name": "close_tol", "label": "Close", "help_url": "", "hint": "Angle must be $\\pm$ this many degrees to be marked close. &nbsp;&nbsp;", "input_type": "code", "default_value": "0.5", "evaluate": false}, {"name": "right_tol", "label": "Right ", "help_url": "", "hint": "Angle must be $\\pm$ this many degrees to be marked correct. &nbsp;", "input_type": "code", "default_value": "0.1", "evaluate": false}], "public_availability": "restricted", "published": false, "extensions": ["quantities"]}, {"source": {"pk": 19, "author": {"name": "William Haynes", "pk": 2530}, "edit_page": "/part_type/19/edit"}, "name": "Engineering Accuracy with units", "short_name": "engineering-answer", "description": "<p>A value with units marked right if within an adjustable % error of the correct value. &nbsp;Marked close if within a wider margin of error.</p>", "help_url": "", "input_widget": "string", "input_options": {"correctAnswer": "siground(settings['correctAnswer'],4)", "hint": {"static": true, "value": ""}, "allowEmpty": {"static": true, "value": true}}, "can_be_gap": true, "can_be_step": true, "marking_script": "mark:\nswitch( \n  right and good_units and right_sign, add_credit(1.0,'Correct.'),\n  right and good_units and not right_sign, add_credit(settings['C2'],'Wrong sign.'),\n  right and right_sign and not good_units, add_credit(settings['C2'],'Correct value, but wrong or missing units.'),\n  close and good_units, add_credit(settings['C1'],'Close.'),\n  close and not good_units, add_credit(settings['C3'],'Answer is close, but wrong or missing units.'),\n  incorrect('Wrong answer.')\n)\n\n\ninterpreted_answer:\nqty(student_scalar, student_units)\n\n\n\ncorrect_quantity:\nsettings[\"correctAnswer\"]\n\n\n\ncorrect_units:\nunits(correct_quantity)\n\n\nallowed_notation_styles:\n[\"plain\",\"en\"]\n\nmatch_student_number:\nmatchnumber(studentAnswer,allowed_notation_styles)\n\nstudent_scalar:\nmatch_student_number[1]\n\nstudent_units:\nreplace_regex('ohms','ohm',\n  replace_regex('\u00b0', ' deg',\n    replace_regex('-', ' ' ,\n      studentAnswer[len(match_student_number[0])..len(studentAnswer)])),\"i\")\n\ngood_units:\ntry(\ncompatible(quantity(1, student_units),correct_units),\nmsg,\nfeedback(msg);false)\n\n\nstudent_quantity:\nswitch(not good_units, \n       student_scalar * correct_units, \n       not right_sign,\n       -quantity(student_scalar, student_units),\n       quantity(student_scalar,student_units)\n)\n  \n\n\npercent_error:\ntry(\nscalar(abs((correct_quantity - student_quantity)/correct_quantity))*100  \n,msg,\nif(student_quantity=correct_quantity,0,100))\n   \n\nright:\npercent_error <= settings['right']\n\n\nclose:\nright_sign and percent_error <= settings['close']\n\nright_sign:\nsign(student_scalar) = sign(correct_quantity)", "marking_notes": [{"name": "mark", "description": "This is the main marking note. It should award credit and provide feedback based on the student's answer.", "definition": "switch( \n  right and good_units and right_sign, add_credit(1.0,'Correct.'),\n  right and good_units and not right_sign, add_credit(settings['C2'],'Wrong sign.'),\n  right and right_sign and not good_units, add_credit(settings['C2'],'Correct value, but wrong or missing units.'),\n  close and good_units, add_credit(settings['C1'],'Close.'),\n  close and not good_units, add_credit(settings['C3'],'Answer is close, but wrong or missing units.'),\n  incorrect('Wrong answer.')\n)\n"}, {"name": "interpreted_answer", "description": "A value representing the student's answer to this part.", "definition": "qty(student_scalar, student_units)\n\n"}, {"name": "correct_quantity", "description": "", "definition": "settings[\"correctAnswer\"]\n\n"}, {"name": "correct_units", "description": "", "definition": "units(correct_quantity)\n"}, {"name": "allowed_notation_styles", "description": "", "definition": "[\"plain\",\"en\"]"}, {"name": "match_student_number", "description": "", "definition": "matchnumber(studentAnswer,allowed_notation_styles)"}, {"name": "student_scalar", "description": "", "definition": "match_student_number[1]"}, {"name": "student_units", "description": "<p>Modify&nbsp;the&nbsp;unit portion of&nbsp;the student's answer by</p>\n<p>1. replacing \"ohms\" with \"ohm\" &nbsp;case insensitive</p>\n<p>2.&nbsp;replacing '-'&nbsp;with ' '&nbsp;</p>\n<p>3. replacing '&deg;' with ' deg'&nbsp;</p>\n<p>to allow answers like 10 ft-lb and 30&deg;</p>", "definition": "replace_regex('ohms','ohm',\n  replace_regex('\u00b0', ' deg',\n    replace_regex('-', ' ' ,\n      studentAnswer[len(match_student_number[0])..len(studentAnswer)])),\"i\")"}, {"name": "good_units", "description": "", "definition": "try(\ncompatible(quantity(1, student_units),correct_units),\nmsg,\nfeedback(msg);false)\n"}, {"name": "student_quantity", "description": "<p>This fixes the student answer for two common errors. &nbsp;</p>\n<p>If student_units are wrong&nbsp;&nbsp;- replace with correct units</p>\n<p>If student_scalar has the wrong sign - replace with right sign</p>\n<p>If student makes both errors, only one gets fixed.</p>", "definition": "switch(not good_units, \n       student_scalar * correct_units, \n       not right_sign,\n       -quantity(student_scalar, student_units),\n       quantity(student_scalar,student_units)\n)\n  \n"}, {"name": "percent_error", "description": "", "definition": "try(\nscalar(abs((correct_quantity - student_quantity)/correct_quantity))*100  \n,msg,\nif(student_quantity=correct_quantity,0,100))\n   "}, {"name": "right", "description": "", "definition": "percent_error <= settings['right']\n"}, {"name": "close", "description": "<p>Only marked close if the student actually has the right sign.</p>", "definition": "right_sign and percent_error <= settings['close']"}, {"name": "right_sign", "description": "", "definition": "sign(student_scalar) = sign(correct_quantity) "}], "settings": [{"name": "correctAnswer", "label": "Correct Quantity.", "help_url": "", "hint": "The correct answer given as a JME quantity.", "input_type": "code", "default_value": "", "evaluate": true}, {"name": "right", "label": "% Accuracy for right.", "help_url": "", "hint": "Question will be considered correct if the scalar part of the student's answer is within this % of correct value.", "input_type": "code", "default_value": "0.2", "evaluate": true}, {"name": "close", "label": "% Accuracy for close.", "help_url": "", "hint": "Question will be considered close if the scalar part of the student's answer is within this % of correct value.", "input_type": "code", "default_value": "1.0", "evaluate": true}, {"name": "C1", "label": "Close with units.", "help_url": "", "hint": "Partial Credit for close value with appropriate units. &nbsp;if correct answer is 100 N and close is &plusmn;1%,<br />99 &nbsp;N is accepted.", "input_type": "percent", "default_value": "75"}, {"name": "C2", "label": "No units or wrong sign", "help_url": "", "hint": "Partial credit for forgetting units or using wrong sign.<br />If the correct answer is 100 N, both 100 and -100 N are accepted.", "input_type": "percent", "default_value": "50"}, {"name": "C3", "label": "Close, no units.", "help_url": "", "hint": "Partial Credit for close value but forgotten units.<br />This value would be close&nbsp;if the expected units were provided. &nbsp;If the correct answer is 100 N, and close is &plusmn;1%,<br />99 is accepted.", "input_type": "percent", "default_value": "25"}], "public_availability": "always", "published": true, "extensions": ["quantities"]}], "resources": [], "navigation": {"allowregen": true, "showfrontpage": false, "preventleave": false, "typeendtoleave": false}, "contributors": [{"name": "William Haynes", "profile_url": "https://numbas.mathcentre.ac.uk/accounts/profile/2530/"}], "tags": ["angle from reference", "Equilibrium", "equilibrium", "Mechanics", "mechanics", "Rigid Body", "rigid body", "Statics", "statics"], "metadata": {"description": "<p>Equilibrium of a rigid body. &nbsp;Find tension to raise a pole.</p>", "licence": "Creative Commons Attribution-NonCommercial 4.0 International"}, "statement": "<p>{geogebra_applet('pf8c3vcn',[['&alpha;',alpha +'&deg;'],['&beta;',beta&nbsp;+'&deg;']])}</p>\n<p>A {mass} homogeneous pole with a length of {L} is being raised by pulling with a cable at $B$.</p>", "advice": "<p>This problem can be solved by the standard method:</p>\n<ol>\n<li>Draw a free body diagram of the pole. &nbsp;Include the weight of the pole at the center of gravity. &nbsp;Note that mass must be converted to weight.</li>\n<li>Use $\\Sigma M_A = 0$&nbsp;to find <em>$T$.</em></li>\n<li>Use $\\Sigma F_x = 0$ and&nbsp; $\\Sigma F_y = 0$ to find $A_x$ and $A_y$.</li>\n<li>Resolve&nbsp; $A_x$ and $A_y$ to find magnitude and direction of $\\mathbf{A}$.</li>\n</ol>\n<p>It can also be solved using the three force body principle.</p>\n<ol>\n<li>Find the point of intersection of the lines of action of the weight and the tension.</li>\n<li>Determine the direction of force $\\mathbf{A}$. &nbsp;Its line of action must pass through the point.</li>\n<li>Draw a force triangle.</li>\n<li>Determine the angles in the force triangle.</li>\n<li>Use the known weight and the law of sines to solve for the tension and the reaction at $A$.</li>\n</ol>", "rulesets": {}, "builtin_constants": {"e": true, "pi,\u03c0": true, "i": true}, "constants": [], "variables": {"L": {"name": "L", "group": "inputs", "definition": "qty(random(3..5#0.2),'m')", "description": "", "templateType": "anything", "can_override": false}, "theta_T": {"name": "theta_T", "group": "Ungrouped variables", "definition": "180 + alpha - beta", "description": "", "templateType": "anything", "can_override": false}, "T": {"name": "T", "group": "Ungrouped variables", "definition": "scalar(weight)  cos(radians(alpha))/(2 sin(radians(beta)) )\nvector(cos(radians(theta_t)),sin(radians(theta_t)))", "description": "", "templateType": "anything", "can_override": false}, "A": {"name": "A", "group": "Ungrouped variables", "definition": "-(W+T)", "description": "", "templateType": "anything", "can_override": false}, "W": {"name": "W", "group": "Ungrouped variables", "definition": "vector(0,-scalar(weight))", "description": "", "templateType": "anything", "can_override": false}, "theta_A": {"name": "theta_A", "group": "Ungrouped variables", "definition": "mod(degrees(atan2(A[1],A[0])),360)", "description": "", "templateType": "anything", "can_override": false}, "mass": {"name": "mass", "group": "inputs", "definition": "qty(random(10..150#5),'kg')", "description": "", "templateType": "anything", "can_override": false}, "beta": {"name": "beta", "group": "inputs", "definition": "random(20..(90+alpha-20))", "description": "<p>angle between pole and rope</p>", "templateType": "anything", "can_override": false}, "weight": {"name": "weight", "group": "inputs", "definition": "mass * qty(9.81,'m/s^2') in 'N'", "description": "", "templateType": "anything", "can_override": false}, "debug": {"name": "debug", "group": "Ungrouped variables", "definition": "false", "description": "", "templateType": "anything", "can_override": false}, "alpha": {"name": "alpha", "group": "inputs", "definition": "random(20..80)", "description": "<p>angle of pole</p>", "templateType": "anything", "can_override": false}}, "variablesTest": {"condition": "", "maxRuns": 100}, "ungrouped_variables": ["W", "T", "theta_T", "A", "theta_A", "debug"], "variable_groups": [{"name": "inputs", "variables": ["alpha", "mass", "beta", "weight", "L"]}], "functions": {}, "preamble": {"js": "", "css": ""}, "parts": [{"type": "gapfill", "useCustomName": true, "customName": "Tension", "marks": 0, "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": true, "showFeedbackIcon": true, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "prompt": "<p>What is the tension in the cable?</p>\n<p>$T$= [[0]] &nbsp;<span data-jme-visible=\"debug\">T = {siground(abs(T),4)} N</span></p>", "gaps": [{"type": "engineering-answer", "useCustomName": true, "customName": "Tension", "marks": "10", "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": true, "showFeedbackIcon": true, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "settings": {"correctAnswer": "qty(abs(T),'N')", "right": "0.2", "close": "1.0", "C1": "75", "C2": "50", "C3": "25"}}], "sortAnswers": false}, {"type": "gapfill", "useCustomName": true, "customName": "Reaction at A", "marks": 0, "scripts": {}, "customMarkingAlgorithm": "interpreted_angle:  // a qty string corrected to standard angle\n  student_angle[2]  + student_angle[1] * student_angle[0] + student_units\n\nmagnitude:\n  studentAnswer[3]\n\nstudent_angle:\n  [mod(matchnumber(studentAnswer[0],['plain','en'])[1],360), // angle\n  [1,-1][indices(studentAnswer[1],[true])[0]],      // ccw = 1 cw = -1\n  [0,90,180,-90][indices(studentAnswer[2],[true])[0]]] // reference axis\n\nstudent_units:\n  studentAnswer[0][len(matchnumber(studentAnswer[0],['plain','en'])[0])..len(studentAnswer[0])]\n\ninterpreted_answers:\n  [interpreted_angle, studentAnswer[1], studentAnswer[2], studentAnswer[3]]\n\ngap_feedback (Feedback on each of the gaps):\n    map(\n        try(\n            let(\n                result, submit_part(gaps[gap_number][\"path\"],answer),\n                gap, gaps[gap_number],\n                name, gap[\"name\"],  \n                noFeedbackIcon, not gap[\"settings\"][\"showFeedbackIcon\"],\n                assert(name=\"\" or len(gaps)=1,feedback(translate('part.gapfill.feedback header',[\"name\": name])));\n                concat_feedback(filter(x[\"op\"]<>\"warning\",x,result[\"feedback\"]), if(marks>0,result[\"marks\"]/marks,1), noFeedbackIcon);\n                    result\n            ),\n            err,\n            fail(translate(\"part.gapfill.error marking gap\",[\"name\": gaps[gap_number][\"name\"], \"message\": err]))\n        ),\n        [gap_number,answer,index],\n        zip([3,0],[studentAnswer[3], interpreted_angle],[1,2])\n    )\n\n", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": true, "showFeedbackIcon": true, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "prompt": "<p>What is the magnitude and direction of the reaction force at point <em>A</em>?</p>\n<p>$\\mathbfy{A}$ = [[3]]</p>\n<p>at an angle of&nbsp;&nbsp;[[0]]&nbsp;measured [[1]]&nbsp;from the &nbsp;[[2]].</p>\n<p><span data-jme-visible=\"debug\">A= {siground(abs(A),4)} N @ {siground(theta_A,4)}&deg;</span></p>", "gaps": [{"type": "angle", "useCustomName": true, "customName": "angle", "marks": "10", "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": true, "showFeedbackIcon": false, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "settings": {"expected_answer": "precround(qty(theta_A,'deg'),2)", "unit_penalty": "20", "close_penalty": "20", "close_tol": "0.5", "right_tol": "0.2"}}, {"type": "1_n_2", "useCustomName": true, "customName": "sign", "marks": 0, "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": false, "showFeedbackIcon": false, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "minMarks": 0, "maxMarks": 0, "shuffleChoices": false, "displayType": "dropdownlist", "displayColumns": 0, "showCellAnswerState": true, "choices": ["CCW", "CW"], "matrix": [0, 0], "distractors": ["", ""]}, {"type": "1_n_2", "useCustomName": true, "customName": "ref", "marks": 0, "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": false, "showFeedbackIcon": false, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "minMarks": 0, "maxMarks": 0, "shuffleChoices": false, "displayType": "dropdownlist", "displayColumns": 0, "showCellAnswerState": true, "choices": ["+x axis", "+y axis", "-x axis", "-yaxis"], "matrix": [0, 0, 0, 0], "distractors": ["", "", "", ""]}, {"type": "engineering-answer", "useCustomName": true, "customName": "Mag A", "marks": "10", "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": true, "showFeedbackIcon": true, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "settings": {"correctAnswer": "qty(siground(abs(A),4),'N')", "right": "0.2", "close": "1.0", "C1": "75", "C2": "50", "C3": "25"}}], "sortAnswers": false}], "partsMode": "all", "maxMarks": 0, "objectives": [], "penalties": [], "objectiveVisibility": "always", "penaltyVisibility": "always"}, {"name": "Equilibrium of a rigid body: cantilever beam", "extensions": ["geogebra", "quantities"], "custom_part_types": [{"source": {"pk": 12, "author": {"name": "William Haynes", "pk": 2530}, "edit_page": "/part_type/12/edit"}, "name": "Angle quantity 2020", "short_name": "angle", "description": "<p>Adjusts all angles to 0 &lt; $\\theta$ &lt; 360.</p>\n<p>Accepts '&deg;' and 'deg' as units.</p>\n<p>Penalizes if not close enough or no units.</p>\n<p>90&deg; = -270&deg; = 450&deg;</p>", "help_url": "", "input_widget": "string", "input_options": {"correctAnswer": "plain_string(settings['expected_answer']) ", "hint": {"static": true, "value": ""}, "allowEmpty": {"static": true, "value": false}}, "can_be_gap": true, "can_be_step": true, "marking_script": "original_student_scalar:\nmatchnumber(studentAnswer,['plain','en'])[1]\n\nstudent_scalar:\nmod(original_student_scalar,360)\n\n\nstudent_unit:\nstudentAnswer[len(matchnumber(studentAnswer,['plain','en'])[0])..len(studentAnswer)]\n\ninterpreted_unit:\nif(trim(student_unit)='\u00b0','deg',student_unit)\n\ninterpreted_answer:\nqty(mod(student_scalar,360),'deg')\n\nclose:\nwithintolerance(student_scalar, correct_scalar,decimal(settings['close_tol']))\n\ncorrect_scalar:\nmod(scalar(settings['expected_answer']),360)\n\nright:\nwithintolerance(student_scalar, correct_scalar, decimal(settings['right_tol']))\n\ngood_unit:\nsame(qty(1,interpreted_unit),qty(1,'deg'))\n\nmark:\nassert(close,incorrect('Incorrect.');end());\nif(right,correct('Correct angle.'), set_credit(1 - settings['close_penalty'],'Angle is close.'));\nassert(good_unit,sub_credit(settings['unit_penalty'], 'Missing or incorrect units.'))", "marking_notes": [{"name": "original_student_scalar", "description": "<p>Retuns the scalar part of students answer (which is a quantity) as a number.</p>", "definition": "matchnumber(studentAnswer,['plain','en'])[1]"}, {"name": "student_scalar", "description": "<p>Normalize angle with mod 360</p>", "definition": "mod(original_student_scalar,360)\n"}, {"name": "student_unit", "description": "<p>matchnumber(studentAnswer,['plain','en'])[0] is a string \"12.34\"</p>", "definition": "studentAnswer[len(matchnumber(studentAnswer,['plain','en'])[0])..len(studentAnswer)]"}, {"name": "interpreted_unit", "description": "<p>Allows student to use degree symbol or 'deg' for units.</p>", "definition": "if(trim(student_unit)='\u00b0','deg',student_unit)"}, {"name": "interpreted_answer", "description": "A value representing the student's answer to this part.", "definition": "qty(mod(student_scalar,360),'deg')"}, {"name": "close", "description": "", "definition": "withintolerance(student_scalar, correct_scalar,decimal(settings['close_tol']))"}, {"name": "correct_scalar", "description": "<p>Normalize expected_answer with mod 360</p>", "definition": "mod(scalar(settings['expected_answer']),360)"}, {"name": "right", "description": "", "definition": "withintolerance(student_scalar, correct_scalar, decimal(settings['right_tol']))"}, {"name": "good_unit", "description": "", "definition": "same(qty(1,interpreted_unit),qty(1,'deg'))"}, {"name": "mark", "description": "This is the main marking note. It should award credit and provide feedback based on the student's answer.", "definition": "assert(close,incorrect('Incorrect.');end());\nif(right,correct('Correct angle.'), set_credit(1 - settings['close_penalty'],'Angle is close.'));\nassert(good_unit,sub_credit(settings['unit_penalty'], 'Missing or incorrect units.'))"}], "settings": [{"name": "expected_answer", "label": "Expected Answer", "help_url": "", "hint": "Expected angle as a quantity.", "input_type": "code", "default_value": "qty(30,'deg')", "evaluate": true}, {"name": "unit_penalty", "label": "Unit penalty", "help_url": "", "hint": "Penalty for not including degree sign or 'deg'.", "input_type": "percent", "default_value": "20"}, {"name": "close_penalty", "label": "Close Penalty", "help_url": "", "hint": "Penalty for close answer.", "input_type": "percent", "default_value": "20"}, {"name": "close_tol", "label": "Close", "help_url": "", "hint": "Angle must be $\\pm$ this many degrees to be marked close. &nbsp;&nbsp;", "input_type": "code", "default_value": "0.5", "evaluate": false}, {"name": "right_tol", "label": "Right ", "help_url": "", "hint": "Angle must be $\\pm$ this many degrees to be marked correct. &nbsp;", "input_type": "code", "default_value": "0.1", "evaluate": false}], "public_availability": "restricted", "published": false, "extensions": ["quantities"]}, {"source": {"pk": 19, "author": {"name": "William Haynes", "pk": 2530}, "edit_page": "/part_type/19/edit"}, "name": "Engineering Accuracy with units", "short_name": "engineering-answer", "description": "<p>A value with units marked right if within an adjustable % error of the correct value. &nbsp;Marked close if within a wider margin of error.</p>", "help_url": "", "input_widget": "string", "input_options": {"correctAnswer": "siground(settings['correctAnswer'],4)", "hint": {"static": true, "value": ""}, "allowEmpty": {"static": true, "value": true}}, "can_be_gap": true, "can_be_step": true, "marking_script": "mark:\nswitch( \n  right and good_units and right_sign, add_credit(1.0,'Correct.'),\n  right and good_units and not right_sign, add_credit(settings['C2'],'Wrong sign.'),\n  right and right_sign and not good_units, add_credit(settings['C2'],'Correct value, but wrong or missing units.'),\n  close and good_units, add_credit(settings['C1'],'Close.'),\n  close and not good_units, add_credit(settings['C3'],'Answer is close, but wrong or missing units.'),\n  incorrect('Wrong answer.')\n)\n\n\ninterpreted_answer:\nqty(student_scalar, student_units)\n\n\n\ncorrect_quantity:\nsettings[\"correctAnswer\"]\n\n\n\ncorrect_units:\nunits(correct_quantity)\n\n\nallowed_notation_styles:\n[\"plain\",\"en\"]\n\nmatch_student_number:\nmatchnumber(studentAnswer,allowed_notation_styles)\n\nstudent_scalar:\nmatch_student_number[1]\n\nstudent_units:\nreplace_regex('ohms','ohm',\n  replace_regex('\u00b0', ' deg',\n    replace_regex('-', ' ' ,\n      studentAnswer[len(match_student_number[0])..len(studentAnswer)])),\"i\")\n\ngood_units:\ntry(\ncompatible(quantity(1, student_units),correct_units),\nmsg,\nfeedback(msg);false)\n\n\nstudent_quantity:\nswitch(not good_units, \n       student_scalar * correct_units, \n       not right_sign,\n       -quantity(student_scalar, student_units),\n       quantity(student_scalar,student_units)\n)\n  \n\n\npercent_error:\ntry(\nscalar(abs((correct_quantity - student_quantity)/correct_quantity))*100  \n,msg,\nif(student_quantity=correct_quantity,0,100))\n   \n\nright:\npercent_error <= settings['right']\n\n\nclose:\nright_sign and percent_error <= settings['close']\n\nright_sign:\nsign(student_scalar) = sign(correct_quantity)", "marking_notes": [{"name": "mark", "description": "This is the main marking note. It should award credit and provide feedback based on the student's answer.", "definition": "switch( \n  right and good_units and right_sign, add_credit(1.0,'Correct.'),\n  right and good_units and not right_sign, add_credit(settings['C2'],'Wrong sign.'),\n  right and right_sign and not good_units, add_credit(settings['C2'],'Correct value, but wrong or missing units.'),\n  close and good_units, add_credit(settings['C1'],'Close.'),\n  close and not good_units, add_credit(settings['C3'],'Answer is close, but wrong or missing units.'),\n  incorrect('Wrong answer.')\n)\n"}, {"name": "interpreted_answer", "description": "A value representing the student's answer to this part.", "definition": "qty(student_scalar, student_units)\n\n"}, {"name": "correct_quantity", "description": "", "definition": "settings[\"correctAnswer\"]\n\n"}, {"name": "correct_units", "description": "", "definition": "units(correct_quantity)\n"}, {"name": "allowed_notation_styles", "description": "", "definition": "[\"plain\",\"en\"]"}, {"name": "match_student_number", "description": "", "definition": "matchnumber(studentAnswer,allowed_notation_styles)"}, {"name": "student_scalar", "description": "", "definition": "match_student_number[1]"}, {"name": "student_units", "description": "<p>Modify&nbsp;the&nbsp;unit portion of&nbsp;the student's answer by</p>\n<p>1. replacing \"ohms\" with \"ohm\" &nbsp;case insensitive</p>\n<p>2.&nbsp;replacing '-'&nbsp;with ' '&nbsp;</p>\n<p>3. replacing '&deg;' with ' deg'&nbsp;</p>\n<p>to allow answers like 10 ft-lb and 30&deg;</p>", "definition": "replace_regex('ohms','ohm',\n  replace_regex('\u00b0', ' deg',\n    replace_regex('-', ' ' ,\n      studentAnswer[len(match_student_number[0])..len(studentAnswer)])),\"i\")"}, {"name": "good_units", "description": "", "definition": "try(\ncompatible(quantity(1, student_units),correct_units),\nmsg,\nfeedback(msg);false)\n"}, {"name": "student_quantity", "description": "<p>This fixes the student answer for two common errors. &nbsp;</p>\n<p>If student_units are wrong&nbsp;&nbsp;- replace with correct units</p>\n<p>If student_scalar has the wrong sign - replace with right sign</p>\n<p>If student makes both errors, only one gets fixed.</p>", "definition": "switch(not good_units, \n       student_scalar * correct_units, \n       not right_sign,\n       -quantity(student_scalar, student_units),\n       quantity(student_scalar,student_units)\n)\n  \n"}, {"name": "percent_error", "description": "", "definition": "try(\nscalar(abs((correct_quantity - student_quantity)/correct_quantity))*100  \n,msg,\nif(student_quantity=correct_quantity,0,100))\n   "}, {"name": "right", "description": "", "definition": "percent_error <= settings['right']\n"}, {"name": "close", "description": "<p>Only marked close if the student actually has the right sign.</p>", "definition": "right_sign and percent_error <= settings['close']"}, {"name": "right_sign", "description": "", "definition": "sign(student_scalar) = sign(correct_quantity) "}], "settings": [{"name": "correctAnswer", "label": "Correct Quantity.", "help_url": "", "hint": "The correct answer given as a JME quantity.", "input_type": "code", "default_value": "", "evaluate": true}, {"name": "right", "label": "% Accuracy for right.", "help_url": "", "hint": "Question will be considered correct if the scalar part of the student's answer is within this % of correct value.", "input_type": "code", "default_value": "0.2", "evaluate": true}, {"name": "close", "label": "% Accuracy for close.", "help_url": "", "hint": "Question will be considered close if the scalar part of the student's answer is within this % of correct value.", "input_type": "code", "default_value": "1.0", "evaluate": true}, {"name": "C1", "label": "Close with units.", "help_url": "", "hint": "Partial Credit for close value with appropriate units. &nbsp;if correct answer is 100 N and close is &plusmn;1%,<br />99 &nbsp;N is accepted.", "input_type": "percent", "default_value": "75"}, {"name": "C2", "label": "No units or wrong sign", "help_url": "", "hint": "Partial credit for forgetting units or using wrong sign.<br />If the correct answer is 100 N, both 100 and -100 N are accepted.", "input_type": "percent", "default_value": "50"}, {"name": "C3", "label": "Close, no units.", "help_url": "", "hint": "Partial Credit for close value but forgotten units.<br />This value would be close&nbsp;if the expected units were provided. &nbsp;If the correct answer is 100 N, and close is &plusmn;1%,<br />99 is accepted.", "input_type": "percent", "default_value": "25"}], "public_availability": "always", "published": true, "extensions": ["quantities"]}], "resources": [], "navigation": {"allowregen": true, "showfrontpage": false, "preventleave": false, "typeendtoleave": false}, "contributors": [{"name": "William Haynes", "profile_url": "https://numbas.mathcentre.ac.uk/accounts/profile/2530/"}], "tags": ["angle_from_ref", "equilibrium", "Equilibrium", "fixed support", "mechanics", "Mechanics", "rigid body", "Rigid Body", "statics", "Statics"], "metadata": {"description": "<p>Determine the reactions supporting a cantilever beam carrying concentrated forces and moments.</p>", "licence": "Creative Commons Attribution-NonCommercial 4.0 International"}, "statement": "<p>{geogebra_applet('v5xfnaym',[['A',A],['B',B],['L',L],['units','\"'+units[1]+'\"'],['fa',FA], ['fc',FC], ['M',M]])}</p>\n<p>A&nbsp;beam of length &nbsp;$L$ = {L} {units[1]} is supported by a fixed (cantilever) support at $O$. Detemine the reactions at $O$&nbsp;when the beam supports these loads:&nbsp;</p>\n<p>$A$ = {magA} {units[0]}, $B$&nbsp;= {abs(M)} {units[0]}-{units[1]} and $C$&nbsp;= {magC} {units[0]}, as shown.</p>", "advice": "<p>Draw a free body diagaram of the beam, then apply the equations of equilibrium.</p>\n<p></p>\n<p>$\\Sigma M = 0$</p>\n<p style=\"padding-left: 30px;\">$M_O + M_A + M_B + M_C = 0$</p>\n<p style=\"padding-left: 30px;\">$M_A = d_1 A_y$ = ({OA}) ({qty(abs(FA[1]),units[0])}) =&nbsp;{abs(MA)} <em> {if(sign(MA)&gt;0,'counterclockwise','clockwise')}</em></p>\n<p style=\"padding-left: 30px;\">$M_B =$ {abs(MB)} <em>{if(sign(MB)&gt;0,'counterclockwise','clockwise')}</em></p>\n<p style=\"padding-left: 30px;\">$M_C = L&nbsp;C_y$ = ({OC}) ({format(qty(abs(FC[1]),units[0]))}) =&nbsp;{format(abs(MC))} <em>{if(sign(MC)&gt;0,'counterclockwise','clockwise')}</em></p>\n<p style=\"padding-left: 30px;\">$ M_O = - (&nbsp;\\var{format(MA)} + \\var{format(MB)} + \\var{format(MC)} ) = \\var{format(abs(MO))}$&nbsp;<em>{if(sign(MO)&gt;0,'counterclockwise','clockwise')}</em></p>\n<p style=\"padding-left: 30px;\"><em>&nbsp;</em></p>\n<p>$\\Sigma F_x = 0$</p>\n<p style=\"padding-left: 30px;\">$O_x + A_x + C_x = 0$</p>\n<p style=\"padding-left: 30px;\">$O_x = 0 - C_x &nbsp;= &nbsp;\\var{format(qty(abs(FO[0]), units[0]))}$&nbsp;<em>{if(sign(FO[0])&gt;=0,'right','left')}</em></p>\n<p style=\"padding-left: 30px;\"><em>&nbsp;</em></p>\n<p>$\\Sigma F_y = 0$</p>\n<p style=\"padding-left: 30px;\">$O_y + A_y + C_y = 0$</p>\n<p style=\"padding-left: 30px;\">$O_y = - (A_y + C_y) &nbsp;= - ( \\var{FA[1]} + \\var{siground(FC[1],4)} )= \\var{format(qty(abs(FO[1]), units[0]))} $ &nbsp;<em>{if(sign(FO[1])&gt;=0,'up','down')}</em></p>\n<p style=\"padding-left: 30px;\"><em>&nbsp;</em></p>\n<p>Resolve $O_x$ and $O_y$ to get</p>\n<p>Force $O = \\var{format(qty(abs(FO), units[0]))} $ at an angle of {format(dirO)} from the positve x-axis.</p>", "rulesets": {}, "builtin_constants": {"e": true, "pi,\u03c0": true, "i": true}, "constants": [], "variables": {"FO": {"name": "FO", "group": "output", "definition": "-(FA+FC)", "description": "<p>The resultant force at O as a vector.</p>", "templateType": "anything", "can_override": false}, "A": {"name": "A", "group": "Input", "definition": "random(0.2..0.8#0.1)", "description": "", "templateType": "anything", "can_override": false}, "FC": {"name": "FC", "group": "Input", "definition": "magC vector(cos(radians(theta_C)),sin(radians(theta_C)))", "description": "", "templateType": "anything", "can_override": false}, "B": {"name": "B", "group": "Input", "definition": "random(A..0.9#0.1)", "description": "", "templateType": "anything", "can_override": false}, "OA": {"name": "OA", "group": "output", "definition": "qty(A L, units[1])", "description": "<p>distance from O to A</p>", "templateType": "anything", "can_override": false}, "MA": {"name": "MA", "group": "output", "definition": "qty(cross(vector(scalar(OA),0,0),vector(FA[0],\n    FA[1],0))[2],\nunits[0] + \" \" + units[1])\n\n", "description": "<p>Moment of force A about point O.</p>", "templateType": "anything", "can_override": false}, "units": {"name": "units", "group": "Input", "definition": "random(['N','m'],['lb','ft'])", "description": "", "templateType": "anything", "can_override": false}, "debug": {"name": "debug", "group": "Input", "definition": "false", "description": "", "templateType": "anything", "can_override": false}, "MB": {"name": "MB", "group": "output", "definition": "qty(M,units[0] + \" \" + units[1])\n", "description": "<p>The concentrated moment.</p>", "templateType": "anything", "can_override": false}, "magA": {"name": "magA", "group": "Input", "definition": "random(10..150#10)", "description": "", "templateType": "anything", "can_override": false}, "OB": {"name": "OB", "group": "output", "definition": "qty(B L, units[1])", "description": "<p>distance from O to B</p>", "templateType": "anything", "can_override": false}, "L": {"name": "L", "group": "Input", "definition": "if(units[1]='ft',random(2..12#2),random(1..5))", "description": "", "templateType": "anything", "can_override": false}, "MagC": {"name": "MagC", "group": "Input", "definition": "random(10..150#10)", "description": "", "templateType": "anything", "can_override": false}, "dirO": {"name": "dirO", "group": "output", "definition": "qty(mod(degrees(atan2(FO[1],FO[0])),360),'deg')", "description": "", "templateType": "anything", "can_override": false}, "FA": {"name": "FA", "group": "Input", "definition": "MagA vector(0,random(1,-1))", "description": "", "templateType": "anything", "can_override": false}, "OC": {"name": "OC", "group": "output", "definition": "qty(L, units[1])", "description": "<p>distance from O to C</p>", "templateType": "anything", "can_override": false}, "MO": {"name": "MO", "group": "output", "definition": "-(MA + MB + MC)", "description": "<p>The reaction moment at O.</p>", "templateType": "anything", "can_override": false}, "M": {"name": "M", "group": "Input", "definition": "random(100..500#25) random(1,-1)", "description": "<p>The magnitude of the moment.</p>", "templateType": "anything", "can_override": false}, "theta_c": {"name": "theta_c", "group": "Input", "definition": "random(0..355#5 except [0,90,180,270])", "description": "", "templateType": "anything", "can_override": false}, "MC": {"name": "MC", "group": "output", "definition": "qty(cross(vector(scalar(OC),0,0),\n    vector(FC[0],FC[1],0))[2],\n  units[0] + \" \" + units[1])\n  \n  \n  ", "description": "<p>Moment of force C&nbsp;about point O.</p>", "templateType": "anything", "can_override": false}}, "variablesTest": {"condition": "B-A > 0.2", "maxRuns": 100}, "ungrouped_variables": [], "variable_groups": [{"name": "Input", "variables": ["L", "A", "B", "units", "FA", "magA", "MagC", "theta_c", "FC", "M", "debug"]}, {"name": "output", "variables": ["OA", "OC", "OB", "MA", "MC", "MB", "MO", "FO", "dirO"]}], "functions": {"format": {"parameters": [["q", "quantity"]], "type": "string", "language": "jme", "definition": "string(siground(q,4))"}}, "preamble": {"js": "", "css": ""}, "parts": [{"type": "gapfill", "useCustomName": true, "customName": "Moment at O", "marks": 0, "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": true, "showFeedbackIcon": true, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "prompt": "<p>Determine the magnitude and direction of the moment at the fixed support at $O$.</p>\n<p>$M_O$ =&nbsp;[[0]]&nbsp;&nbsp;[[1]] &nbsp;<span data-jme-visible=\"debug\">{format(MO)}</span></p>", "gaps": [{"type": "engineering-answer", "useCustomName": true, "customName": "$M_O$", "marks": "10", "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": true, "showFeedbackIcon": true, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "settings": {"correctAnswer": "abs(MO)", "right": "0.2", "close": "1.0", "C1": "75", "C2": "50", "C3": "25"}}, {"type": "1_n_2", "useCustomName": true, "customName": "Direction", "marks": 0, "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": false, "showFeedbackIcon": true, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "minMarks": 0, "maxMarks": 0, "shuffleChoices": false, "displayType": "dropdownlist", "displayColumns": 0, "showCellAnswerState": true, "choices": ["Counterclockwise", "Clockwise", "Neither"], "matrix": "[if(sign(MO)>0,5,0),if(sign(MO)<0,5,0),if(sign(MO)=0,5,0)]"}], "sortAnswers": false}, {"type": "gapfill", "useCustomName": true, "customName": "Force at O", "marks": 0, "scripts": {}, "customMarkingAlgorithm": "interpreted_angle:  // a qty string corrected to standard angle\n  student_angle[2]  + student_angle[1] * student_angle[0] + student_units\n\nmagnitude:\n  studentAnswer[3]\n\nstudent_angle:\n  [mod(matchnumber(studentAnswer[0],['plain','en'])[1],360), // angle\n  [1,-1][indices(studentAnswer[1],[true])[0]],      // ccw = 1 cw = -1\n  [0,90,180,-90][indices(studentAnswer[2],[true])[0]]] // reference axis\n\nstudent_units:\n  studentAnswer[0][len(matchnumber(studentAnswer[0],['plain','en'])[0])..len(studentAnswer[0])]\n\ninterpreted_answers:\n  [interpreted_angle, studentAnswer[1], studentAnswer[2], studentAnswer[3]]\n\ngap_feedback (Feedback on each of the gaps):\n    map(\n        try(\n            let(\n                result, submit_part(gaps[gap_number][\"path\"],answer),\n                gap, gaps[gap_number],\n                name, gap[\"name\"],  \n                noFeedbackIcon, not gap[\"settings\"][\"showFeedbackIcon\"],\n                assert(name=\"\" or len(gaps)=1,feedback(translate('part.gapfill.feedback header',[\"name\": name])));\n                concat_feedback(filter(x[\"op\"]<>\"warning\",x,result[\"feedback\"]), if(marks>0,result[\"marks\"]/marks,1), noFeedbackIcon);\n                    result\n            ),\n            err,\n            fail(translate(\"part.gapfill.error marking gap\",[\"name\": gaps[gap_number][\"name\"], \"message\": err]))\n        ),\n        [gap_number,answer,index],\n        zip([3,0],[studentAnswer[3], interpreted_angle],[1,2])\n    )\n\n", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": true, "showFeedbackIcon": true, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "prompt": "<p>Determine the magnitude and direction of the reaction force at $O$.</p>\n<p>$O$ = [[3]]&nbsp;&nbsp;at an angle of [[0]]&nbsp;measured [[1]]&nbsp;from the [[2]].</p>\n<p data-jme-visible=\"debug\">{format(qty(abs(FO),units[0]))} at {format(dirO)}</p>", "gaps": [{"type": "angle", "useCustomName": true, "customName": "angle", "marks": "10", "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": true, "showFeedbackIcon": false, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "settings": {"expected_answer": "dirO", "unit_penalty": "20", "close_penalty": "20", "close_tol": "0.5", "right_tol": "0.2"}}, {"type": "1_n_2", "useCustomName": true, "customName": "sign", "marks": 0, "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": false, "showFeedbackIcon": false, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "minMarks": 0, "maxMarks": 0, "shuffleChoices": false, "displayType": "dropdownlist", "displayColumns": 0, "showCellAnswerState": true, "choices": ["CCW", "CW"], "matrix": [0, 0], "distractors": ["", ""]}, {"type": "1_n_2", "useCustomName": true, "customName": "ref", "marks": 0, "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": false, "showFeedbackIcon": false, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "minMarks": 0, "maxMarks": 0, "shuffleChoices": false, "displayType": "dropdownlist", "displayColumns": 0, "showCellAnswerState": true, "choices": ["+x axis", "+y axis", "-x axis", "-y axis"], "matrix": [0, 0, 0, 0], "distractors": ["", "", "", ""]}, {"type": "engineering-answer", "useCustomName": true, "customName": "Magnitude", "marks": "10", "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": true, "showFeedbackIcon": true, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "settings": {"correctAnswer": "qty(abs(FO),units[0])", "right": "0.2", "close": "1.0", "C1": "75", "C2": "50", "C3": "25"}}], "sortAnswers": false}], "partsMode": "all", "maxMarks": 0, "objectives": [], "penalties": [], "objectiveVisibility": "always", "penaltyVisibility": "always"}, {"name": "Equilibrium of a rigid body: beam and pulley", "extensions": ["geogebra", "quantities"], "custom_part_types": [{"source": {"pk": 12, "author": {"name": "William Haynes", "pk": 2530}, "edit_page": "/part_type/12/edit"}, "name": "Angle quantity 2020", "short_name": "angle", "description": "<p>Adjusts all angles to 0 &lt; $\\theta$ &lt; 360.</p>\n<p>Accepts '&deg;' and 'deg' as units.</p>\n<p>Penalizes if not close enough or no units.</p>\n<p>90&deg; = -270&deg; = 450&deg;</p>", "help_url": "", "input_widget": "string", "input_options": {"correctAnswer": "plain_string(settings['expected_answer']) ", "hint": {"static": true, "value": ""}, "allowEmpty": {"static": true, "value": false}}, "can_be_gap": true, "can_be_step": true, "marking_script": "original_student_scalar:\nmatchnumber(studentAnswer,['plain','en'])[1]\n\nstudent_scalar:\nmod(original_student_scalar,360)\n\n\nstudent_unit:\nstudentAnswer[len(matchnumber(studentAnswer,['plain','en'])[0])..len(studentAnswer)]\n\ninterpreted_unit:\nif(trim(student_unit)='\u00b0','deg',student_unit)\n\ninterpreted_answer:\nqty(mod(student_scalar,360),'deg')\n\nclose:\nwithintolerance(student_scalar, correct_scalar,decimal(settings['close_tol']))\n\ncorrect_scalar:\nmod(scalar(settings['expected_answer']),360)\n\nright:\nwithintolerance(student_scalar, correct_scalar, decimal(settings['right_tol']))\n\ngood_unit:\nsame(qty(1,interpreted_unit),qty(1,'deg'))\n\nmark:\nassert(close,incorrect('Incorrect.');end());\nif(right,correct('Correct angle.'), set_credit(1 - settings['close_penalty'],'Angle is close.'));\nassert(good_unit,sub_credit(settings['unit_penalty'], 'Missing or incorrect units.'))", "marking_notes": [{"name": "original_student_scalar", "description": "<p>Retuns the scalar part of students answer (which is a quantity) as a number.</p>", "definition": "matchnumber(studentAnswer,['plain','en'])[1]"}, {"name": "student_scalar", "description": "<p>Normalize angle with mod 360</p>", "definition": "mod(original_student_scalar,360)\n"}, {"name": "student_unit", "description": "<p>matchnumber(studentAnswer,['plain','en'])[0] is a string \"12.34\"</p>", "definition": "studentAnswer[len(matchnumber(studentAnswer,['plain','en'])[0])..len(studentAnswer)]"}, {"name": "interpreted_unit", "description": "<p>Allows student to use degree symbol or 'deg' for units.</p>", "definition": "if(trim(student_unit)='\u00b0','deg',student_unit)"}, {"name": "interpreted_answer", "description": "A value representing the student's answer to this part.", "definition": "qty(mod(student_scalar,360),'deg')"}, {"name": "close", "description": "", "definition": "withintolerance(student_scalar, correct_scalar,decimal(settings['close_tol']))"}, {"name": "correct_scalar", "description": "<p>Normalize expected_answer with mod 360</p>", "definition": "mod(scalar(settings['expected_answer']),360)"}, {"name": "right", "description": "", "definition": "withintolerance(student_scalar, correct_scalar, decimal(settings['right_tol']))"}, {"name": "good_unit", "description": "", "definition": "same(qty(1,interpreted_unit),qty(1,'deg'))"}, {"name": "mark", "description": "This is the main marking note. It should award credit and provide feedback based on the student's answer.", "definition": "assert(close,incorrect('Incorrect.');end());\nif(right,correct('Correct angle.'), set_credit(1 - settings['close_penalty'],'Angle is close.'));\nassert(good_unit,sub_credit(settings['unit_penalty'], 'Missing or incorrect units.'))"}], "settings": [{"name": "expected_answer", "label": "Expected Answer", "help_url": "", "hint": "Expected angle as a quantity.", "input_type": "code", "default_value": "qty(30,'deg')", "evaluate": true}, {"name": "unit_penalty", "label": "Unit penalty", "help_url": "", "hint": "Penalty for not including degree sign or 'deg'.", "input_type": "percent", "default_value": "20"}, {"name": "close_penalty", "label": "Close Penalty", "help_url": "", "hint": "Penalty for close answer.", "input_type": "percent", "default_value": "20"}, {"name": "close_tol", "label": "Close", "help_url": "", "hint": "Angle must be $\\pm$ this many degrees to be marked close. &nbsp;&nbsp;", "input_type": "code", "default_value": "0.5", "evaluate": false}, {"name": "right_tol", "label": "Right ", "help_url": "", "hint": "Angle must be $\\pm$ this many degrees to be marked correct. &nbsp;", "input_type": "code", "default_value": "0.1", "evaluate": false}], "public_availability": "restricted", "published": false, "extensions": ["quantities"]}, {"source": {"pk": 19, "author": {"name": "William Haynes", "pk": 2530}, "edit_page": "/part_type/19/edit"}, "name": "Engineering Accuracy with units", "short_name": "engineering-answer", "description": "<p>A value with units marked right if within an adjustable % error of the correct value. &nbsp;Marked close if within a wider margin of error.</p>", "help_url": "", "input_widget": "string", "input_options": {"correctAnswer": "siground(settings['correctAnswer'],4)", "hint": {"static": true, "value": ""}, "allowEmpty": {"static": true, "value": true}}, "can_be_gap": true, "can_be_step": true, "marking_script": "mark:\nswitch( \n  right and good_units and right_sign, add_credit(1.0,'Correct.'),\n  right and good_units and not right_sign, add_credit(settings['C2'],'Wrong sign.'),\n  right and right_sign and not good_units, add_credit(settings['C2'],'Correct value, but wrong or missing units.'),\n  close and good_units, add_credit(settings['C1'],'Close.'),\n  close and not good_units, add_credit(settings['C3'],'Answer is close, but wrong or missing units.'),\n  incorrect('Wrong answer.')\n)\n\n\ninterpreted_answer:\nqty(student_scalar, student_units)\n\n\n\ncorrect_quantity:\nsettings[\"correctAnswer\"]\n\n\n\ncorrect_units:\nunits(correct_quantity)\n\n\nallowed_notation_styles:\n[\"plain\",\"en\"]\n\nmatch_student_number:\nmatchnumber(studentAnswer,allowed_notation_styles)\n\nstudent_scalar:\nmatch_student_number[1]\n\nstudent_units:\nreplace_regex('ohms','ohm',\n  replace_regex('\u00b0', ' deg',\n    replace_regex('-', ' ' ,\n      studentAnswer[len(match_student_number[0])..len(studentAnswer)])),\"i\")\n\ngood_units:\ntry(\ncompatible(quantity(1, student_units),correct_units),\nmsg,\nfeedback(msg);false)\n\n\nstudent_quantity:\nswitch(not good_units, \n       student_scalar * correct_units, \n       not right_sign,\n       -quantity(student_scalar, student_units),\n       quantity(student_scalar,student_units)\n)\n  \n\n\npercent_error:\ntry(\nscalar(abs((correct_quantity - student_quantity)/correct_quantity))*100  \n,msg,\nif(student_quantity=correct_quantity,0,100))\n   \n\nright:\npercent_error <= settings['right']\n\n\nclose:\nright_sign and percent_error <= settings['close']\n\nright_sign:\nsign(student_scalar) = sign(correct_quantity)", "marking_notes": [{"name": "mark", "description": "This is the main marking note. It should award credit and provide feedback based on the student's answer.", "definition": "switch( \n  right and good_units and right_sign, add_credit(1.0,'Correct.'),\n  right and good_units and not right_sign, add_credit(settings['C2'],'Wrong sign.'),\n  right and right_sign and not good_units, add_credit(settings['C2'],'Correct value, but wrong or missing units.'),\n  close and good_units, add_credit(settings['C1'],'Close.'),\n  close and not good_units, add_credit(settings['C3'],'Answer is close, but wrong or missing units.'),\n  incorrect('Wrong answer.')\n)\n"}, {"name": "interpreted_answer", "description": "A value representing the student's answer to this part.", "definition": "qty(student_scalar, student_units)\n\n"}, {"name": "correct_quantity", "description": "", "definition": "settings[\"correctAnswer\"]\n\n"}, {"name": "correct_units", "description": "", "definition": "units(correct_quantity)\n"}, {"name": "allowed_notation_styles", "description": "", "definition": "[\"plain\",\"en\"]"}, {"name": "match_student_number", "description": "", "definition": "matchnumber(studentAnswer,allowed_notation_styles)"}, {"name": "student_scalar", "description": "", "definition": "match_student_number[1]"}, {"name": "student_units", "description": "<p>Modify&nbsp;the&nbsp;unit portion of&nbsp;the student's answer by</p>\n<p>1. replacing \"ohms\" with \"ohm\" &nbsp;case insensitive</p>\n<p>2.&nbsp;replacing '-'&nbsp;with ' '&nbsp;</p>\n<p>3. replacing '&deg;' with ' deg'&nbsp;</p>\n<p>to allow answers like 10 ft-lb and 30&deg;</p>", "definition": "replace_regex('ohms','ohm',\n  replace_regex('\u00b0', ' deg',\n    replace_regex('-', ' ' ,\n      studentAnswer[len(match_student_number[0])..len(studentAnswer)])),\"i\")"}, {"name": "good_units", "description": "", "definition": "try(\ncompatible(quantity(1, student_units),correct_units),\nmsg,\nfeedback(msg);false)\n"}, {"name": "student_quantity", "description": "<p>This fixes the student answer for two common errors. &nbsp;</p>\n<p>If student_units are wrong&nbsp;&nbsp;- replace with correct units</p>\n<p>If student_scalar has the wrong sign - replace with right sign</p>\n<p>If student makes both errors, only one gets fixed.</p>", "definition": "switch(not good_units, \n       student_scalar * correct_units, \n       not right_sign,\n       -quantity(student_scalar, student_units),\n       quantity(student_scalar,student_units)\n)\n  \n"}, {"name": "percent_error", "description": "", "definition": "try(\nscalar(abs((correct_quantity - student_quantity)/correct_quantity))*100  \n,msg,\nif(student_quantity=correct_quantity,0,100))\n   "}, {"name": "right", "description": "", "definition": "percent_error <= settings['right']\n"}, {"name": "close", "description": "<p>Only marked close if the student actually has the right sign.</p>", "definition": "right_sign and percent_error <= settings['close']"}, {"name": "right_sign", "description": "", "definition": "sign(student_scalar) = sign(correct_quantity) "}], "settings": [{"name": "correctAnswer", "label": "Correct Quantity.", "help_url": "", "hint": "The correct answer given as a JME quantity.", "input_type": "code", "default_value": "", "evaluate": true}, {"name": "right", "label": "% Accuracy for right.", "help_url": "", "hint": "Question will be considered correct if the scalar part of the student's answer is within this % of correct value.", "input_type": "code", "default_value": "0.2", "evaluate": true}, {"name": "close", "label": "% Accuracy for close.", "help_url": "", "hint": "Question will be considered close if the scalar part of the student's answer is within this % of correct value.", "input_type": "code", "default_value": "1.0", "evaluate": true}, {"name": "C1", "label": "Close with units.", "help_url": "", "hint": "Partial Credit for close value with appropriate units. &nbsp;if correct answer is 100 N and close is &plusmn;1%,<br />99 &nbsp;N is accepted.", "input_type": "percent", "default_value": "75"}, {"name": "C2", "label": "No units or wrong sign", "help_url": "", "hint": "Partial credit for forgetting units or using wrong sign.<br />If the correct answer is 100 N, both 100 and -100 N are accepted.", "input_type": "percent", "default_value": "50"}, {"name": "C3", "label": "Close, no units.", "help_url": "", "hint": "Partial Credit for close value but forgotten units.<br />This value would be close&nbsp;if the expected units were provided. &nbsp;If the correct answer is 100 N, and close is &plusmn;1%,<br />99 is accepted.", "input_type": "percent", "default_value": "25"}], "public_availability": "always", "published": true, "extensions": ["quantities"]}], "resources": [], "navigation": {"allowregen": true, "showfrontpage": false, "preventleave": false, "typeendtoleave": false}, "contributors": [{"name": "William Haynes", "profile_url": "https://numbas.mathcentre.ac.uk/accounts/profile/2530/"}], "tags": ["angle from reference", "Mechanics", "mechanics", "pulley", "rigid body equilibrium", "Rigid body equilibrium", "Statics", "statics"], "metadata": {"description": "<p>Rigid body equilibrium problem. &nbsp;Easiest to solve by replacing forces on the perimiter of the pulley with equivalent forces at the axle.</p>", "licence": "Creative Commons Attribution-NonCommercial 4.0 International"}, "statement": "<p>{geogebra_applet('nnkbvxb8',[['L',scalar(L)],['ab',scalar(ab)],['r',scalar(r)/12],['alpha',alpha+'&deg;'],['theta',theta+'&deg;']])}</p>\n<p>{L} long beam $ABC$ supports a frictionless pulley with {r} radius&nbsp;at point $B$, located {ab} from the left end. Determine the reactions at $A$ and $C$ when it supports&nbsp;{W} weight $W$ as shown.</p>\n<p></p>\n<p></p>", "advice": "<p></p>\n<p><strong>Known</strong>: $L = \\var{l} \\qquad&nbsp;d = \\var{ab} \\qquad&nbsp;\\theta = \\var{theta}&deg; \\qquad \\alpha = \\var{alpha}&deg; \\qquad&nbsp;W = T = \\var{W}$</p>\n<ol>\n<li style=\"list-style-type: none;\">\n<ol>\n<li>Draw a free body diagram of the beam. &nbsp;It simplifies the solution to replace the forces of the rope on the pulley with equivalent forces at point $B$. The force at $C$ acts perpendicular to the surface the roller rests on.\n<p>{geogebra_applet('kggckbyp',[['L',scalar(L)],['ab',scalar(ab)],['r',scalar(r)/12],['alpha',alpha+'&deg;'],['theta',theta+'&deg;']])}</p>\n</li>\n<li>Take moments about point $A$ to find the reaction at $C$.\n<p style=\"text-align: center;\">$\\begin{align}\\Sigma M_A &amp;= 0&nbsp;\\\\+ C_y L+ &nbsp;T_y d - W d&amp;= 0 \\\\&nbsp;&nbsp;C_y &nbsp;&amp;=\\dfrac{ d (W - T \\cos \\theta)}{L} &nbsp;= \\var{display(Cy)}\\\\C &amp;= \\dfrac{C_y}{\\cos \\alpha} = \\var{display(magC)}\\end{align}$&nbsp;</p>\n</li>\n<li>Apply $F_x=0$ to find $A_x$.\n<p style=\"text-align: center;\">$\\begin{align}F_x&amp;=0\\\\A_x - T_x - C_x &amp;= 0 \\\\A_x &amp;= C_x + T_x\\\\A_x&amp;= C \\sin \\alpha + T \\sin \\theta&nbsp;= \\var{display(Ax)}\\end{align}$</p>\n</li>\n<li>Apply $\\Sigma F_y = 0$ to find $A_y$.\n<p style=\"text-align: center;\">$\\begin{align}F_y&amp;=0\\\\A_y&nbsp;+ C_y +&nbsp;T_y&nbsp;- W&nbsp; &amp;= 0 \\\\A_y &amp;= W&nbsp;-&nbsp;C_y -&nbsp;T_y\\\\A_y&amp;= W&nbsp;&nbsp;- C \\cos \\alpha - T \\cos \\theta= \\var{display(Ay)}\\end{align}$</p>\n</li>\n<li>Resolve $A_x$ and $A_y$ to get magnitude and direction of force $\\mathbf{A}$.\n<p style=\"text-align: center;\">$A = \\sqrt{(A_x)^2+(A_y)^2} = \\var{display(magA)}$</p>\n<p style=\"text-align: center;\">$\\phi = \\tan^{-1} \\left(\\dfrac{A_y}{A_x}\\right) = \\var{precround(dirA,2)}$&deg; &nbsp;from the positive <em>x</em>-axis.</p>\n</li>\n<li>Check with $\\Sigma \\mathbf{F} = 0$.\n<p style=\"text-align: center;\">$ \\mathbf{A} + \\mathbf{C}&nbsp;+ \\mathbf{W}&nbsp;+ \\mathbf{T}&nbsp;= 0$&nbsp;</p>\n<p style=\"text-align: center;\">$\\var{precround(vecA,2)} + \\var{precround(vecC,2)} + &nbsp;\\var{vecW} + \\var{precround(vecT,2)} = \\var{precround(sum,2)}$</p>\n</li>\n</ol>\n</li>\n</ol>", "rulesets": {}, "builtin_constants": {"e": true, "pi,\u03c0": true, "i": true}, "constants": [], "variables": {"r": {"name": "r", "group": "Ungrouped variables", "definition": "qty(random(12..24#2),'inch')", "description": "", "templateType": "anything", "can_override": false}, "ab": {"name": "ab", "group": "Ungrouped variables", "definition": "qty(random(2..10),'ft')", "description": "", "templateType": "anything", "can_override": false}, "vecT": {"name": "vecT", "group": "Unnamed group", "definition": "vector(cos(radians(90+theta)),sin(radians(90+theta))) scalar(W)", "description": "", "templateType": "anything", "can_override": false}, "vecW": {"name": "vecW", "group": "Unnamed group", "definition": "vector(0,-scalar(W))", "description": "", "templateType": "anything", "can_override": false}, "Cy": {"name": "Cy", "group": "Unnamed group", "definition": "ab * W *(1- cos(radians(theta)))/ L", "description": "", "templateType": "anything", "can_override": false}, "W": {"name": "W", "group": "Ungrouped variables", "definition": "qty(random(25..200#25),'lb')", "description": "", "templateType": "anything", "can_override": false}, "Ay": {"name": "Ay", "group": "Unnamed group", "definition": "W - magC cos(radians(alpha)) - T cos(radians(theta))", "description": "", "templateType": "anything", "can_override": false}, "dirC": {"name": "dirC", "group": "Unnamed group", "definition": "90+alpha", "description": "", "templateType": "anything", "can_override": false}, "theta": {"name": "theta", "group": "Ungrouped variables", "definition": "random(55..75#5)", "description": "", "templateType": "anything", "can_override": false}, "vecC": {"name": "vecC", "group": "Unnamed group", "definition": "vector(scalar(Cx),scalar(Cy))", "description": "", "templateType": "anything", "can_override": false}, "alpha": {"name": "alpha", "group": "Ungrouped variables", "definition": "random(30..45#5)", "description": "", "templateType": "anything", "can_override": false}, "Ax": {"name": "Ax", "group": "Unnamed group", "definition": "magC sin(radians(alpha)) + T sin(radians(theta))", "description": "", "templateType": "anything", "can_override": false}, "magA": {"name": "magA", "group": "Unnamed group", "definition": "qty(abs(vecA),'lb')", "description": "", "templateType": "anything", "can_override": false}, "dirA": {"name": "dirA", "group": "Unnamed group", "definition": "degrees(atan2(scalar(Ay),scalar(Ax)))", "description": "", "templateType": "anything", "can_override": false}, "Cx": {"name": "Cx", "group": "Unnamed group", "definition": "magC * (cos(radians(alpha+90)))", "description": "", "templateType": "anything", "can_override": false}, "vecA": {"name": "vecA", "group": "Unnamed group", "definition": "vector(scalar(Ax),scalar(Ay))", "description": "", "templateType": "anything", "can_override": false}, "T": {"name": "T", "group": "Ungrouped variables", "definition": "W", "description": "", "templateType": "anything", "can_override": false}, "magC": {"name": "magC", "group": "Unnamed group", "definition": "Cy/cos(radians(alpha))", "description": "", "templateType": "anything", "can_override": false}, "sum": {"name": "sum", "group": "Unnamed group", "definition": "vecA+vecC+vecW+vecT", "description": "", "templateType": "anything", "can_override": false}, "L": {"name": "L", "group": "Ungrouped variables", "definition": "qty(random(8..16),'ft')", "description": "", "templateType": "anything", "can_override": false}, "dir_C_from_X": {"name": "dir_C_from_X", "group": "Unnamed group", "definition": "qty(degrees(atan2(scalar(cy),scalar(cx))),'deg')", "description": "", "templateType": "anything", "can_override": false}, "debug": {"name": "debug", "group": "Ungrouped variables", "definition": "false", "description": "", "templateType": "anything", "can_override": false}}, "variablesTest": {"condition": "ab > r + qty(1,'ft') and ab < l-r- qty(2,'ft')", "maxRuns": 100}, "ungrouped_variables": ["L", "r", "ab", "alpha", "theta", "W", "T", "debug"], "variable_groups": [{"name": "Unnamed group", "variables": ["Cy", "magC", "Ax", "Ay", "magA", "dirA", "Cx", "vecA", "vecC", "vecW", "vecT", "sum", "dirC", "dir_C_from_X"]}], "functions": {"display": {"parameters": [["q", "quantity"]], "type": "string", "language": "jme", "definition": "string(siground(q,4))"}}, "preamble": {"js": "", "css": ""}, "parts": [{"type": "gapfill", "useCustomName": true, "customName": "Reaction at C", "marks": 0, "scripts": {}, "customMarkingAlgorithm": "interpreted_angle:  // a qty string corrected to standard angle\n  student_angle[2]  + student_angle[1] * student_angle[0] + student_units\n\nmagnitude:\n  studentAnswer[3]\n\nstudent_angle:\n  [mod(matchnumber(studentAnswer[0],['plain','en'])[1],360), // angle\n  [1,-1][indices(studentAnswer[1],[true])[0]],      // ccw = 1 cw = -1\n  [0,90,180,-90][indices(studentAnswer[2],[true])[0]]] // reference axis\n\nstudent_units:\n  studentAnswer[0][len(matchnumber(studentAnswer[0],['plain','en'])[0])..len(studentAnswer[0])]\n\ninterpreted_answers:\n  [interpreted_angle, studentAnswer[1], studentAnswer[2], studentAnswer[3]]\n\ngap_feedback (Feedback on each of the gaps):\n    map(\n        try(\n            let(\n                result, submit_part(gaps[gap_number][\"path\"],answer),\n                gap, gaps[gap_number],\n                name, gap[\"name\"],  \n                noFeedbackIcon, not gap[\"settings\"][\"showFeedbackIcon\"],\n                assert(name=\"\" or len(gaps)=1,feedback(translate('part.gapfill.feedback header',[\"name\": name])));\n                concat_feedback(filter(x[\"op\"]<>\"warning\",x,result[\"feedback\"]), if(marks>0,result[\"marks\"]/marks,1), noFeedbackIcon);\n                    result\n            ),\n            err,\n            fail(translate(\"part.gapfill.error marking gap\",[\"name\": gaps[gap_number][\"name\"], \"message\": err]))\n        ),\n        [gap_number,answer,index],\n        zip([3,0],[studentAnswer[3], interpreted_angle],[1,2])\n    )\n\n", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": true, "showFeedbackIcon": true, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "prompt": "<p>Determine the magnitude and direction of the reaction at the roller at $C$.</p>\n<p>Force $\\mathbf{C}$ has a magnitude of [[3]]&nbsp;</p>\n<p>acting at an angle of&nbsp;[[0]] measured&nbsp;[[1]]&nbsp;from the [[2]].</p>\n<p><span data-jme-visible=\"debug\"><strong>C</strong> = {magC}, angle={dirC}&deg;</span></p>", "gaps": [{"type": "angle", "useCustomName": true, "customName": "angleC", "marks": "10", "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": true, "showFeedbackIcon": false, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "settings": {"expected_answer": "dir_C_from_X", "unit_penalty": "20", "close_penalty": "20", "close_tol": "0.5", "right_tol": "0.2"}}, {"type": "1_n_2", "useCustomName": true, "customName": "sign", "marks": 0, "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": false, "showFeedbackIcon": false, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "minMarks": 0, "maxMarks": 0, "shuffleChoices": false, "displayType": "dropdownlist", "displayColumns": 0, "showCellAnswerState": true, "choices": ["CCW", "CW"], "matrix": [0, 0], "distractors": ["", ""]}, {"type": "1_n_2", "useCustomName": true, "customName": "ref", "marks": 0, "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": false, "showFeedbackIcon": false, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "minMarks": 0, "maxMarks": 0, "shuffleChoices": false, "displayType": "dropdownlist", "displayColumns": 0, "showCellAnswerState": true, "choices": ["+x axis", "+y axis", "-x axis", "-y axis"], "matrix": [0, 0, 0, 0], "distractors": ["", "", "", ""]}, {"type": "engineering-answer", "useCustomName": true, "customName": "magC", "marks": "10", "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": true, "showFeedbackIcon": true, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "settings": {"correctAnswer": "magC", "right": "0.2", "close": "1.0", "C1": "75", "C2": "50", "C3": "25"}}], "sortAnswers": false}, {"type": "gapfill", "useCustomName": true, "customName": "Reaction at A", "marks": 0, "scripts": {}, "customMarkingAlgorithm": "interpreted_angle:  // a qty string corrected to standard angle\n  student_angle[2]  + student_angle[1] * student_angle[0] + student_units\n\nmagnitude:\n  studentAnswer[3]\n\nstudent_angle:\n  [mod(matchnumber(studentAnswer[0],['plain','en'])[1],360), // angle\n  [1,-1][indices(studentAnswer[1],[true])[0]],      // ccw = 1 cw = -1\n  [0,90,180,-90][indices(studentAnswer[2],[true])[0]]] // reference axis\n\nstudent_units:\n  studentAnswer[0][len(matchnumber(studentAnswer[0],['plain','en'])[0])..len(studentAnswer[0])]\n\ninterpreted_answers:\n  [interpreted_angle, studentAnswer[1], studentAnswer[2], studentAnswer[3]]\n\ngap_feedback (Feedback on each of the gaps):\n    map(\n        try(\n            let(\n                result, submit_part(gaps[gap_number][\"path\"],answer),\n                gap, gaps[gap_number],\n                name, gap[\"name\"],  \n                noFeedbackIcon, not gap[\"settings\"][\"showFeedbackIcon\"],\n                assert(name=\"\" or len(gaps)=1,feedback(translate('part.gapfill.feedback header',[\"name\": name])));\n                concat_feedback(filter(x[\"op\"]<>\"warning\",x,result[\"feedback\"]), if(marks>0,result[\"marks\"]/marks,1), noFeedbackIcon);\n                    result\n            ),\n            err,\n            fail(translate(\"part.gapfill.error marking gap\",[\"name\": gaps[gap_number][\"name\"], \"message\": err]))\n        ),\n        [gap_number,answer,index],\n        zip([3,0],[studentAnswer[3], interpreted_angle],[1,2])\n    )\n\n", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": true, "showFeedbackIcon": true, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "prompt": "<p>Determine the magnitude and direction of the reaction at pin $A$.</p>\n<p>Force $\\mathbf{A}$ has a magnitude of [[3]]&nbsp;</p>\n<p>acting at an angle of&nbsp;[[0]] measured&nbsp;[[1]]&nbsp;from the [[2]].</p>\n<p><span data-jme-visible=\"debug\"><strong>A</strong>&nbsp;= {magA}, angle={dirA}&deg;</span></p>", "gaps": [{"type": "angle", "useCustomName": true, "customName": "angleA", "marks": "10", "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": true, "showFeedbackIcon": false, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "settings": {"expected_answer": "qty(dirA,'deg')", "unit_penalty": "20", "close_penalty": "20", "close_tol": "0.5", "right_tol": "0.2"}}, {"type": "1_n_2", "useCustomName": true, "customName": "sign", "marks": 0, "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": false, "showFeedbackIcon": false, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "minMarks": 0, "maxMarks": 0, "shuffleChoices": false, "displayType": "dropdownlist", "displayColumns": 0, "showCellAnswerState": true, "choices": ["CCW", "CW"], "matrix": [0, 0], "distractors": ["", ""]}, {"type": "1_n_2", "useCustomName": true, "customName": "ref", "marks": 0, "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": false, "showFeedbackIcon": false, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "minMarks": 0, "maxMarks": 0, "shuffleChoices": false, "displayType": "dropdownlist", "displayColumns": 0, "showCellAnswerState": true, "choices": ["+x axis", "+y axis", "-x axis", "-y axis"], "matrix": [0, 0, 0, 0], "distractors": ["", "", "", ""]}, {"type": "engineering-answer", "useCustomName": true, "customName": "magA", "marks": "10", "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": true, "showFeedbackIcon": true, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "settings": {"correctAnswer": "magA", "right": "0.2", "close": "1.0", "C1": "75", "C2": "50", "C3": "25"}}], "sortAnswers": false}], "partsMode": "all", "maxMarks": 0, "objectives": [], "penalties": [], "objectiveVisibility": "always", "penaltyVisibility": "always"}, {"name": "Equilibrium of a rigid body: bell crank", "extensions": ["geogebra", "quantities"], "custom_part_types": [{"source": {"pk": 12, "author": {"name": "William Haynes", "pk": 2530}, "edit_page": "/part_type/12/edit"}, "name": "Angle quantity 2020", "short_name": "angle", "description": "<p>Adjusts all angles to 0 &lt; $\\theta$ &lt; 360.</p>\n<p>Accepts '&deg;' and 'deg' as units.</p>\n<p>Penalizes if not close enough or no units.</p>\n<p>90&deg; = -270&deg; = 450&deg;</p>", "help_url": "", "input_widget": "string", "input_options": {"correctAnswer": "plain_string(settings['expected_answer']) ", "hint": {"static": true, "value": ""}, "allowEmpty": {"static": true, "value": false}}, "can_be_gap": true, "can_be_step": true, "marking_script": "original_student_scalar:\nmatchnumber(studentAnswer,['plain','en'])[1]\n\nstudent_scalar:\nmod(original_student_scalar,360)\n\n\nstudent_unit:\nstudentAnswer[len(matchnumber(studentAnswer,['plain','en'])[0])..len(studentAnswer)]\n\ninterpreted_unit:\nif(trim(student_unit)='\u00b0','deg',student_unit)\n\ninterpreted_answer:\nqty(mod(student_scalar,360),'deg')\n\nclose:\nwithintolerance(student_scalar, correct_scalar,decimal(settings['close_tol']))\n\ncorrect_scalar:\nmod(scalar(settings['expected_answer']),360)\n\nright:\nwithintolerance(student_scalar, correct_scalar, decimal(settings['right_tol']))\n\ngood_unit:\nsame(qty(1,interpreted_unit),qty(1,'deg'))\n\nmark:\nassert(close,incorrect('Incorrect.');end());\nif(right,correct('Correct angle.'), set_credit(1 - settings['close_penalty'],'Angle is close.'));\nassert(good_unit,sub_credit(settings['unit_penalty'], 'Missing or incorrect units.'))", "marking_notes": [{"name": "original_student_scalar", "description": "<p>Retuns the scalar part of students answer (which is a quantity) as a number.</p>", "definition": "matchnumber(studentAnswer,['plain','en'])[1]"}, {"name": "student_scalar", "description": "<p>Normalize angle with mod 360</p>", "definition": "mod(original_student_scalar,360)\n"}, {"name": "student_unit", "description": "<p>matchnumber(studentAnswer,['plain','en'])[0] is a string \"12.34\"</p>", "definition": "studentAnswer[len(matchnumber(studentAnswer,['plain','en'])[0])..len(studentAnswer)]"}, {"name": "interpreted_unit", "description": "<p>Allows student to use degree symbol or 'deg' for units.</p>", "definition": "if(trim(student_unit)='\u00b0','deg',student_unit)"}, {"name": "interpreted_answer", "description": "A value representing the student's answer to this part.", "definition": "qty(mod(student_scalar,360),'deg')"}, {"name": "close", "description": "", "definition": "withintolerance(student_scalar, correct_scalar,decimal(settings['close_tol']))"}, {"name": "correct_scalar", "description": "<p>Normalize expected_answer with mod 360</p>", "definition": "mod(scalar(settings['expected_answer']),360)"}, {"name": "right", "description": "", "definition": "withintolerance(student_scalar, correct_scalar, decimal(settings['right_tol']))"}, {"name": "good_unit", "description": "", "definition": "same(qty(1,interpreted_unit),qty(1,'deg'))"}, {"name": "mark", "description": "This is the main marking note. It should award credit and provide feedback based on the student's answer.", "definition": "assert(close,incorrect('Incorrect.');end());\nif(right,correct('Correct angle.'), set_credit(1 - settings['close_penalty'],'Angle is close.'));\nassert(good_unit,sub_credit(settings['unit_penalty'], 'Missing or incorrect units.'))"}], "settings": [{"name": "expected_answer", "label": "Expected Answer", "help_url": "", "hint": "Expected angle as a quantity.", "input_type": "code", "default_value": "qty(30,'deg')", "evaluate": true}, {"name": "unit_penalty", "label": "Unit penalty", "help_url": "", "hint": "Penalty for not including degree sign or 'deg'.", "input_type": "percent", "default_value": "20"}, {"name": "close_penalty", "label": "Close Penalty", "help_url": "", "hint": "Penalty for close answer.", "input_type": "percent", "default_value": "20"}, {"name": "close_tol", "label": "Close", "help_url": "", "hint": "Angle must be $\\pm$ this many degrees to be marked close. &nbsp;&nbsp;", "input_type": "code", "default_value": "0.5", "evaluate": false}, {"name": "right_tol", "label": "Right ", "help_url": "", "hint": "Angle must be $\\pm$ this many degrees to be marked correct. &nbsp;", "input_type": "code", "default_value": "0.1", "evaluate": false}], "public_availability": "restricted", "published": false, "extensions": ["quantities"]}, {"source": {"pk": 19, "author": {"name": "William Haynes", "pk": 2530}, "edit_page": "/part_type/19/edit"}, "name": "Engineering Accuracy with units", "short_name": "engineering-answer", "description": "<p>A value with units marked right if within an adjustable % error of the correct value. &nbsp;Marked close if within a wider margin of error.</p>", "help_url": "", "input_widget": "string", "input_options": {"correctAnswer": "siground(settings['correctAnswer'],4)", "hint": {"static": true, "value": ""}, "allowEmpty": {"static": true, "value": true}}, "can_be_gap": true, "can_be_step": true, "marking_script": "mark:\nswitch( \n  right and good_units and right_sign, add_credit(1.0,'Correct.'),\n  right and good_units and not right_sign, add_credit(settings['C2'],'Wrong sign.'),\n  right and right_sign and not good_units, add_credit(settings['C2'],'Correct value, but wrong or missing units.'),\n  close and good_units, add_credit(settings['C1'],'Close.'),\n  close and not good_units, add_credit(settings['C3'],'Answer is close, but wrong or missing units.'),\n  incorrect('Wrong answer.')\n)\n\n\ninterpreted_answer:\nqty(student_scalar, student_units)\n\n\n\ncorrect_quantity:\nsettings[\"correctAnswer\"]\n\n\n\ncorrect_units:\nunits(correct_quantity)\n\n\nallowed_notation_styles:\n[\"plain\",\"en\"]\n\nmatch_student_number:\nmatchnumber(studentAnswer,allowed_notation_styles)\n\nstudent_scalar:\nmatch_student_number[1]\n\nstudent_units:\nreplace_regex('ohms','ohm',\n  replace_regex('\u00b0', ' deg',\n    replace_regex('-', ' ' ,\n      studentAnswer[len(match_student_number[0])..len(studentAnswer)])),\"i\")\n\ngood_units:\ntry(\ncompatible(quantity(1, student_units),correct_units),\nmsg,\nfeedback(msg);false)\n\n\nstudent_quantity:\nswitch(not good_units, \n       student_scalar * correct_units, \n       not right_sign,\n       -quantity(student_scalar, student_units),\n       quantity(student_scalar,student_units)\n)\n  \n\n\npercent_error:\ntry(\nscalar(abs((correct_quantity - student_quantity)/correct_quantity))*100  \n,msg,\nif(student_quantity=correct_quantity,0,100))\n   \n\nright:\npercent_error <= settings['right']\n\n\nclose:\nright_sign and percent_error <= settings['close']\n\nright_sign:\nsign(student_scalar) = sign(correct_quantity)", "marking_notes": [{"name": "mark", "description": "This is the main marking note. It should award credit and provide feedback based on the student's answer.", "definition": "switch( \n  right and good_units and right_sign, add_credit(1.0,'Correct.'),\n  right and good_units and not right_sign, add_credit(settings['C2'],'Wrong sign.'),\n  right and right_sign and not good_units, add_credit(settings['C2'],'Correct value, but wrong or missing units.'),\n  close and good_units, add_credit(settings['C1'],'Close.'),\n  close and not good_units, add_credit(settings['C3'],'Answer is close, but wrong or missing units.'),\n  incorrect('Wrong answer.')\n)\n"}, {"name": "interpreted_answer", "description": "A value representing the student's answer to this part.", "definition": "qty(student_scalar, student_units)\n\n"}, {"name": "correct_quantity", "description": "", "definition": "settings[\"correctAnswer\"]\n\n"}, {"name": "correct_units", "description": "", "definition": "units(correct_quantity)\n"}, {"name": "allowed_notation_styles", "description": "", "definition": "[\"plain\",\"en\"]"}, {"name": "match_student_number", "description": "", "definition": "matchnumber(studentAnswer,allowed_notation_styles)"}, {"name": "student_scalar", "description": "", "definition": "match_student_number[1]"}, {"name": "student_units", "description": "<p>Modify&nbsp;the&nbsp;unit portion of&nbsp;the student's answer by</p>\n<p>1. replacing \"ohms\" with \"ohm\" &nbsp;case insensitive</p>\n<p>2.&nbsp;replacing '-'&nbsp;with ' '&nbsp;</p>\n<p>3. replacing '&deg;' with ' deg'&nbsp;</p>\n<p>to allow answers like 10 ft-lb and 30&deg;</p>", "definition": "replace_regex('ohms','ohm',\n  replace_regex('\u00b0', ' deg',\n    replace_regex('-', ' ' ,\n      studentAnswer[len(match_student_number[0])..len(studentAnswer)])),\"i\")"}, {"name": "good_units", "description": "", "definition": "try(\ncompatible(quantity(1, student_units),correct_units),\nmsg,\nfeedback(msg);false)\n"}, {"name": "student_quantity", "description": "<p>This fixes the student answer for two common errors. &nbsp;</p>\n<p>If student_units are wrong&nbsp;&nbsp;- replace with correct units</p>\n<p>If student_scalar has the wrong sign - replace with right sign</p>\n<p>If student makes both errors, only one gets fixed.</p>", "definition": "switch(not good_units, \n       student_scalar * correct_units, \n       not right_sign,\n       -quantity(student_scalar, student_units),\n       quantity(student_scalar,student_units)\n)\n  \n"}, {"name": "percent_error", "description": "", "definition": "try(\nscalar(abs((correct_quantity - student_quantity)/correct_quantity))*100  \n,msg,\nif(student_quantity=correct_quantity,0,100))\n   "}, {"name": "right", "description": "", "definition": "percent_error <= settings['right']\n"}, {"name": "close", "description": "<p>Only marked close if the student actually has the right sign.</p>", "definition": "right_sign and percent_error <= settings['close']"}, {"name": "right_sign", "description": "", "definition": "sign(student_scalar) = sign(correct_quantity) "}], "settings": [{"name": "correctAnswer", "label": "Correct Quantity.", "help_url": "", "hint": "The correct answer given as a JME quantity.", "input_type": "code", "default_value": "", "evaluate": true}, {"name": "right", "label": "% Accuracy for right.", "help_url": "", "hint": "Question will be considered correct if the scalar part of the student's answer is within this % of correct value.", "input_type": "code", "default_value": "0.2", "evaluate": true}, {"name": "close", "label": "% Accuracy for close.", "help_url": "", "hint": "Question will be considered close if the scalar part of the student's answer is within this % of correct value.", "input_type": "code", "default_value": "1.0", "evaluate": true}, {"name": "C1", "label": "Close with units.", "help_url": "", "hint": "Partial Credit for close value with appropriate units. &nbsp;if correct answer is 100 N and close is &plusmn;1%,<br />99 &nbsp;N is accepted.", "input_type": "percent", "default_value": "75"}, {"name": "C2", "label": "No units or wrong sign", "help_url": "", "hint": "Partial credit for forgetting units or using wrong sign.<br />If the correct answer is 100 N, both 100 and -100 N are accepted.", "input_type": "percent", "default_value": "50"}, {"name": "C3", "label": "Close, no units.", "help_url": "", "hint": "Partial Credit for close value but forgotten units.<br />This value would be close&nbsp;if the expected units were provided. &nbsp;If the correct answer is 100 N, and close is &plusmn;1%,<br />99 is accepted.", "input_type": "percent", "default_value": "25"}], "public_availability": "always", "published": true, "extensions": ["quantities"]}], "resources": [], "navigation": {"allowregen": true, "showfrontpage": false, "preventleave": false, "typeendtoleave": false}, "contributors": [{"name": "William Haynes", "profile_url": "https://numbas.mathcentre.ac.uk/accounts/profile/2530/"}], "tags": ["angle from reference", "mechanics", "Mechanics", "rigid body equilibrium", "Rigid body equilibrium", "Statics", "statics", "three force body", "Three force body"], "metadata": {"description": "<p></p>\n<p>Two forces act on a bell crank.&nbsp;This problem has two unknown magnitudes and an unknown direction which makes it tricky to solve&nbsp;by the equilibrium equation method. &nbsp;</p>\n<p>The solution is much simpler if three force body principle is used.</p>", "licence": "Creative Commons Attribution-NonCommercial 4.0 International"}, "statement": "<p>{geogebra_applet('at35nexv',[['L_B',scalar(L_B)],['L_C',scalar(L_C)],['&alpha;',alpha+'&deg;'],['&beta;',beta+'&deg;']])}</p>\n<p>Two forces, $\\mathbf{B}$ and $\\mathbf{C}$<em>,</em> act on the arms of the rigid bell crank shown. &nbsp;Arm $AB$ is {L_B} long, and arm $AC$ is {L_C} long, and the bell crank is free to pivot on pin $A$.&nbsp;</p>", "advice": "<p><strong>Equilibrium Equation&nbsp;approach :</strong></p>\n<p>Four Unknowns: Magnitudes of $\\mathbf{B}$ and $\\mathbf{C}$, &nbsp;$A_x$ , $A_y$</p>\n<p>Four Equations: &nbsp;Three equations of equilibrium plus $A = \\sqrt{A_x^2 + A_y^2} = \\var{limit}$</p>\n<p></p>\n<p>\\[\\begin{align}\\Sigma M_A &amp;= 0\\\\ M_B &amp;= M_C \\\\B \\cdot d_{AB}\\, \\cos \\beta &amp;=&nbsp;C \\cdot d_{AC}\\\\C&amp;= B \\,\\cos \\var{beta}&deg;\\left( \\frac{\\var{L_B}}{\\var{L_C}}\\right)\\\\C &amp;=\\var{siground(cos(radians(beta)) * (L_B /L_C),4)}B \\end{align}\\]</p>\n<p>\\[\\begin{align}\\Sigma F_x &amp;= 0\\\\A_x &amp;= C_x\\\\&amp;=C \\,\\sin&nbsp;\\var{alpha}&deg;\\\\&amp;=(\\var{siground(cos(radians(beta)) * (L_B /L_C),4)} B)\\, \\sin \\var{alpha}&deg;\\\\&amp;=\\var{siground(mag_c&nbsp;*&nbsp;sin(radians(alpha)),4) } B &nbsp;\\end{align}\\]</p>\n<p>\\[\\begin{align}\\Sigma F_y &amp;= 0\\\\A_y &amp;=B+ C_y\\\\&amp;= B +C \\cos \\var{alpha}&deg;\\\\&nbsp;&amp;= B +(\\var{siground(mag_C,4)} B ) \\cos \\var{alpha}&deg; \\\\ &amp;= \\var{siground(1 + mag_c&nbsp;* &nbsp;cos(radians(alpha)),4) } B \\end{align}\\]</p>\n<p>\\[\\begin{align}A=\\sqrt{A_x^2 + A_y^2} &amp;= \\var{limit}\\\\ \\sqrt{(\\var{siground(mag_c * sin(radians(alpha)),4) } B)^2 + (\\var{siground(1 + mag_c * &nbsp;cos(radians(alpha)) ,4) } B)^2 }&amp;= \\var{limit}\\\\B\\sqrt{(\\var{siground(mag_c * sin(radians(alpha)),4) })^2 + (\\var{siground(1 + mag_c * &nbsp;cos(radians(alpha)) ,4) })^2 }&amp;= \\var{limit}\\\\B=\\var{siground(limit/mag_A,4)}\\end{align}\\]</p>\n<p><strong>Three force body approach:</strong></p>\n<p>Three unknowns: Magnitudes of $\\mathbf{B}$ and $\\mathbf{C}$, direction of $\\mathbf{A}$.</p>\n<p>The lines of action of $\\mathbf{B}$ and $\\mathbf{C}$ are known so you can use geometry to find their intersection point. &nbsp;Force $\\mathbf{A}$ passes through this point too, so you can determine from this the direction of $\\mathbf{A}$.</p>\n<p>With the three directions known as well as the magnitude of $\\mathbf{A}$, draw a force triangle and use the law of sines to solve for $B$ and $C$.</p>", "rulesets": {}, "builtin_constants": {"e": true, "pi,\u03c0": true, "i": true}, "constants": [], "variables": {"FB": {"name": "FB", "group": "output", "definition": "vector(0,-1)", "description": "", "templateType": "anything", "can_override": false}, "FC": {"name": "FC", "group": "output", "definition": "mag_C vector(cos(radians(theta_C)),sin(radians(theta_C)))", "description": "", "templateType": "anything", "can_override": false}, "alpha": {"name": "alpha", "group": "inputs", "definition": "random(20..70#5)", "description": "", "templateType": "anything", "can_override": false}, "theta_A": {"name": "theta_A", "group": "output", "definition": "degrees(atan2(FA[1],FA[0]))", "description": "", "templateType": "anything", "can_override": false}, "FA": {"name": "FA", "group": "output", "definition": "-(FB+FC)", "description": "", "templateType": "anything", "can_override": false}, "theta_C": {"name": "theta_C", "group": "output", "definition": "270 + alpha", "description": "", "templateType": "anything", "can_override": false}, "limit": {"name": "limit", "group": "inputs", "definition": "qty(random(100..1000#25), units[1])", "description": "", "templateType": "anything", "can_override": false}, "beta": {"name": "beta", "group": "inputs", "definition": "random(20..70#5)", "description": "", "templateType": "anything", "can_override": false}, "L_B": {"name": "L_B", "group": "inputs", "definition": "precround(qty(random(4..24),'in') in units[0],0)", "description": "", "templateType": "anything", "can_override": false}, "units": {"name": "units", "group": "inputs", "definition": "random(['in','lb'],['cm','N'])", "description": "", "templateType": "anything", "can_override": false}, "mag_a": {"name": "mag_a", "group": "output", "definition": "abs(FA)", "description": "", "templateType": "anything", "can_override": false}, "mag_c": {"name": "mag_c", "group": "output", "definition": "mag_B*scalar(L_B) cos(radians(beta)) / scalar(L_C)", "description": "", "templateType": "anything", "can_override": false}, "mag_b": {"name": "mag_b", "group": "output", "definition": "1", "description": "", "templateType": "anything", "can_override": false}, "debug": {"name": "debug", "group": "inputs", "definition": "false", "description": "", "templateType": "anything", "can_override": false}, "L_C": {"name": "L_C", "group": "inputs", "definition": "random(0.75..1.5#0.25) L_B", "description": "", "templateType": "anything", "can_override": false}}, "variablesTest": {"condition": "(180 - alpha - beta) >=70", "maxRuns": 100}, "ungrouped_variables": [], "variable_groups": [{"name": "inputs", "variables": ["L_C", "alpha", "beta", "L_B", "limit", "units", "debug"]}, {"name": "output", "variables": ["mag_c", "mag_b", "theta_C", "FC", "FB", "mag_a", "theta_A", "FA"]}], "functions": {}, "preamble": {"js": "", "css": ""}, "parts": [{"type": "gapfill", "useCustomName": true, "customName": "Force B", "marks": 0, "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": true, "showFeedbackIcon": true, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "prompt": "<p>Determine the maximum force which can be applied at $B$ if the magnitude of the reaction at $A$&nbsp;is not to exceed {limit}.</p>\n<p>$B =$ &nbsp;[[0]]</p>\n<p><span data-jme-visible=\"debug\"><em>B</em>&nbsp;= {siground(limit/mag_A,4)}</span></p>", "gaps": [{"type": "engineering-answer", "useCustomName": true, "customName": "B max", "marks": "10", "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": false, "showFeedbackIcon": true, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "settings": {"correctAnswer": "limit/mag_A", "right": "0.2", "close": "1.0", "C1": "75", "C2": "50", "C3": "25"}}], "sortAnswers": false}, {"type": "gapfill", "useCustomName": true, "customName": "Reaction at C", "marks": 0, "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": true, "showFeedbackIcon": true, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "prompt": "<p>What is the corresponding magnitude of the force at $C$ ?</p>\n<p><i>$C= $ </i>&nbsp;[[0]]</p>\n<p><span data-jme-visible=\"debug\"><em>C</em>&nbsp; = {siground(mag_C limit/mag_A,4)}</span></p>", "gaps": [{"type": "engineering-answer", "useCustomName": true, "customName": "C", "marks": "10", "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": true, "showFeedbackIcon": true, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "settings": {"correctAnswer": "mag_C limit/mag_A", "right": "0.2", "close": "1.0", "C1": "75", "C2": "50", "C3": "25"}}], "sortAnswers": false}, {"type": "gapfill", "useCustomName": true, "customName": "Direction of A", "marks": 0, "scripts": {}, "customMarkingAlgorithm": "interpreted_angle:  // a qty string corrected to standard angle\n  student_angle[2]  + student_angle[1] * student_angle[0] + student_units\n\n\nstudent_angle:\n  [mod(matchnumber(studentAnswer[0],['plain','en'])[1],360), // angle\n  [1,-1][indices(studentAnswer[1],[true])[0]],      // ccw = 1 cw = -1\n  [0,90,180,-90][indices(studentAnswer[2],[true])[0]]] // reference axis\n\nstudent_units:\n  studentAnswer[0][len(matchnumber(studentAnswer[0],['plain','en'])[0])..len(studentAnswer[0])]\n\ninterpreted_answers:\n  [interpreted_angle, studentAnswer[1], studentAnswer[2]]\n\ngap_feedback (Feedback on each of the gaps):\n    map(\n        try(\n            let(\n                result, submit_part(gaps[gap_number][\"path\"],answer),\n                gap, gaps[gap_number],\n                name, gap[\"name\"],  \n                noFeedbackIcon, not gap[\"settings\"][\"showFeedbackIcon\"],\n                assert(name=\"\" or len(gaps)=1,feedback(translate('part.gapfill.feedback header',[\"name\": name])));\n                concat_feedback(filter(x[\"op\"]<>\"warning\",x,result[\"feedback\"]), if(marks>0,result[\"marks\"]/marks,1), noFeedbackIcon);\n                    result\n            ),\n            err,\n            fail(translate(\"part.gapfill.error marking gap\",[\"name\": gaps[gap_number][\"name\"], \"message\": err]))\n        ),\n        [gap_number,answer,index],\n        zip([0],[interpreted_angle],[1])\n    )\n\n\n\n", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": true, "showFeedbackIcon": true, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "prompt": "<p>In what direction does the force at $A$&nbsp;act?</p>\n<p>$\\theta_A$ =&nbsp;[[0]]&nbsp;measured [[1]]&nbsp;from the&nbsp;[[2]].</p>\n<p><span data-jme-visible=\"debug\">$\\theta_A$ = {theta_A}</span></p>", "gaps": [{"type": "angle", "useCustomName": true, "customName": "theta A", "marks": "10", "scripts": {}, "customMarkingAlgorithm": "interpreted_angle:  // a qty string corrected to standard angle\n  student_angle[2]  + student_angle[1] * student_angle[0] + student_units\n\n\nstudent_angle:\n  [mod(matchnumber(studentAnswer[0],['plain','en'])[1],360), // angle\n  [1,-1][indices(studentAnswer[1],[true])[0]],      // ccw = 1 cw = -1\n  [0,90,180,-90][indices(studentAnswer[2],[true])[0]]] // reference axis\n\nstudent_units:\n  studentAnswer[0][len(matchnumber(studentAnswer[0],['plain','en'])[0])..len(studentAnswer[0])]\n\ninterpreted_answers:\n  [interpreted_angle, studentAnswer[1], studentAnswer[2]]\n\ngap_feedback (Feedback on each of the gaps):\n    map(\n        try(\n            let(\n                result, submit_part(gaps[gap_number][\"path\"],answer),\n                gap, gaps[gap_number],\n                name, gap[\"name\"],  \n                noFeedbackIcon, not gap[\"settings\"][\"showFeedbackIcon\"],\n                assert(name=\"\" or len(gaps)=1,feedback(translate('part.gapfill.feedback header',[\"name\": name])));\n                concat_feedback(filter(x[\"op\"]<>\"warning\",x,result[\"feedback\"]), if(marks>0,result[\"marks\"]/marks,1), noFeedbackIcon);\n                    result\n            ),\n            err,\n            fail(translate(\"part.gapfill.error marking gap\",[\"name\": gaps[gap_number][\"name\"], \"message\": err]))\n        ),\n        [gap_number,answer,index],\n        zip([0],[interpreted_angle],[1])\n    )\n\n\n\n", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": true, "showFeedbackIcon": false, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "settings": {"expected_answer": "precround(qty(theta_A,'deg'),1)", "unit_penalty": "20", "close_penalty": "20", "close_tol": "0.5", "right_tol": "0.2"}}, {"type": "1_n_2", "useCustomName": true, "customName": "sign", "marks": 0, "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": false, "showFeedbackIcon": false, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "minMarks": 0, "maxMarks": 0, "shuffleChoices": false, "displayType": "dropdownlist", "displayColumns": 0, "showCellAnswerState": true, "choices": ["CCW", "CW"], "matrix": [0, 0], "distractors": ["", ""]}, {"type": "1_n_2", "useCustomName": true, "customName": "ref", "marks": 0, "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": false, "showFeedbackIcon": false, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "minMarks": 0, "maxMarks": 0, "shuffleChoices": false, "displayType": "dropdownlist", "displayColumns": 0, "showCellAnswerState": true, "choices": ["+x axis", "+y axis", "-x axis", "-y axis"], "matrix": [0, 0, 0, 0], "distractors": ["", "", "", ""]}], "sortAnswers": false}], "partsMode": "all", "maxMarks": 0, "objectives": [], "penalties": [], "objectiveVisibility": "always", "penaltyVisibility": "always"}, {"name": "Equilibrium of a rigid body: Car on a hill", "extensions": ["geogebra", "quantities", "weh"], "custom_part_types": [{"source": {"pk": 19, "author": {"name": "William Haynes", "pk": 2530}, "edit_page": "/part_type/19/edit"}, "name": "Engineering Accuracy with units", "short_name": "engineering-answer", "description": "<p>A value with units marked right if within an adjustable % error of the correct value. &nbsp;Marked close if within a wider margin of error.</p>", "help_url": "", "input_widget": "string", "input_options": {"correctAnswer": "siground(settings['correctAnswer'],4)", "hint": {"static": true, "value": ""}, "allowEmpty": {"static": true, "value": true}}, "can_be_gap": true, "can_be_step": true, "marking_script": "mark:\nswitch( \n  right and good_units and right_sign, add_credit(1.0,'Correct.'),\n  right and good_units and not right_sign, add_credit(settings['C2'],'Wrong sign.'),\n  right and right_sign and not good_units, add_credit(settings['C2'],'Correct value, but wrong or missing units.'),\n  close and good_units, add_credit(settings['C1'],'Close.'),\n  close and not good_units, add_credit(settings['C3'],'Answer is close, but wrong or missing units.'),\n  incorrect('Wrong answer.')\n)\n\n\ninterpreted_answer:\nqty(student_scalar, student_units)\n\n\n\ncorrect_quantity:\nsettings[\"correctAnswer\"]\n\n\n\ncorrect_units:\nunits(correct_quantity)\n\n\nallowed_notation_styles:\n[\"plain\",\"en\"]\n\nmatch_student_number:\nmatchnumber(studentAnswer,allowed_notation_styles)\n\nstudent_scalar:\nmatch_student_number[1]\n\nstudent_units:\nreplace_regex('ohms','ohm',\n  replace_regex('\u00b0', ' deg',\n    replace_regex('-', ' ' ,\n      studentAnswer[len(match_student_number[0])..len(studentAnswer)])),\"i\")\n\ngood_units:\ntry(\ncompatible(quantity(1, student_units),correct_units),\nmsg,\nfeedback(msg);false)\n\n\nstudent_quantity:\nswitch(not good_units, \n       student_scalar * correct_units, \n       not right_sign,\n       -quantity(student_scalar, student_units),\n       quantity(student_scalar,student_units)\n)\n  \n\n\npercent_error:\ntry(\nscalar(abs((correct_quantity - student_quantity)/correct_quantity))*100  \n,msg,\nif(student_quantity=correct_quantity,0,100))\n   \n\nright:\npercent_error <= settings['right']\n\n\nclose:\nright_sign and percent_error <= settings['close']\n\nright_sign:\nsign(student_scalar) = sign(correct_quantity)", "marking_notes": [{"name": "mark", "description": "This is the main marking note. It should award credit and provide feedback based on the student's answer.", "definition": "switch( \n  right and good_units and right_sign, add_credit(1.0,'Correct.'),\n  right and good_units and not right_sign, add_credit(settings['C2'],'Wrong sign.'),\n  right and right_sign and not good_units, add_credit(settings['C2'],'Correct value, but wrong or missing units.'),\n  close and good_units, add_credit(settings['C1'],'Close.'),\n  close and not good_units, add_credit(settings['C3'],'Answer is close, but wrong or missing units.'),\n  incorrect('Wrong answer.')\n)\n"}, {"name": "interpreted_answer", "description": "A value representing the student's answer to this part.", "definition": "qty(student_scalar, student_units)\n\n"}, {"name": "correct_quantity", "description": "", "definition": "settings[\"correctAnswer\"]\n\n"}, {"name": "correct_units", "description": "", "definition": "units(correct_quantity)\n"}, {"name": "allowed_notation_styles", "description": "", "definition": "[\"plain\",\"en\"]"}, {"name": "match_student_number", "description": "", "definition": "matchnumber(studentAnswer,allowed_notation_styles)"}, {"name": "student_scalar", "description": "", "definition": "match_student_number[1]"}, {"name": "student_units", "description": "<p>Modify&nbsp;the&nbsp;unit portion of&nbsp;the student's answer by</p>\n<p>1. replacing \"ohms\" with \"ohm\" &nbsp;case insensitive</p>\n<p>2.&nbsp;replacing '-'&nbsp;with ' '&nbsp;</p>\n<p>3. replacing '&deg;' with ' deg'&nbsp;</p>\n<p>to allow answers like 10 ft-lb and 30&deg;</p>", "definition": "replace_regex('ohms','ohm',\n  replace_regex('\u00b0', ' deg',\n    replace_regex('-', ' ' ,\n      studentAnswer[len(match_student_number[0])..len(studentAnswer)])),\"i\")"}, {"name": "good_units", "description": "", "definition": "try(\ncompatible(quantity(1, student_units),correct_units),\nmsg,\nfeedback(msg);false)\n"}, {"name": "student_quantity", "description": "<p>This fixes the student answer for two common errors. &nbsp;</p>\n<p>If student_units are wrong&nbsp;&nbsp;- replace with correct units</p>\n<p>If student_scalar has the wrong sign - replace with right sign</p>\n<p>If student makes both errors, only one gets fixed.</p>", "definition": "switch(not good_units, \n       student_scalar * correct_units, \n       not right_sign,\n       -quantity(student_scalar, student_units),\n       quantity(student_scalar,student_units)\n)\n  \n"}, {"name": "percent_error", "description": "", "definition": "try(\nscalar(abs((correct_quantity - student_quantity)/correct_quantity))*100  \n,msg,\nif(student_quantity=correct_quantity,0,100))\n   "}, {"name": "right", "description": "", "definition": "percent_error <= settings['right']\n"}, {"name": "close", "description": "<p>Only marked close if the student actually has the right sign.</p>", "definition": "right_sign and percent_error <= settings['close']"}, {"name": "right_sign", "description": "", "definition": "sign(student_scalar) = sign(correct_quantity) "}], "settings": [{"name": "correctAnswer", "label": "Correct Quantity.", "help_url": "", "hint": "The correct answer given as a JME quantity.", "input_type": "code", "default_value": "", "evaluate": true}, {"name": "right", "label": "% Accuracy for right.", "help_url": "", "hint": "Question will be considered correct if the scalar part of the student's answer is within this % of correct value.", "input_type": "code", "default_value": "0.2", "evaluate": true}, {"name": "close", "label": "% Accuracy for close.", "help_url": "", "hint": "Question will be considered close if the scalar part of the student's answer is within this % of correct value.", "input_type": "code", "default_value": "1.0", "evaluate": true}, {"name": "C1", "label": "Close with units.", "help_url": "", "hint": "Partial Credit for close value with appropriate units. &nbsp;if correct answer is 100 N and close is &plusmn;1%,<br />99 &nbsp;N is accepted.", "input_type": "percent", "default_value": "75"}, {"name": "C2", "label": "No units or wrong sign", "help_url": "", "hint": "Partial credit for forgetting units or using wrong sign.<br />If the correct answer is 100 N, both 100 and -100 N are accepted.", "input_type": "percent", "default_value": "50"}, {"name": "C3", "label": "Close, no units.", "help_url": "", "hint": "Partial Credit for close value but forgotten units.<br />This value would be close&nbsp;if the expected units were provided. &nbsp;If the correct answer is 100 N, and close is &plusmn;1%,<br />99 is accepted.", "input_type": "percent", "default_value": "25"}], "public_availability": "always", "published": true, "extensions": ["quantities"]}], "resources": [], "navigation": {"allowregen": true, "showfrontpage": false, "preventleave": false, "typeendtoleave": false}, "contributors": [{"name": "William Haynes", "profile_url": "https://numbas.mathcentre.ac.uk/accounts/profile/2530/"}], "tags": ["Equilibrium", "equilibrium", "Mechanics", "mechanics", "Rigid Body", "rigid body", "Statics", "statics", "three force body", "Three force body"], "metadata": {"description": "<p>Classic problem of a vehicle parked on an incline. &nbsp;Best solved by rotating the coordinate system.</p>\n<p>Image Credit:&nbsp;https://svgsilh.com/image/34325.html &nbsp;CC-0</p>", "licence": "Creative Commons Attribution-NonCommercial 4.0 International"}, "statement": "<p>{geogebra_applet('w4xb6n95',['alpha':&nbsp;radians(alpha), 'fbd': [visible: false] ])}</p>\n<p>A car is parked on a {alpha}&deg;&nbsp;slope, with the rear wheels locked by the parking brake.&nbsp;&nbsp;Find the components&nbsp;of the forces acting on each of the front and rear wheels, parallel and perpendicular to the roadbed.</p>\n<div>\n<p style=\"padding-left: 30px;\"><strong>Vehicle Specifications</strong></p>\n<table style=\"margin-left: 30px; float: left;\">\n<tbody>\n<tr>\n<td>Wheelbase</td>\n<td>$L = $ {wb} mm</td>\n</tr>\n<tr>\n<td>Curb weight</td>\n<td>$m = $ {m} kg</td>\n</tr>\n<tr>\n<td>Center of Gravity</td>\n<td>$d = $ {d} mm<br/>$h = $ {h} mm</td>\n</tr>\n</tbody>\n</table>\n</div>", "advice": "<p style=\"float: right; padding: 5px;\">{geogebra_applet('w4xb6n95',['alpha':&nbsp;radians(alpha), 'fbd': [definition: 'true', visible: true] ])}</p>\n<p>First, draw a free body diagram of the vehicle. &nbsp;</p>\n<p>For convenience, let the <em>x</em>- and <em>y-</em> directions be parallel and perpendicular to the roadbed and define $\\alpha$ as the&nbsp;the angle the road makes with the horizontal.&nbsp;Note that $\\alpha$ is also the&nbsp;angle between the&nbsp;weight and the y-direction. Treat the front wheels like a roller, the rear wheels like a rough surface.</p>\n<p style=\"padding-left: 30px;\">$\\alpha = \\var{alpha}&deg;$</p>\n<p>Define $L$ as the distance between the front and rear wheels:</p>\n<p style=\"padding-left: 30px;\">$L= \\var{qty(wb,'mm')}$</p>\n<p>Note that the curb 'weight' is actually a mass, so let:</p>\n<p style=\"padding-left: 30px;\">$\\begin{align}W &amp;= m g\\\\ &amp;= (\\var{qty(m,'kg')}) \\cdot (\\var{qty(g, 'm/s^2')}) =\\var{show(w)}\\\\ W_x&amp; = W \\sin \\alpha = \\var{show(w_x)}\\\\W_y&amp; = W \\cos \\alpha = \\var{show(w_y)}\\end{align}$</p>\n<p>Apply the equations of equilibrium, starting with the sum of the moments about either A or B, since two unknown&nbsp;forces&nbsp;intersect there.</p>\n<p style=\"padding-left: 30px;\">$\\begin{align}\\Sigma M_A &amp;= 0\\\\&nbsp;&nbsp;B_y&nbsp;(L)&nbsp;&amp;= W_y(d)&nbsp;+ W_x&nbsp;&nbsp;(h)\\\\ B_y &amp;= &nbsp;W \\left(\\dfrac{d \\cos \\alpha + h \\sin \\alpha}{L}\\right)\\\\&amp;= \\var{show(B_y)}\\\\\\\\ \\Sigma F_x &amp;= 0\\\\ B_x &amp;= W_x\\\\ B_x &amp;= \\var{show(w_x)}\\\\\\\\ \\Sigma F_y &amp;= 0\\\\A + B_y &amp;=&nbsp;W_y \\\\A &amp;= W_y-B_y\\\\&amp;=\\var{show(A)}\\end{align}$</p>\n<p>Since there are two front wheels and two rear wheels, the forces acting on each wheel are&nbsp;half of these values:</p>\n<p style=\"padding-left: 30px;\">$A_{||} = 0 \\text{ N} \\qquad A_\\perp = A/2 = \\var{show(A/2)} \\qquad&nbsp;B_{||} = B_x/2 = &nbsp;\\var{show(B_x/2)} \\qquad&nbsp;B_\\perp = B_y/2 = \\var{show(B_y/2)}$</p>", "rulesets": {}, "builtin_constants": {"e": true, "pi,\u03c0": true, "i": true}, "constants": [], "variables": {"B_x": {"name": "B_x", "group": "answers", "definition": "w_x", "description": "", "templateType": "anything", "can_override": false}, "h": {"name": "h", "group": "Ungrouped variables", "definition": "round(random(90..110) d /100)", "description": "", "templateType": "anything", "can_override": false}, "A": {"name": "A", "group": "answers", "definition": "w_y-b_y", "description": "", "templateType": "anything", "can_override": false}, "w_y": {"name": "w_y", "group": "answers", "definition": "W cos(radians(alpha))", "description": "", "templateType": "anything", "can_override": false}, "d": {"name": "d", "group": "Ungrouped variables", "definition": "round(random(0.25..0.35#0.01)wb)", "description": "", "templateType": "anything", "can_override": false}, "B_y": {"name": "B_y", "group": "answers", "definition": "(w_x h + w_y d)/wb", "description": "", "templateType": "anything", "can_override": false}, "m": {"name": "m", "group": "Ungrouped variables", "definition": "random(1200..1400)", "description": "<p>curb weight in kg</p>", "templateType": "anything", "can_override": false}, "W": {"name": "W", "group": "answers", "definition": "m g ", "description": "<p>weight of vechicle</p>", "templateType": "anything", "can_override": false}, "w_x": {"name": "w_x", "group": "answers", "definition": "W sin(radians(alpha))", "description": "", "templateType": "anything", "can_override": false}, "g": {"name": "g", "group": "Ungrouped variables", "definition": "9.81", "description": "", "templateType": "anything", "can_override": false}, "wb": {"name": "wb", "group": "Ungrouped variables", "definition": "random(2450..2580)", "description": "<p>wheelbase in mm</p>", "templateType": "anything", "can_override": false}, "alpha": {"name": "alpha", "group": "Ungrouped variables", "definition": "random([10,15,20,25,30])", "description": "", "templateType": "anything", "can_override": false}, "units": {"name": "units", "group": "Ungrouped variables", "definition": "['N','mm']", "description": "", "templateType": "anything", "can_override": false}, "debug": {"name": "debug", "group": "answers", "definition": "false", "description": "", "templateType": "anything", "can_override": false}}, "variablesTest": {"condition": "", "maxRuns": 100}, "ungrouped_variables": ["alpha", "m", "wb", "units", "d", "h", "g"], "variable_groups": [{"name": "answers", "variables": ["w_y", "A", "w_x", "B_x", "B_y", "W", "debug"]}], "functions": {"show": {"parameters": [["f", "number"]], "type": "number", "language": "jme", "definition": "siground(qty(f,'N'),4)"}}, "preamble": {"js": "", "css": ""}, "parts": [{"type": "gapfill", "useCustomName": false, "customName": "", "marks": 0, "scripts": {"mark": {"script": "//numbasGGBApplet0.setValue('fbd',true)\n//numbasGGBApplet0.setVisible('fbd',true)", "order": "after"}}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": true, "showFeedbackIcon": true, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "prompt": "<p>$A_{||} =$ &nbsp;[[0]]&nbsp; &nbsp;$\\qquad A_\\perp = $&nbsp;[[3]]&nbsp;<span data-jme-visible=\"debug\"> $0 B_{\\perp} = &nbsp; \\var{qty(A/2 ,'N')}$</span></p>\n<p>$B_{||}&nbsp;=$ &nbsp;[[1]]&nbsp; &nbsp;$\\qquad B_\\perp = $&nbsp;[[2]]&nbsp; <span data-jme-visible=\"debug\">$B_{||}= \\var{qty(B_x/2,'N')} B_{\\perp} = &nbsp; \\var{qty(B_y/2,'N')}$</span></p>", "gaps": [{"type": "engineering-answer", "useCustomName": false, "customName": "", "marks": "5", "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": true, "showFeedbackIcon": true, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "settings": {"correctAnswer": "qty(0, 'N')", "right": "0.2", "close": "1.0", "C1": "75", "C2": "50", "C3": "25"}}, {"type": "engineering-answer", "useCustomName": false, "customName": "", "marks": "5", "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": true, "showFeedbackIcon": true, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "settings": {"correctAnswer": "qty(B_x/2,'N')", "right": "0.2", "close": "1.0", "C1": "75", "C2": "50", "C3": "25"}}, {"type": "engineering-answer", "useCustomName": false, "customName": "", "marks": "5", "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": true, "showFeedbackIcon": true, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "settings": {"correctAnswer": "qty(B_y/2,'N')", "right": "0.2", "close": "1.0", "C1": "75", "C2": "50", "C3": "25"}}, {"type": "engineering-answer", "useCustomName": false, "customName": "", "marks": "5", "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": true, "showFeedbackIcon": true, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "settings": {"correctAnswer": "qty(A/2 ,'N')", "right": "0.2", "close": "1.0", "C1": "75", "C2": "50", "C3": "25"}}], "sortAnswers": false}], "partsMode": "all", "maxMarks": 0, "objectives": [], "penalties": [], "objectiveVisibility": "always", "penaltyVisibility": "always"}, {"name": "Equilibrium of a rigid body: hand truck", "extensions": ["geogebra", "quantities"], "custom_part_types": [{"source": {"pk": 19, "author": {"name": "William Haynes", "pk": 2530}, "edit_page": "/part_type/19/edit"}, "name": "Engineering Accuracy with units", "short_name": "engineering-answer", "description": "<p>A value with units marked right if within an adjustable % error of the correct value. &nbsp;Marked close if within a wider margin of error.</p>", "help_url": "", "input_widget": "string", "input_options": {"correctAnswer": "siground(settings['correctAnswer'],4)", "hint": {"static": true, "value": ""}, "allowEmpty": {"static": true, "value": true}}, "can_be_gap": true, "can_be_step": true, "marking_script": "mark:\nswitch( \n  right and good_units and right_sign, add_credit(1.0,'Correct.'),\n  right and good_units and not right_sign, add_credit(settings['C2'],'Wrong sign.'),\n  right and right_sign and not good_units, add_credit(settings['C2'],'Correct value, but wrong or missing units.'),\n  close and good_units, add_credit(settings['C1'],'Close.'),\n  close and not good_units, add_credit(settings['C3'],'Answer is close, but wrong or missing units.'),\n  incorrect('Wrong answer.')\n)\n\n\ninterpreted_answer:\nqty(student_scalar, student_units)\n\n\n\ncorrect_quantity:\nsettings[\"correctAnswer\"]\n\n\n\ncorrect_units:\nunits(correct_quantity)\n\n\nallowed_notation_styles:\n[\"plain\",\"en\"]\n\nmatch_student_number:\nmatchnumber(studentAnswer,allowed_notation_styles)\n\nstudent_scalar:\nmatch_student_number[1]\n\nstudent_units:\nreplace_regex('ohms','ohm',\n  replace_regex('\u00b0', ' deg',\n    replace_regex('-', ' ' ,\n      studentAnswer[len(match_student_number[0])..len(studentAnswer)])),\"i\")\n\ngood_units:\ntry(\ncompatible(quantity(1, student_units),correct_units),\nmsg,\nfeedback(msg);false)\n\n\nstudent_quantity:\nswitch(not good_units, \n       student_scalar * correct_units, \n       not right_sign,\n       -quantity(student_scalar, student_units),\n       quantity(student_scalar,student_units)\n)\n  \n\n\npercent_error:\ntry(\nscalar(abs((correct_quantity - student_quantity)/correct_quantity))*100  \n,msg,\nif(student_quantity=correct_quantity,0,100))\n   \n\nright:\npercent_error <= settings['right']\n\n\nclose:\nright_sign and percent_error <= settings['close']\n\nright_sign:\nsign(student_scalar) = sign(correct_quantity)", "marking_notes": [{"name": "mark", "description": "This is the main marking note. It should award credit and provide feedback based on the student's answer.", "definition": "switch( \n  right and good_units and right_sign, add_credit(1.0,'Correct.'),\n  right and good_units and not right_sign, add_credit(settings['C2'],'Wrong sign.'),\n  right and right_sign and not good_units, add_credit(settings['C2'],'Correct value, but wrong or missing units.'),\n  close and good_units, add_credit(settings['C1'],'Close.'),\n  close and not good_units, add_credit(settings['C3'],'Answer is close, but wrong or missing units.'),\n  incorrect('Wrong answer.')\n)\n"}, {"name": "interpreted_answer", "description": "A value representing the student's answer to this part.", "definition": "qty(student_scalar, student_units)\n\n"}, {"name": "correct_quantity", "description": "", "definition": "settings[\"correctAnswer\"]\n\n"}, {"name": "correct_units", "description": "", "definition": "units(correct_quantity)\n"}, {"name": "allowed_notation_styles", "description": "", "definition": "[\"plain\",\"en\"]"}, {"name": "match_student_number", "description": "", "definition": "matchnumber(studentAnswer,allowed_notation_styles)"}, {"name": "student_scalar", "description": "", "definition": "match_student_number[1]"}, {"name": "student_units", "description": "<p>Modify&nbsp;the&nbsp;unit portion of&nbsp;the student's answer by</p>\n<p>1. replacing \"ohms\" with \"ohm\" &nbsp;case insensitive</p>\n<p>2.&nbsp;replacing '-'&nbsp;with ' '&nbsp;</p>\n<p>3. replacing '&deg;' with ' deg'&nbsp;</p>\n<p>to allow answers like 10 ft-lb and 30&deg;</p>", "definition": "replace_regex('ohms','ohm',\n  replace_regex('\u00b0', ' deg',\n    replace_regex('-', ' ' ,\n      studentAnswer[len(match_student_number[0])..len(studentAnswer)])),\"i\")"}, {"name": "good_units", "description": "", "definition": "try(\ncompatible(quantity(1, student_units),correct_units),\nmsg,\nfeedback(msg);false)\n"}, {"name": "student_quantity", "description": "<p>This fixes the student answer for two common errors. &nbsp;</p>\n<p>If student_units are wrong&nbsp;&nbsp;- replace with correct units</p>\n<p>If student_scalar has the wrong sign - replace with right sign</p>\n<p>If student makes both errors, only one gets fixed.</p>", "definition": "switch(not good_units, \n       student_scalar * correct_units, \n       not right_sign,\n       -quantity(student_scalar, student_units),\n       quantity(student_scalar,student_units)\n)\n  \n"}, {"name": "percent_error", "description": "", "definition": "try(\nscalar(abs((correct_quantity - student_quantity)/correct_quantity))*100  \n,msg,\nif(student_quantity=correct_quantity,0,100))\n   "}, {"name": "right", "description": "", "definition": "percent_error <= settings['right']\n"}, {"name": "close", "description": "<p>Only marked close if the student actually has the right sign.</p>", "definition": "right_sign and percent_error <= settings['close']"}, {"name": "right_sign", "description": "", "definition": "sign(student_scalar) = sign(correct_quantity) "}], "settings": [{"name": "correctAnswer", "label": "Correct Quantity.", "help_url": "", "hint": "The correct answer given as a JME quantity.", "input_type": "code", "default_value": "", "evaluate": true}, {"name": "right", "label": "% Accuracy for right.", "help_url": "", "hint": "Question will be considered correct if the scalar part of the student's answer is within this % of correct value.", "input_type": "code", "default_value": "0.2", "evaluate": true}, {"name": "close", "label": "% Accuracy for close.", "help_url": "", "hint": "Question will be considered close if the scalar part of the student's answer is within this % of correct value.", "input_type": "code", "default_value": "1.0", "evaluate": true}, {"name": "C1", "label": "Close with units.", "help_url": "", "hint": "Partial Credit for close value with appropriate units. &nbsp;if correct answer is 100 N and close is &plusmn;1%,<br />99 &nbsp;N is accepted.", "input_type": "percent", "default_value": "75"}, {"name": "C2", "label": "No units or wrong sign", "help_url": "", "hint": "Partial credit for forgetting units or using wrong sign.<br />If the correct answer is 100 N, both 100 and -100 N are accepted.", "input_type": "percent", "default_value": "50"}, {"name": "C3", "label": "Close, no units.", "help_url": "", "hint": "Partial Credit for close value but forgotten units.<br />This value would be close&nbsp;if the expected units were provided. &nbsp;If the correct answer is 100 N, and close is &plusmn;1%,<br />99 is accepted.", "input_type": "percent", "default_value": "25"}], "public_availability": "always", "published": true, "extensions": ["quantities"]}], "resources": [["question-resources/fbd.png", "/srv/numbas/media/question-resources/fbd.png"]], "navigation": {"allowregen": true, "showfrontpage": false, "preventleave": false, "typeendtoleave": false}, "contributors": [{"name": "William Haynes", "profile_url": "https://numbas.mathcentre.ac.uk/accounts/profile/2530/"}], "tags": ["equilibrium", "Equilibrium", "equilibrium of a rigid body", "mechanics", "Mechanics", "Statics", "statics"], "metadata": {"description": "<p>A hand truck on wheels. &nbsp;Easiest to solve by rotating coordinate system.</p>", "licence": "Creative Commons Attribution-NonCommercial 4.0 International"}, "statement": "<p>{geogebra_applet('kptuqdfk',[['&alpha;',alpha+\"&deg;\"],['d1','\"'+string(d1)+'\"'],['d2','\"'+string(d2)+'\"'],['d3','\"'+string(d3)+'\"']])}</p>\n<p>A hand truck is used to move a{random(' nitrogen', 'n oxygen', 'n&nbsp;R-134a', ' compressed air', ' refrigerant')} cylinder. &nbsp;Knowing that the combined weight of the truck and cylinder is {W} acting&nbsp;at the center of gravity $G$, determine the vertical force $A$&nbsp;which must&nbsp;be applied to the handle to maintain the cylinder at this {alpha}&deg; angle, and also the corresponding reaction at each of the two wheels.</p>\n<p></p>\n<p></p>\n<p></p>", "advice": "<p>Start by drawing a free body diagram and gathering the known values:&nbsp;</p>\n<p>$W = \\var{W}, \\alpha = \\var{alpha}&deg;, d_1 = \\var{d1}, d_2 = \\var{d2}$ &nbsp;and $d_3 = \\var{d3}$.</p>\n<p style=\"float: right;\"><img src=\"resources/question-resources/fbd.png\" width=\"274\" height=\"282\"/></p>\n<p>It's easiest to solve this problem if you resolve&nbsp;the weight into components parallel and perpendicular to the axis of the cylinder, since the dimensions in these directions are given, so:</p>\n<p></p>\n<p>$W_{\\perp}&nbsp;= W \\cos \\alpha = &nbsp;\\var{display(W * cos(radians(alpha)))}$ and</p>\n<p>$W_{\\|} = W \\sin \\alpha = &nbsp;\\var{display(W * sin(radians(alpha)))}$</p>\n<p></p>\n<p>To find $A$, apply the&nbsp;sum of the moments about point $B$:</p>\n<p></p>\n<p>$\\begin{align} \\Sigma M_B &amp;= 0\\\\ A d_3 &nbsp;+ W_{\\|} d_1 &amp;= W_{\\perp} d_2 \\\\ A &amp;= &nbsp;&nbsp;\\dfrac{ W_{\\perp} d_2 -W_{\\|} d_1 }{d_3}\\\\ &amp;= \\frac{\\var{display(W_perp)}(\\var{d2}) -\\var{display(W_par)}(\\var{d1}) }{\\var{d3}}\\\\&amp;= \\var{display(A)}\\end{align}$</p>\n<p></p>\n<p>To find <em>B, </em>the force on one wheel, apply the sum of the forces in the <em>y</em>-direction:</p>\n<p>$\\begin{align}\\Sigma F_y &amp;= 0\\\\ A - W + 2 B &amp;= 0\\\\B &amp;= \\frac{W-A}{2} \\\\&amp;=\\frac{\\var{W} - \\var{display(A)}}{2}\\\\&amp; = \\var{display(B)}\\end{align}$</p>", "rulesets": {}, "builtin_constants": {"e": true, "pi,\u03c0": true, "i": true}, "constants": [], "variables": {"W_par": {"name": "W_par", "group": "solution", "definition": "W sin(radians(alpha))", "description": "", "templateType": "anything", "can_override": false}, "B": {"name": "B", "group": "Ungrouped variables", "definition": "(W-A)/2", "description": "", "templateType": "anything", "can_override": false}, "W": {"name": "W", "group": "Ungrouped variables", "definition": "qty(random(180..180#5),'lb')", "description": "", "templateType": "anything", "can_override": false}, "d1": {"name": "d1", "group": "Ungrouped variables", "definition": "qty(random(8..14),'in')", "description": "", "templateType": "anything", "can_override": false}, "d3": {"name": "d3", "group": "Ungrouped variables", "definition": "round(qty(random(36..40) cos(radians(alpha)),'in'),'1 in')\n  \n  ", "description": "", "templateType": "anything", "can_override": false}, "d2": {"name": "d2", "group": "Ungrouped variables", "definition": "qty(random(20..26#2),'in')", "description": "", "templateType": "anything", "can_override": false}, "alpha": {"name": "alpha", "group": "Ungrouped variables", "definition": "random(40..60 except 45)", "description": "", "templateType": "anything", "can_override": false}, "A": {"name": "A", "group": "Ungrouped variables", "definition": "(-W_par d1 + W_perp d2)/d3", "description": "", "templateType": "anything", "can_override": false}, "W_perp": {"name": "W_perp", "group": "solution", "definition": "W cos(radians(alpha))", "description": "", "templateType": "anything", "can_override": false}}, "variablesTest": {"condition": "", "maxRuns": 100}, "ungrouped_variables": ["alpha", "W", "d1", "d2", "d3", "A", "B"], "variable_groups": [{"name": "solution", "variables": ["W_perp", "W_par"]}], "functions": {"display": {"parameters": [["q", "quantity"]], "type": "string", "language": "jme", "definition": "string(siground(q,4))"}}, "preamble": {"js": "", "css": ""}, "parts": [{"type": "gapfill", "useCustomName": true, "customName": "Handle", "marks": 0, "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": true, "showFeedbackIcon": true, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "prompt": "<p>Determine the force on the handle:</p>\n<p>$A =$ [[0]]&nbsp;</p>", "gaps": [{"type": "engineering-answer", "useCustomName": true, "customName": "A", "marks": "10", "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": true, "showFeedbackIcon": true, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "settings": {"correctAnswer": "A", "right": "0.2", "close": "1.0", "C1": "75", "C2": "50", "C3": "25"}}], "sortAnswers": false}, {"type": "gapfill", "useCustomName": true, "customName": "Wheels", "marks": 0, "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": true, "showFeedbackIcon": true, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "prompt": "<p>Determine the force acting on each wheel:</p>\n<p>$B =$ [[0]]&nbsp;</p>", "gaps": [{"type": "engineering-answer", "useCustomName": true, "customName": "B", "marks": "10", "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": true, "showFeedbackIcon": true, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "settings": {"correctAnswer": "B", "right": "0.2", "close": "1.0", "C1": "75", "C2": "50", "C3": "25"}}], "sortAnswers": false}], "partsMode": "all", "maxMarks": 0, "objectives": [], "penalties": [], "objectiveVisibility": "always", "penaltyVisibility": "always"}, {"name": "Equilibrium of a rigid body: triangle", "extensions": ["geogebra", "quantities"], "custom_part_types": [{"source": {"pk": 12, "author": {"name": "William Haynes", "pk": 2530}, "edit_page": "/part_type/12/edit"}, "name": "Angle quantity 2020", "short_name": "angle", "description": "<p>Adjusts all angles to 0 &lt; $\\theta$ &lt; 360.</p>\n<p>Accepts '&deg;' and 'deg' as units.</p>\n<p>Penalizes if not close enough or no units.</p>\n<p>90&deg; = -270&deg; = 450&deg;</p>", "help_url": "", "input_widget": "string", "input_options": {"correctAnswer": "plain_string(settings['expected_answer']) ", "hint": {"static": true, "value": ""}, "allowEmpty": {"static": true, "value": false}}, "can_be_gap": true, "can_be_step": true, "marking_script": "original_student_scalar:\nmatchnumber(studentAnswer,['plain','en'])[1]\n\nstudent_scalar:\nmod(original_student_scalar,360)\n\n\nstudent_unit:\nstudentAnswer[len(matchnumber(studentAnswer,['plain','en'])[0])..len(studentAnswer)]\n\ninterpreted_unit:\nif(trim(student_unit)='\u00b0','deg',student_unit)\n\ninterpreted_answer:\nqty(mod(student_scalar,360),'deg')\n\nclose:\nwithintolerance(student_scalar, correct_scalar,decimal(settings['close_tol']))\n\ncorrect_scalar:\nmod(scalar(settings['expected_answer']),360)\n\nright:\nwithintolerance(student_scalar, correct_scalar, decimal(settings['right_tol']))\n\ngood_unit:\nsame(qty(1,interpreted_unit),qty(1,'deg'))\n\nmark:\nassert(close,incorrect('Incorrect.');end());\nif(right,correct('Correct angle.'), set_credit(1 - settings['close_penalty'],'Angle is close.'));\nassert(good_unit,sub_credit(settings['unit_penalty'], 'Missing or incorrect units.'))", "marking_notes": [{"name": "original_student_scalar", "description": "<p>Retuns the scalar part of students answer (which is a quantity) as a number.</p>", "definition": "matchnumber(studentAnswer,['plain','en'])[1]"}, {"name": "student_scalar", "description": "<p>Normalize angle with mod 360</p>", "definition": "mod(original_student_scalar,360)\n"}, {"name": "student_unit", "description": "<p>matchnumber(studentAnswer,['plain','en'])[0] is a string \"12.34\"</p>", "definition": "studentAnswer[len(matchnumber(studentAnswer,['plain','en'])[0])..len(studentAnswer)]"}, {"name": "interpreted_unit", "description": "<p>Allows student to use degree symbol or 'deg' for units.</p>", "definition": "if(trim(student_unit)='\u00b0','deg',student_unit)"}, {"name": "interpreted_answer", "description": "A value representing the student's answer to this part.", "definition": "qty(mod(student_scalar,360),'deg')"}, {"name": "close", "description": "", "definition": "withintolerance(student_scalar, correct_scalar,decimal(settings['close_tol']))"}, {"name": "correct_scalar", "description": "<p>Normalize expected_answer with mod 360</p>", "definition": "mod(scalar(settings['expected_answer']),360)"}, {"name": "right", "description": "", "definition": "withintolerance(student_scalar, correct_scalar, decimal(settings['right_tol']))"}, {"name": "good_unit", "description": "", "definition": "same(qty(1,interpreted_unit),qty(1,'deg'))"}, {"name": "mark", "description": "This is the main marking note. It should award credit and provide feedback based on the student's answer.", "definition": "assert(close,incorrect('Incorrect.');end());\nif(right,correct('Correct angle.'), set_credit(1 - settings['close_penalty'],'Angle is close.'));\nassert(good_unit,sub_credit(settings['unit_penalty'], 'Missing or incorrect units.'))"}], "settings": [{"name": "expected_answer", "label": "Expected Answer", "help_url": "", "hint": "Expected angle as a quantity.", "input_type": "code", "default_value": "qty(30,'deg')", "evaluate": true}, {"name": "unit_penalty", "label": "Unit penalty", "help_url": "", "hint": "Penalty for not including degree sign or 'deg'.", "input_type": "percent", "default_value": "20"}, {"name": "close_penalty", "label": "Close Penalty", "help_url": "", "hint": "Penalty for close answer.", "input_type": "percent", "default_value": "20"}, {"name": "close_tol", "label": "Close", "help_url": "", "hint": "Angle must be $\\pm$ this many degrees to be marked close. &nbsp;&nbsp;", "input_type": "code", "default_value": "0.5", "evaluate": false}, {"name": "right_tol", "label": "Right ", "help_url": "", "hint": "Angle must be $\\pm$ this many degrees to be marked correct. &nbsp;", "input_type": "code", "default_value": "0.1", "evaluate": false}], "public_availability": "restricted", "published": false, "extensions": ["quantities"]}, {"source": {"pk": 19, "author": {"name": "William Haynes", "pk": 2530}, "edit_page": "/part_type/19/edit"}, "name": "Engineering Accuracy with units", "short_name": "engineering-answer", "description": "<p>A value with units marked right if within an adjustable % error of the correct value. &nbsp;Marked close if within a wider margin of error.</p>", "help_url": "", "input_widget": "string", "input_options": {"correctAnswer": "siground(settings['correctAnswer'],4)", "hint": {"static": true, "value": ""}, "allowEmpty": {"static": true, "value": true}}, "can_be_gap": true, "can_be_step": true, "marking_script": "mark:\nswitch( \n  right and good_units and right_sign, add_credit(1.0,'Correct.'),\n  right and good_units and not right_sign, add_credit(settings['C2'],'Wrong sign.'),\n  right and right_sign and not good_units, add_credit(settings['C2'],'Correct value, but wrong or missing units.'),\n  close and good_units, add_credit(settings['C1'],'Close.'),\n  close and not good_units, add_credit(settings['C3'],'Answer is close, but wrong or missing units.'),\n  incorrect('Wrong answer.')\n)\n\n\ninterpreted_answer:\nqty(student_scalar, student_units)\n\n\n\ncorrect_quantity:\nsettings[\"correctAnswer\"]\n\n\n\ncorrect_units:\nunits(correct_quantity)\n\n\nallowed_notation_styles:\n[\"plain\",\"en\"]\n\nmatch_student_number:\nmatchnumber(studentAnswer,allowed_notation_styles)\n\nstudent_scalar:\nmatch_student_number[1]\n\nstudent_units:\nreplace_regex('ohms','ohm',\n  replace_regex('\u00b0', ' deg',\n    replace_regex('-', ' ' ,\n      studentAnswer[len(match_student_number[0])..len(studentAnswer)])),\"i\")\n\ngood_units:\ntry(\ncompatible(quantity(1, student_units),correct_units),\nmsg,\nfeedback(msg);false)\n\n\nstudent_quantity:\nswitch(not good_units, \n       student_scalar * correct_units, \n       not right_sign,\n       -quantity(student_scalar, student_units),\n       quantity(student_scalar,student_units)\n)\n  \n\n\npercent_error:\ntry(\nscalar(abs((correct_quantity - student_quantity)/correct_quantity))*100  \n,msg,\nif(student_quantity=correct_quantity,0,100))\n   \n\nright:\npercent_error <= settings['right']\n\n\nclose:\nright_sign and percent_error <= settings['close']\n\nright_sign:\nsign(student_scalar) = sign(correct_quantity)", "marking_notes": [{"name": "mark", "description": "This is the main marking note. It should award credit and provide feedback based on the student's answer.", "definition": "switch( \n  right and good_units and right_sign, add_credit(1.0,'Correct.'),\n  right and good_units and not right_sign, add_credit(settings['C2'],'Wrong sign.'),\n  right and right_sign and not good_units, add_credit(settings['C2'],'Correct value, but wrong or missing units.'),\n  close and good_units, add_credit(settings['C1'],'Close.'),\n  close and not good_units, add_credit(settings['C3'],'Answer is close, but wrong or missing units.'),\n  incorrect('Wrong answer.')\n)\n"}, {"name": "interpreted_answer", "description": "A value representing the student's answer to this part.", "definition": "qty(student_scalar, student_units)\n\n"}, {"name": "correct_quantity", "description": "", "definition": "settings[\"correctAnswer\"]\n\n"}, {"name": "correct_units", "description": "", "definition": "units(correct_quantity)\n"}, {"name": "allowed_notation_styles", "description": "", "definition": "[\"plain\",\"en\"]"}, {"name": "match_student_number", "description": "", "definition": "matchnumber(studentAnswer,allowed_notation_styles)"}, {"name": "student_scalar", "description": "", "definition": "match_student_number[1]"}, {"name": "student_units", "description": "<p>Modify&nbsp;the&nbsp;unit portion of&nbsp;the student's answer by</p>\n<p>1. replacing \"ohms\" with \"ohm\" &nbsp;case insensitive</p>\n<p>2.&nbsp;replacing '-'&nbsp;with ' '&nbsp;</p>\n<p>3. replacing '&deg;' with ' deg'&nbsp;</p>\n<p>to allow answers like 10 ft-lb and 30&deg;</p>", "definition": "replace_regex('ohms','ohm',\n  replace_regex('\u00b0', ' deg',\n    replace_regex('-', ' ' ,\n      studentAnswer[len(match_student_number[0])..len(studentAnswer)])),\"i\")"}, {"name": "good_units", "description": "", "definition": "try(\ncompatible(quantity(1, student_units),correct_units),\nmsg,\nfeedback(msg);false)\n"}, {"name": "student_quantity", "description": "<p>This fixes the student answer for two common errors. &nbsp;</p>\n<p>If student_units are wrong&nbsp;&nbsp;- replace with correct units</p>\n<p>If student_scalar has the wrong sign - replace with right sign</p>\n<p>If student makes both errors, only one gets fixed.</p>", "definition": "switch(not good_units, \n       student_scalar * correct_units, \n       not right_sign,\n       -quantity(student_scalar, student_units),\n       quantity(student_scalar,student_units)\n)\n  \n"}, {"name": "percent_error", "description": "", "definition": "try(\nscalar(abs((correct_quantity - student_quantity)/correct_quantity))*100  \n,msg,\nif(student_quantity=correct_quantity,0,100))\n   "}, {"name": "right", "description": "", "definition": "percent_error <= settings['right']\n"}, {"name": "close", "description": "<p>Only marked close if the student actually has the right sign.</p>", "definition": "right_sign and percent_error <= settings['close']"}, {"name": "right_sign", "description": "", "definition": "sign(student_scalar) = sign(correct_quantity) "}], "settings": [{"name": "correctAnswer", "label": "Correct Quantity.", "help_url": "", "hint": "The correct answer given as a JME quantity.", "input_type": "code", "default_value": "", "evaluate": true}, {"name": "right", "label": "% Accuracy for right.", "help_url": "", "hint": "Question will be considered correct if the scalar part of the student's answer is within this % of correct value.", "input_type": "code", "default_value": "0.2", "evaluate": true}, {"name": "close", "label": "% Accuracy for close.", "help_url": "", "hint": "Question will be considered close if the scalar part of the student's answer is within this % of correct value.", "input_type": "code", "default_value": "1.0", "evaluate": true}, {"name": "C1", "label": "Close with units.", "help_url": "", "hint": "Partial Credit for close value with appropriate units. &nbsp;if correct answer is 100 N and close is &plusmn;1%,<br />99 &nbsp;N is accepted.", "input_type": "percent", "default_value": "75"}, {"name": "C2", "label": "No units or wrong sign", "help_url": "", "hint": "Partial credit for forgetting units or using wrong sign.<br />If the correct answer is 100 N, both 100 and -100 N are accepted.", "input_type": "percent", "default_value": "50"}, {"name": "C3", "label": "Close, no units.", "help_url": "", "hint": "Partial Credit for close value but forgotten units.<br />This value would be close&nbsp;if the expected units were provided. &nbsp;If the correct answer is 100 N, and close is &plusmn;1%,<br />99 is accepted.", "input_type": "percent", "default_value": "25"}], "public_availability": "always", "published": true, "extensions": ["quantities"]}], "resources": [], "navigation": {"allowregen": true, "showfrontpage": false, "preventleave": false, "typeendtoleave": false}, "contributors": [{"name": "William Haynes", "profile_url": "https://numbas.mathcentre.ac.uk/accounts/profile/2530/"}], "tags": ["angle from reference", "equilibrium", "Equilibrium", "Mechanics", "mechanics", "rigid body", "Rigid Body", "Statics", "statics"], "metadata": {"description": "<p>Find the reactions of a rigid body (a triangular plate) at a pin and roller. &nbsp;The load is at an angle.</p>", "licence": "Creative Commons Attribution-NonCommercial 4.0 International"}, "statement": "<p>{applet}</p>\n<p>The triangular plate is secured by a pin at $A$ and a roller at $C$.&nbsp;Determine the reactions at the pin and the roller when the plate&nbsp;is subjected to a {FB} load as shown by applying the equations of equilibrium.&nbsp;</p>\n<p><span data-jme-visible=\"debug\">B = ({abs(B)};{mod(degrees(atan2(B[1],B[0]))+360,360)}) {units[0]}</span></p>\n<p></p>", "advice": "<ol>\n<li>Draw a free body diagram.</li>\n<li>Apply $\\Sigma M_A$=0 to find the reaction at $C$. &nbsp;There's no x-component at $C$, because the support there is a roller. &nbsp;This should have been indicated on your free body diagram.</li>\n<li>Once $C$ and is&nbsp;known, apply $\\sum&nbsp;&nbsp;F_x = 0$ and $\\sum F_y=0$ to find components $A_x$ and $A_y$.</li>\n<li>With $A_x$ and $A_y$ known, use the pathagorean theorem to calculate the magnitude of $A$, and use trig to get the its direction.</li>\n</ol>", "rulesets": {}, "builtin_constants": {"e": true, "pi,\u03c0": true, "i": true}, "constants": [], "variables": {"debug": {"name": "debug", "group": "Inputs", "definition": "false", "description": "", "templateType": "anything", "can_override": false}, "FB": {"name": "FB", "group": "Ungrouped variables", "definition": "qty(magB,units[0])", "description": "", "templateType": "anything", "can_override": false}, "C": {"name": "C", "group": "Ungrouped variables", "definition": "vector(0,cross(B,rb)[2]/L)", "description": "", "templateType": "anything", "can_override": false}, "theta": {"name": "theta", "group": "Inputs", "definition": "random(alpha+180..360+alpha#5)", "description": "<p>reference direction. &nbsp;Set by student choice.</p>", "templateType": "anything", "can_override": false}, "A": {"name": "A", "group": "Ungrouped variables", "definition": "-(B+C)", "description": "", "templateType": "anything", "can_override": false}, "L": {"name": "L", "group": "Inputs", "definition": "random(2..6#0.2)", "description": "", "templateType": "anything", "can_override": false}, "B": {"name": "B", "group": "Ungrouped variables", "definition": "magB vector(cos(radians(theta)),sin(radians(theta)),0)", "description": "", "templateType": "anything", "can_override": false}, "dirA": {"name": "dirA", "group": "Ungrouped variables", "definition": "mod(degrees(atan2(A[1],A[0])),360)", "description": "", "templateType": "anything", "can_override": false}, "magB": {"name": "magB", "group": "Inputs", "definition": "random(1..15)random(10,20,50)", "description": "", "templateType": "anything", "can_override": false}, "rb": {"name": "rb", "group": "Ungrouped variables", "definition": "L/2 vector(1,tan(radians(alpha)),0)", "description": "<p>position vector to point B</p>", "templateType": "anything", "can_override": false}, "alpha": {"name": "alpha", "group": "Inputs", "definition": "65//random(25..65#5)", "description": "", "templateType": "anything", "can_override": false}, "units": {"name": "units", "group": "Inputs", "definition": "random([['kN','m'],['lb','ft'],['N','cm'],['lb','in']])", "description": "", "templateType": "anything", "can_override": false}, "applet": {"name": "applet", "group": "Inputs", "definition": "geogebra_applet('n3rkawce',params)", "description": "", "templateType": "anything", "can_override": false}, "params": {"name": "params", "group": "Inputs", "definition": "[text1: '\" '+ string(L) +' ' + units[1] + ' \"', alpha: radians(alpha), theta: radians(theta)]", "description": "", "templateType": "anything", "can_override": false}}, "variablesTest": {"condition": "theta <> 180 + alpha and theta <> 360 + alpha \nand C[1] > 0", "maxRuns": 100}, "ungrouped_variables": ["B", "rb", "C", "A", "dirA", "FB"], "variable_groups": [{"name": "Inputs", "variables": ["theta", "units", "debug", "alpha", "magB", "L", "applet", "params"]}], "functions": {}, "preamble": {"js": "", "css": ""}, "parts": [{"type": "gapfill", "useCustomName": true, "customName": "Reaction at C", "marks": 0, "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": true, "showFeedbackIcon": true, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "prompt": "<ol>\n<li>Draw and label a neat free body diagram of the triangular plate.</li>\n<li>Determine any needed distance or angles.</li>\n<li>Use $\\Sigma M_A = 0$ to find the reaction at <em>C</em>.</li>\n</ol>\n<p>$C = $ [[0]] &nbsp;</p>\n<p><span data-jme-visible=\"debug\">C = {abs(C)} {units[0]}</span></p>\n<p></p>", "gaps": [{"type": "engineering-answer", "useCustomName": true, "customName": "C", "marks": "10", "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": true, "showFeedbackIcon": true, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "settings": {"correctAnswer": "qty(abs(C),units[0])", "right": "0.2", "close": "1.0", "C1": "75", "C2": "50", "C3": "25"}}], "sortAnswers": false}, {"type": "gapfill", "useCustomName": true, "customName": "Reaction at A", "marks": 0, "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": true, "showFeedbackIcon": true, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "prompt": "<p>Use $\\Sigma F_x = 0$ and $\\Sigma F_y=0$ to find the magnitude and direction of the components of the reaction at <em>A</em>.</p>\n<p></p>\n<p>$A_x = $&nbsp;[[0]]&nbsp;[[1]]</p>\n<p>$A_y = $&nbsp;[[2]]&nbsp;[[3]]</p>\n<p><span data-jme-visible=\"debug\">A= {A} {units[0]}</span></p>", "gaps": [{"type": "engineering-answer", "useCustomName": true, "customName": "Ax", "marks": "8", "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": true, "showFeedbackIcon": true, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "settings": {"correctAnswer": "abs(qty(A[0],units[0]))", "right": "0.2", "close": "1.0", "C1": "75", "C2": "50", "C3": "25"}}, {"type": "1_n_2", "useCustomName": true, "customName": "dir Ay", "marks": 0, "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": false, "showFeedbackIcon": true, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "minMarks": 0, "maxMarks": 0, "shuffleChoices": false, "displayType": "dropdownlist", "displayColumns": 0, "showCellAnswerState": true, "choices": ["&rarr; (right)", "&larr; (left)", "Neither"], "matrix": "map(if(sign(A[0])=x,2,0),x,[1,-1,0])"}, {"type": "engineering-answer", "useCustomName": true, "customName": "Ay", "marks": "8", "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": true, "showFeedbackIcon": true, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "settings": {"correctAnswer": "abs(qty(A[1],units[0]))", "right": "0.2", "close": "1.0", "C1": "75", "C2": "50", "C3": "25"}}, {"type": "1_n_2", "useCustomName": true, "customName": "dir Ay", "marks": 0, "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": false, "showFeedbackIcon": true, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "minMarks": 0, "maxMarks": 0, "shuffleChoices": false, "displayType": "dropdownlist", "displayColumns": 0, "showCellAnswerState": true, "choices": ["&uarr; (up)", "&darr; (down)", "Neither"], "matrix": "map(if(sign(A[1])=x,2,0),x,[1,-1,0])"}], "sortAnswers": false}, {"type": "gapfill", "useCustomName": true, "customName": "Magnitude and direction of A", "marks": 0, "scripts": {}, "customMarkingAlgorithm": "interpreted_angle:  // a qty string corrected to standard angle\n  student_angle[2]  + student_angle[1] * student_angle[0] + student_units\n\nmagnitude:\n  studentAnswer[3]\n\nstudent_angle:\n  [mod(matchnumber(studentAnswer[0],['plain','en'])[1],360), // angle\n  [1,-1][indices(studentAnswer[1],[true])[0]],      // ccw = 1 cw = -1\n  [0,90,180,-90][indices(studentAnswer[2],[true])[0]]] // reference axis\n\nstudent_units:\n  studentAnswer[0][len(matchnumber(studentAnswer[0],['plain','en'])[0])..len(studentAnswer[0])]\n\ninterpreted_answers:\n  [interpreted_angle, studentAnswer[1], studentAnswer[2], studentAnswer[3]]\n\ngap_feedback (Feedback on each of the gaps):\n    map(\n        try(\n            let(\n                result, submit_part(gaps[gap_number][\"path\"],answer),\n                gap, gaps[gap_number],\n                name, gap[\"name\"],  \n                noFeedbackIcon, not gap[\"settings\"][\"showFeedbackIcon\"],\n                assert(name=\"\" or len(gaps)=1,feedback(translate('part.gapfill.feedback header',[\"name\": name])));\n                concat_feedback(filter(x[\"op\"]<>\"warning\",x,result[\"feedback\"]), if(marks>0,result[\"marks\"]/marks,1), noFeedbackIcon);\n                    result\n            ),\n            err,\n            fail(translate(\"part.gapfill.error marking gap\",[\"name\": gaps[gap_number][\"name\"], \"message\": err]))\n        ),\n        [gap_number,answer,index],\n        zip([3,0],[studentAnswer[3], interpreted_angle],[1,2])\n    )\n\n", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": true, "showFeedbackIcon": true, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "prompt": "<p>Determine the magnitude and direction of the resultant force $\\textbf{A}$ by resolving the components found in part b).</p>\n<p>Indicate direction&nbsp;as an angle less than 90&deg; measured from a chosen reference direction. Positive angle = counterclockwise.</p>\n<p>Force $\\textbf{A}$ has a magnitude of&nbsp;[[3]]</p>\n<p>acting at an angle of&nbsp;[[0]]&nbsp;&nbsp;measured&nbsp;[[1]]&nbsp;from the&nbsp;[[2]].</p>\n<p><span data-jme-visible=\"debug\">A= ({abs(A)};{mod(degrees(atan2(A[1],A[0]))+360,360)}) {units[0]}</span></p>", "gaps": [{"type": "angle", "useCustomName": true, "customName": "angle", "marks": "10", "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": true, "showFeedbackIcon": false, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "settings": {"expected_answer": "qty(dirA,'deg')", "unit_penalty": "20", "close_penalty": "20", "close_tol": "0.5", "right_tol": "0.2"}}, {"type": "1_n_2", "useCustomName": true, "customName": "sign", "marks": 0, "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": false, "showFeedbackIcon": false, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "minMarks": 0, "maxMarks": 0, "shuffleChoices": false, "displayType": "dropdownlist", "displayColumns": 0, "showCellAnswerState": true, "choices": ["CCW", "CW"], "matrix": [0, 0], "distractors": ["", ""]}, {"type": "1_n_2", "useCustomName": true, "customName": "ref", "marks": 0, "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": false, "showFeedbackIcon": false, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "minMarks": 0, "maxMarks": 0, "shuffleChoices": false, "displayType": "dropdownlist", "displayColumns": 0, "showCellAnswerState": true, "choices": ["+x axis", "+y axis", "-x axis", "-y axis"], "matrix": [0, 0, 0, 0], "distractors": ["", "", "", ""]}, {"type": "engineering-answer", "useCustomName": true, "customName": "Mag A", "marks": "10", "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": false, "showFeedbackIcon": true, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "settings": {"correctAnswer": "qty(abs(A),units[0])", "right": "0.2", "close": "1.0", "C1": "75", "C2": "50", "C3": "25"}}], "sortAnswers": false}], "partsMode": "all", "maxMarks": 0, "objectives": [], "penalties": [], "objectiveVisibility": "always", "penaltyVisibility": "always"}, {"name": "Equilibrium of a rigid body: truss", "extensions": ["geogebra", "quantities"], "custom_part_types": [{"source": {"pk": 12, "author": {"name": "William Haynes", "pk": 2530}, "edit_page": "/part_type/12/edit"}, "name": "Angle quantity 2020", "short_name": "angle", "description": "<p>Adjusts all angles to 0 &lt; $\\theta$ &lt; 360.</p>\n<p>Accepts '&deg;' and 'deg' as units.</p>\n<p>Penalizes if not close enough or no units.</p>\n<p>90&deg; = -270&deg; = 450&deg;</p>", "help_url": "", "input_widget": "string", "input_options": {"correctAnswer": "plain_string(settings['expected_answer']) ", "hint": {"static": true, "value": ""}, "allowEmpty": {"static": true, "value": false}}, "can_be_gap": true, "can_be_step": true, "marking_script": "original_student_scalar:\nmatchnumber(studentAnswer,['plain','en'])[1]\n\nstudent_scalar:\nmod(original_student_scalar,360)\n\n\nstudent_unit:\nstudentAnswer[len(matchnumber(studentAnswer,['plain','en'])[0])..len(studentAnswer)]\n\ninterpreted_unit:\nif(trim(student_unit)='\u00b0','deg',student_unit)\n\ninterpreted_answer:\nqty(mod(student_scalar,360),'deg')\n\nclose:\nwithintolerance(student_scalar, correct_scalar,decimal(settings['close_tol']))\n\ncorrect_scalar:\nmod(scalar(settings['expected_answer']),360)\n\nright:\nwithintolerance(student_scalar, correct_scalar, decimal(settings['right_tol']))\n\ngood_unit:\nsame(qty(1,interpreted_unit),qty(1,'deg'))\n\nmark:\nassert(close,incorrect('Incorrect.');end());\nif(right,correct('Correct angle.'), set_credit(1 - settings['close_penalty'],'Angle is close.'));\nassert(good_unit,sub_credit(settings['unit_penalty'], 'Missing or incorrect units.'))", "marking_notes": [{"name": "original_student_scalar", "description": "<p>Retuns the scalar part of students answer (which is a quantity) as a number.</p>", "definition": "matchnumber(studentAnswer,['plain','en'])[1]"}, {"name": "student_scalar", "description": "<p>Normalize angle with mod 360</p>", "definition": "mod(original_student_scalar,360)\n"}, {"name": "student_unit", "description": "<p>matchnumber(studentAnswer,['plain','en'])[0] is a string \"12.34\"</p>", "definition": "studentAnswer[len(matchnumber(studentAnswer,['plain','en'])[0])..len(studentAnswer)]"}, {"name": "interpreted_unit", "description": "<p>Allows student to use degree symbol or 'deg' for units.</p>", "definition": "if(trim(student_unit)='\u00b0','deg',student_unit)"}, {"name": "interpreted_answer", "description": "A value representing the student's answer to this part.", "definition": "qty(mod(student_scalar,360),'deg')"}, {"name": "close", "description": "", "definition": "withintolerance(student_scalar, correct_scalar,decimal(settings['close_tol']))"}, {"name": "correct_scalar", "description": "<p>Normalize expected_answer with mod 360</p>", "definition": "mod(scalar(settings['expected_answer']),360)"}, {"name": "right", "description": "", "definition": "withintolerance(student_scalar, correct_scalar, decimal(settings['right_tol']))"}, {"name": "good_unit", "description": "", "definition": "same(qty(1,interpreted_unit),qty(1,'deg'))"}, {"name": "mark", "description": "This is the main marking note. It should award credit and provide feedback based on the student's answer.", "definition": "assert(close,incorrect('Incorrect.');end());\nif(right,correct('Correct angle.'), set_credit(1 - settings['close_penalty'],'Angle is close.'));\nassert(good_unit,sub_credit(settings['unit_penalty'], 'Missing or incorrect units.'))"}], "settings": [{"name": "expected_answer", "label": "Expected Answer", "help_url": "", "hint": "Expected angle as a quantity.", "input_type": "code", "default_value": "qty(30,'deg')", "evaluate": true}, {"name": "unit_penalty", "label": "Unit penalty", "help_url": "", "hint": "Penalty for not including degree sign or 'deg'.", "input_type": "percent", "default_value": "20"}, {"name": "close_penalty", "label": "Close Penalty", "help_url": "", "hint": "Penalty for close answer.", "input_type": "percent", "default_value": "20"}, {"name": "close_tol", "label": "Close", "help_url": "", "hint": "Angle must be $\\pm$ this many degrees to be marked close. &nbsp;&nbsp;", "input_type": "code", "default_value": "0.5", "evaluate": false}, {"name": "right_tol", "label": "Right ", "help_url": "", "hint": "Angle must be $\\pm$ this many degrees to be marked correct. &nbsp;", "input_type": "code", "default_value": "0.1", "evaluate": false}], "public_availability": "restricted", "published": false, "extensions": ["quantities"]}, {"source": {"pk": 19, "author": {"name": "William Haynes", "pk": 2530}, "edit_page": "/part_type/19/edit"}, "name": "Engineering Accuracy with units", "short_name": "engineering-answer", "description": "<p>A value with units marked right if within an adjustable % error of the correct value. &nbsp;Marked close if within a wider margin of error.</p>", "help_url": "", "input_widget": "string", "input_options": {"correctAnswer": "siground(settings['correctAnswer'],4)", "hint": {"static": true, "value": ""}, "allowEmpty": {"static": true, "value": true}}, "can_be_gap": true, "can_be_step": true, "marking_script": "mark:\nswitch( \n  right and good_units and right_sign, add_credit(1.0,'Correct.'),\n  right and good_units and not right_sign, add_credit(settings['C2'],'Wrong sign.'),\n  right and right_sign and not good_units, add_credit(settings['C2'],'Correct value, but wrong or missing units.'),\n  close and good_units, add_credit(settings['C1'],'Close.'),\n  close and not good_units, add_credit(settings['C3'],'Answer is close, but wrong or missing units.'),\n  incorrect('Wrong answer.')\n)\n\n\ninterpreted_answer:\nqty(student_scalar, student_units)\n\n\n\ncorrect_quantity:\nsettings[\"correctAnswer\"]\n\n\n\ncorrect_units:\nunits(correct_quantity)\n\n\nallowed_notation_styles:\n[\"plain\",\"en\"]\n\nmatch_student_number:\nmatchnumber(studentAnswer,allowed_notation_styles)\n\nstudent_scalar:\nmatch_student_number[1]\n\nstudent_units:\nreplace_regex('ohms','ohm',\n  replace_regex('\u00b0', ' deg',\n    replace_regex('-', ' ' ,\n      studentAnswer[len(match_student_number[0])..len(studentAnswer)])),\"i\")\n\ngood_units:\ntry(\ncompatible(quantity(1, student_units),correct_units),\nmsg,\nfeedback(msg);false)\n\n\nstudent_quantity:\nswitch(not good_units, \n       student_scalar * correct_units, \n       not right_sign,\n       -quantity(student_scalar, student_units),\n       quantity(student_scalar,student_units)\n)\n  \n\n\npercent_error:\ntry(\nscalar(abs((correct_quantity - student_quantity)/correct_quantity))*100  \n,msg,\nif(student_quantity=correct_quantity,0,100))\n   \n\nright:\npercent_error <= settings['right']\n\n\nclose:\nright_sign and percent_error <= settings['close']\n\nright_sign:\nsign(student_scalar) = sign(correct_quantity)", "marking_notes": [{"name": "mark", "description": "This is the main marking note. It should award credit and provide feedback based on the student's answer.", "definition": "switch( \n  right and good_units and right_sign, add_credit(1.0,'Correct.'),\n  right and good_units and not right_sign, add_credit(settings['C2'],'Wrong sign.'),\n  right and right_sign and not good_units, add_credit(settings['C2'],'Correct value, but wrong or missing units.'),\n  close and good_units, add_credit(settings['C1'],'Close.'),\n  close and not good_units, add_credit(settings['C3'],'Answer is close, but wrong or missing units.'),\n  incorrect('Wrong answer.')\n)\n"}, {"name": "interpreted_answer", "description": "A value representing the student's answer to this part.", "definition": "qty(student_scalar, student_units)\n\n"}, {"name": "correct_quantity", "description": "", "definition": "settings[\"correctAnswer\"]\n\n"}, {"name": "correct_units", "description": "", "definition": "units(correct_quantity)\n"}, {"name": "allowed_notation_styles", "description": "", "definition": "[\"plain\",\"en\"]"}, {"name": "match_student_number", "description": "", "definition": "matchnumber(studentAnswer,allowed_notation_styles)"}, {"name": "student_scalar", "description": "", "definition": "match_student_number[1]"}, {"name": "student_units", "description": "<p>Modify&nbsp;the&nbsp;unit portion of&nbsp;the student's answer by</p>\n<p>1. replacing \"ohms\" with \"ohm\" &nbsp;case insensitive</p>\n<p>2.&nbsp;replacing '-'&nbsp;with ' '&nbsp;</p>\n<p>3. replacing '&deg;' with ' deg'&nbsp;</p>\n<p>to allow answers like 10 ft-lb and 30&deg;</p>", "definition": "replace_regex('ohms','ohm',\n  replace_regex('\u00b0', ' deg',\n    replace_regex('-', ' ' ,\n      studentAnswer[len(match_student_number[0])..len(studentAnswer)])),\"i\")"}, {"name": "good_units", "description": "", "definition": "try(\ncompatible(quantity(1, student_units),correct_units),\nmsg,\nfeedback(msg);false)\n"}, {"name": "student_quantity", "description": "<p>This fixes the student answer for two common errors. &nbsp;</p>\n<p>If student_units are wrong&nbsp;&nbsp;- replace with correct units</p>\n<p>If student_scalar has the wrong sign - replace with right sign</p>\n<p>If student makes both errors, only one gets fixed.</p>", "definition": "switch(not good_units, \n       student_scalar * correct_units, \n       not right_sign,\n       -quantity(student_scalar, student_units),\n       quantity(student_scalar,student_units)\n)\n  \n"}, {"name": "percent_error", "description": "", "definition": "try(\nscalar(abs((correct_quantity - student_quantity)/correct_quantity))*100  \n,msg,\nif(student_quantity=correct_quantity,0,100))\n   "}, {"name": "right", "description": "", "definition": "percent_error <= settings['right']\n"}, {"name": "close", "description": "<p>Only marked close if the student actually has the right sign.</p>", "definition": "right_sign and percent_error <= settings['close']"}, {"name": "right_sign", "description": "", "definition": "sign(student_scalar) = sign(correct_quantity) "}], "settings": [{"name": "correctAnswer", "label": "Correct Quantity.", "help_url": "", "hint": "The correct answer given as a JME quantity.", "input_type": "code", "default_value": "", "evaluate": true}, {"name": "right", "label": "% Accuracy for right.", "help_url": "", "hint": "Question will be considered correct if the scalar part of the student's answer is within this % of correct value.", "input_type": "code", "default_value": "0.2", "evaluate": true}, {"name": "close", "label": "% Accuracy for close.", "help_url": "", "hint": "Question will be considered close if the scalar part of the student's answer is within this % of correct value.", "input_type": "code", "default_value": "1.0", "evaluate": true}, {"name": "C1", "label": "Close with units.", "help_url": "", "hint": "Partial Credit for close value with appropriate units. &nbsp;if correct answer is 100 N and close is &plusmn;1%,<br />99 &nbsp;N is accepted.", "input_type": "percent", "default_value": "75"}, {"name": "C2", "label": "No units or wrong sign", "help_url": "", "hint": "Partial credit for forgetting units or using wrong sign.<br />If the correct answer is 100 N, both 100 and -100 N are accepted.", "input_type": "percent", "default_value": "50"}, {"name": "C3", "label": "Close, no units.", "help_url": "", "hint": "Partial Credit for close value but forgotten units.<br />This value would be close&nbsp;if the expected units were provided. &nbsp;If the correct answer is 100 N, and close is &plusmn;1%,<br />99 is accepted.", "input_type": "percent", "default_value": "25"}], "public_availability": "always", "published": true, "extensions": ["quantities"]}], "resources": [], "navigation": {"allowregen": true, "showfrontpage": false, "preventleave": false, "typeendtoleave": false}, "contributors": [{"name": "William Haynes", "profile_url": "https://numbas.mathcentre.ac.uk/accounts/profile/2530/"}], "tags": ["angle from reference", "Equilibrium", "equilibrium", "Mechanics", "mechanics", "reactions", "Rigid Body", "rigid body", "Statics", "statics"], "metadata": {"description": "<p>Find the reactions of a rigid body (a truss) at a pin and roller. &nbsp;All loads are either horizontal or vertical.</p>", "licence": "Creative Commons Attribution-NonCommercial 4.0 International"}, "statement": "<p>{applet}</p>\n<p>The truss shown consists of three sections {b} {units[1]} wide and {h} {units[1]} tall, subjected to the loads shown.</p>\n<p>Determine the reactions at the pin and the roller.</p>\n<p><span data-jme-visible=\"debug\">D: {siground(D,3)} {units[0]}</span></p>\n<p><span data-jme-visible=\"debug\">A: &nbsp;{siground(magA,3)}&nbsp;{units[0]} at {siground(dirA,4)}&deg; from the x-axis&nbsp;</span></p>\n<p><span data-jme-visible=\"debug\"><span class=\"Apple-tab-span\"></span>Ax: {Ax} &nbsp;Ay: {Ay}&nbsp;</span></p>", "advice": "<ol>\n<li>Draw a free body diagram.</li>\n<li>Apply $\\Sigma M_A$ = 0 to find the reaction at $D$. &nbsp;There's no <em>x</em>-component at $D$, because the support there is a roller. &nbsp;This should have been indicated on your free body diagram.</li>\n<li>Once force $D$ and the loads are known, apply $\\Sigma F_x = 0$ and $\\Sigma F_y=0$ to find components $A_x$ and $A_y$.</li>\n<li>With $A_x$ and $A_y$ known, use the pythagorean theorem to calculate the magnitude of force $A$, and use trig to get the its direction.</li>\n</ol>", "rulesets": {}, "builtin_constants": {"e": true, "pi,\u03c0": true, "i": true}, "constants": [], "variables": {"Ay": {"name": "Ay", "group": "Ungrouped variables", "definition": "Fe + Ff - D", "description": "<p>x-component of reaction at A. &nbsp;up is positive</p>", "templateType": "anything", "can_override": false}, "FC": {"name": "FC", "group": "inputs", "definition": "random(0..5)", "description": "", "templateType": "anything", "can_override": false}, "dirA": {"name": "dirA", "group": "Ungrouped variables", "definition": "mod(degrees(atan2(Ay,Ax)),360)", "description": "", "templateType": "anything", "can_override": false}, "A": {"name": "A", "group": "Ungrouped variables", "definition": "vector(Ax,Ay)", "description": "", "templateType": "anything", "can_override": false}, "FB": {"name": "FB", "group": "inputs", "definition": "random(0..5)", "description": "", "templateType": "anything", "can_override": false}, "magA": {"name": "magA", "group": "Ungrouped variables", "definition": "abs(A)", "description": "<p>magnitude of A</p>", "templateType": "anything", "can_override": false}, "D": {"name": "D", "group": "Ungrouped variables", "definition": "(Fb * h + Fc * h + Ff * b + Fe * 2 * b)/(3*b)", "description": "<p>Reaction at D. &nbsp;Up is positive</p>", "templateType": "anything", "can_override": false}, "FF": {"name": "FF", "group": "inputs", "definition": "random(0..5)", "description": "", "templateType": "anything", "can_override": false}, "Ax": {"name": "Ax", "group": "Ungrouped variables", "definition": "-(Fb+Fc)", "description": "<p>x- component of reaction at A. positive is to the right</p>", "templateType": "anything", "can_override": false}, "b": {"name": "b", "group": "inputs", "definition": "random(2..4#0.4)", "description": "", "templateType": "anything", "can_override": false}, "h": {"name": "h", "group": "inputs", "definition": "random(2..4#0.2)", "description": "", "templateType": "anything", "can_override": false}, "units": {"name": "units", "group": "inputs", "definition": "['kN','m']", "description": "", "templateType": "anything", "can_override": false}, "FE": {"name": "FE", "group": "inputs", "definition": "random(0..5)", "description": "", "templateType": "anything", "can_override": false}, "debug": {"name": "debug", "group": "GGB", "definition": "false", "description": "", "templateType": "anything", "can_override": false}, "params": {"name": "params", "group": "GGB", "definition": "[\nb: b, h: h,\nF_F: FF, F_E: FE, F_C: FC, F_B: FB,\nunitsF: '\"{units[0]}\"',\nunitsD: '\"{units[1]}\"',\nR_A: [visible: debug], R_D: [visible: debug]\n]", "description": "", "templateType": "anything", "can_override": false}, "applet": {"name": "applet", "group": "GGB", "definition": "geogebra_applet('xqsbgp9c',params)", "description": "", "templateType": "anything", "can_override": false}}, "variablesTest": {"condition": "len(filter(x>0,x,[Fb,Fc,Fe,Ff]))>1", "maxRuns": 100}, "ungrouped_variables": ["D", "dirA", "Ay", "Ax", "A", "magA"], "variable_groups": [{"name": "inputs", "variables": ["h", "b", "FB", "FC", "FF", "FE", "units"]}, {"name": "GGB", "variables": ["params", "applet", "debug"]}], "functions": {}, "preamble": {"js": "", "css": ""}, "parts": [{"type": "gapfill", "useCustomName": true, "customName": "Reactions at D", "marks": 0, "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": true, "showFeedbackIcon": true, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "prompt": "<p>Use $\\Sigma M_A = 0$ to find the vector components of $\\textbf{D}$.&nbsp;</p>\n<p>$\\textbf{D}_x = $&nbsp;[[0]]&nbsp;&nbsp;[[1]]&nbsp;&nbsp;$\\qquad \\textbf{D}_y = $&nbsp;[[2]]&nbsp;&nbsp;[[3]]&nbsp;</p>", "gaps": [{"type": "engineering-answer", "useCustomName": true, "customName": "Dx Magnitude", "marks": "9", "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": true, "showFeedbackIcon": true, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "settings": {"correctAnswer": "qty(0,units[0])", "right": "0.2", "close": "1.0", "C1": "75", "C2": "50", "C3": "25"}}, {"type": "1_n_2", "useCustomName": true, "customName": "Dx Direction", "marks": 0, "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": true, "showFeedbackIcon": true, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "minMarks": 0, "maxMarks": 0, "shuffleChoices": false, "displayType": "dropdownlist", "displayColumns": 0, "showCellAnswerState": true, "choices": ["&rarr; (right)", "&larr; (left)", "Neither"], "matrix": [0, 0, "1"], "distractors": ["", "", ""]}, {"type": "engineering-answer", "useCustomName": true, "customName": "Dy Magnitude", "marks": "9", "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": true, "showFeedbackIcon": true, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "alternatives": [{"type": "engineering-answer", "useCustomName": false, "customName": "", "marks": 0, "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "alternativeFeedbackMessage": "", "useAlternativeFeedback": false, "settings": {"correctAnswer": "qty(abs(D),units[0])", "right": "0.2", "close": "1.0", "C1": "75", "C2": "50", "C3": "25"}}], "settings": {"correctAnswer": "qty(abs(D),units[0])", "right": "0.2", "close": "1.0", "C1": "75", "C2": "50", "C3": "25"}}, {"type": "1_n_2", "useCustomName": true, "customName": "Dy Direction", "marks": 0, "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": true, "showFeedbackIcon": true, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "minMarks": 0, "maxMarks": 0, "shuffleChoices": false, "displayType": "dropdownlist", "displayColumns": 0, "showCellAnswerState": true, "choices": ["&uarr; (up)", "&darr; (down)", "Neither"], "matrix": ["if(D>0,1,0)", "if(D<0,1,0)", "If(D=0,1,0)"], "distractors": ["", "", ""]}], "sortAnswers": false}, {"type": "gapfill", "useCustomName": true, "customName": "Reactions at A", "marks": 0, "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": true, "showFeedbackIcon": true, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "prompt": "<p>Use $\\Sigma F_x = 0$ and $\\Sigma F_y=0$ to find the vector&nbsp;components of the reaction at $\\textbf{A}$.</p>\n<p></p>\n<p>$\\textbf{A}_x = $&nbsp;[[0]]&nbsp;&nbsp;[[1]]&nbsp;&nbsp;$\\qquad \\textbf{A}_y = $&nbsp;[[2]]&nbsp;&nbsp;[[3]]&nbsp;</p>", "gaps": [{"type": "engineering-answer", "useCustomName": true, "customName": "Ax Magnitude", "marks": "9", "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": true, "showFeedbackIcon": true, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "settings": {"correctAnswer": "qty(abs(Ax),units[0])", "right": "0.2", "close": "1.0", "C1": "75", "C2": "50", "C3": "25"}}, {"type": "1_n_2", "useCustomName": true, "customName": "Ax Direction", "marks": 0, "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": false, "showFeedbackIcon": true, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "minMarks": 0, "maxMarks": 0, "shuffleChoices": false, "displayType": "dropdownlist", "displayColumns": 0, "showCellAnswerState": true, "choices": ["&rarr; (right)", "&larr; (left)", "Neither"], "matrix": "[if(sign(Ax) >= 0,1,0), if(sign(Ax) <=0,1,0), if(sign(Ax)=0,1,0)]"}, {"type": "engineering-answer", "useCustomName": true, "customName": "Ay Magnitude", "marks": "9", "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": false, "showFeedbackIcon": true, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "settings": {"correctAnswer": "qty(precround(abs(Ay),6),units[0])", "right": "0.2", "close": "1.0", "C1": "75", "C2": "50", "C3": "25"}}, {"type": "1_n_2", "useCustomName": true, "customName": "Ay Direction", "marks": 0, "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": false, "showFeedbackIcon": true, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "minMarks": 0, "maxMarks": 0, "shuffleChoices": false, "displayType": "dropdownlist", "displayColumns": 0, "showCellAnswerState": true, "choices": ["&uarr; (up)", "&darr; (down)", "Neither"], "matrix": "[if(sign(Ay) >= 0,1,0), if(sign(Ay) <=0,1,0), if(sign(Ay)=0,1,0)]"}], "sortAnswers": false}, {"type": "gapfill", "useCustomName": true, "customName": "Resultant at A", "marks": 0, "scripts": {}, "customMarkingAlgorithm": "interpreted_angle:  // a qty string corrected to standard angle\n  student_angle[2]  + student_angle[1] * student_angle[0] + student_units\n\nmagnitude:\n  studentAnswer[3]\n\nstudent_angle:\n  [mod(matchnumber(studentAnswer[0],['plain','en'])[1],360), // angle\n  [1,-1][indices(studentAnswer[1],[true])[0]],      // ccw = 1 cw = -1\n  [0,90,180,-90][indices(studentAnswer[2],[true])[0]]] // reference axis\n\nstudent_units:\n  studentAnswer[0][len(matchnumber(studentAnswer[0],['plain','en'])[0])..len(studentAnswer[0])]\n\ninterpreted_answers:\n  [interpreted_angle, studentAnswer[1], studentAnswer[2], studentAnswer[3]]\n\ngap_feedback (Feedback on each of the gaps):\n    map(\n        try(\n            let(\n                result, submit_part(gaps[gap_number][\"path\"],answer),\n                gap, gaps[gap_number],\n                name, gap[\"name\"],  \n                noFeedbackIcon, not gap[\"settings\"][\"showFeedbackIcon\"],\n                assert(name=\"\" or len(gaps)=1,feedback(translate('part.gapfill.feedback header',[\"name\": name])));\n                concat_feedback(filter(x[\"op\"]<>\"warning\",x,result[\"feedback\"]), if(marks>0,result[\"marks\"]/marks,1), noFeedbackIcon);\n                    result\n            ),\n            err,\n            fail(translate(\"part.gapfill.error marking gap\",[\"name\": gaps[gap_number][\"name\"], \"message\": err]))\n        ),\n        [gap_number,answer,index],\n        zip([3,0],[studentAnswer[3], interpreted_angle],[1,2])\n    )\n\n", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": true, "showFeedbackIcon": true, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "prompt": "<p>Determine the magnitude and direction of the resultant force $\\textbf{A}$ by resolving&nbsp;$\\textbf{A}_x$ and&nbsp;&nbsp;$\\textbf{A}_y$.</p>\n<p>Force $\\textbf{A}$ has a magnitude of&nbsp;[[3]],</p>\n<p>acting at an angle of&nbsp;[[0]] measured&nbsp;&nbsp;[[1]]&nbsp;from the [[2]].&nbsp;</p>\n<p></p>", "gaps": [{"type": "angle", "useCustomName": true, "customName": "angle", "marks": "10", "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": true, "showFeedbackIcon": false, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "settings": {"expected_answer": "qty(siground(dirA,5),'deg')", "unit_penalty": "20", "close_penalty": "20", "close_tol": "0.5", "right_tol": "0.2"}}, {"type": "1_n_2", "useCustomName": true, "customName": "sign", "marks": 0, "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": false, "showFeedbackIcon": false, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "minMarks": 0, "maxMarks": 0, "shuffleChoices": false, "displayType": "dropdownlist", "displayColumns": 0, "showCellAnswerState": true, "choices": ["CCW", "CW"], "matrix": [0, 0], "distractors": ["", ""]}, {"type": "1_n_2", "useCustomName": true, "customName": "ref", "marks": 0, "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": false, "showFeedbackIcon": true, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "minMarks": 0, "maxMarks": 0, "shuffleChoices": false, "displayType": "dropdownlist", "displayColumns": 0, "showCellAnswerState": true, "choices": ["+x axis", "+y axis", "-x axis", "-y axis"], "matrix": [0, 0, 0, 0], "distractors": ["", "", "", ""]}, {"type": "engineering-answer", "useCustomName": true, "customName": "magA", "marks": "10", "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": true, "showFeedbackIcon": true, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "settings": {"correctAnswer": "qty(siground(magA,5),units[0])", "right": "0.2", "close": "1.0", "C1": "75", "C2": "50", "C3": "25"}}], "sortAnswers": false}], "partsMode": "all", "maxMarks": 0, "objectives": [], "penalties": [], "objectiveVisibility": "always", "penaltyVisibility": "always"}]}, {"name": "Three-force Body Method", "pickingStrategy": "all-ordered", "pickQuestions": 1, "questionNames": ["Triangle", " Beam with angled load"], "variable_overrides": [[], []], "questions": [{"name": "Three-force body method: triangle", "extensions": ["geogebra", "quantities"], "custom_part_types": [{"source": {"pk": 24, "author": {"name": "William Haynes", "pk": 2530}, "edit_page": "/part_type/24/edit"}, "name": "Angle quantity", "short_name": "angle-quantity-from-reference", "description": "<p>Angle&nbsp;as a quantity in degrees.</p>", "help_url": "", "input_widget": "string", "input_options": {"correctAnswer": "plain_string(settings['correct_quantity'])", "hint": {"static": true, "value": ""}, "allowEmpty": {"static": true, "value": false}}, "can_be_gap": true, "can_be_step": true, "marking_script": "mark:\nswitch( \nright and good_units and right_sign and angle_in_range, add_credit(1.0,'Correct.'),\nright and good_units and not right_sign, add_credit(settings['C2'],'Wrong sign.'),\nright and right_sign and not good_units, add_credit(settings['C2'],'Correct value, but missing degree symbol.'),\nright and good_units and right_sign and not angle_in_range,add_credit(settings['C1'],'Angle is out of range.'),\nclose and good_units, add_credit(settings['C1'],'Close.'),\nclose and not good_units, add_credit(settings['C3'],'Answer is close, but missing degree symbol.'),\nincorrect('Wrong answer.')\n)\n\ninterpreted_answer:\nqty(student_scalar, student_units)\n\ncorrect_scalar:\nscalar(correct_quantity)\n  \n\ncorrect_quantity:\nsettings['correct_quantity']\n\ncorrect_units:\nunits(correct_quantity)\n\nallowed_notation_styles:\n[\"plain\",\"en\"]\n\nmatch_student_number:\nmatchnumber(studentAnswer,allowed_notation_styles)\n\nstudent_scalar:\nmatch_student_number[1]\n\nstudent_units:\njoin(\nsplit(studentAnswer[len(match_student_number[0])..len(studentAnswer)]\n,\"\u00b0\"),\" deg\")\n\n\n\ngood_units:\ntry(\ncompatible(quantity(1, student_units),correct_quantity),\nmsg,\nfeedback(msg);false)\n\nstudent_quantity:\nswitch(not good_units, \nstudent_scalar * correct_units, \nnot right_sign,\n-quantity(student_scalar, student_units),\nquantity(student_scalar,student_units)\n)\n\nright_sign:\nsign(student_scalar) = sign(correct_quantity)\n\nangle_in_range:\nif(settings['restrict_angle'], abs(student_scalar) <= 90, true)\n\nright:\nwithinTolerance(abs(student_scalar), abs(correct_scalar), settings['right'])\n\nclose:\nwithinTolerance(student_scalar, correct_scalar, settings['close'])", "marking_notes": [{"name": "mark", "description": "This is the main marking note. It should award credit and provide feedback based on the student's answer.", "definition": "switch( \nright and good_units and right_sign and angle_in_range, add_credit(1.0,'Correct.'),\nright and good_units and not right_sign, add_credit(settings['C2'],'Wrong sign.'),\nright and right_sign and not good_units, add_credit(settings['C2'],'Correct value, but missing degree symbol.'),\nright and good_units and right_sign and not angle_in_range,add_credit(settings['C1'],'Angle is out of range.'),\nclose and good_units, add_credit(settings['C1'],'Close.'),\nclose and not good_units, add_credit(settings['C3'],'Answer is close, but missing degree symbol.'),\nincorrect('Wrong answer.')\n)"}, {"name": "interpreted_answer", "description": "A value representing the student's answer to this part.", "definition": "qty(student_scalar, student_units)"}, {"name": "correct_scalar", "description": "", "definition": "scalar(correct_quantity)\n  "}, {"name": "correct_quantity", "description": "", "definition": "settings['correct_quantity']"}, {"name": "correct_units", "description": "", "definition": "units(correct_quantity)"}, {"name": "allowed_notation_styles", "description": "", "definition": "[\"plain\",\"en\"]"}, {"name": "match_student_number", "description": "", "definition": "matchnumber(studentAnswer,allowed_notation_styles)"}, {"name": "student_scalar", "description": "", "definition": "match_student_number[1]"}, {"name": "student_units", "description": "", "definition": "join(\nsplit(studentAnswer[len(match_student_number[0])..len(studentAnswer)]\n,\"\u00b0\"),\" deg\")\n\n"}, {"name": "good_units", "description": "", "definition": "try(\ncompatible(quantity(1, student_units),correct_quantity),\nmsg,\nfeedback(msg);false)"}, {"name": "student_quantity", "description": "", "definition": "switch(not good_units, \nstudent_scalar * correct_units, \nnot right_sign,\n-quantity(student_scalar, student_units),\nquantity(student_scalar,student_units)\n)"}, {"name": "right_sign", "description": "", "definition": "sign(student_scalar) = sign(correct_quantity)"}, {"name": "angle_in_range", "description": "", "definition": "if(settings['restrict_angle'], abs(student_scalar) <= 90, true)"}, {"name": "right", "description": "<p>Will check for correct sign elswhere.</p>", "definition": "withinTolerance(abs(student_scalar), abs(correct_scalar), settings['right'])"}, {"name": "close", "description": "<p>Must have correct sign to be close.</p>", "definition": "withinTolerance(student_scalar, correct_scalar, settings['close'])\n"}], "settings": [{"name": "correct_quantity", "label": "Correct Angle as quantity ", "help_url": "", "hint": "", "input_type": "code", "default_value": "qty(45,'deg')", "evaluate": true}, {"name": "right", "label": "Accuracy for right.", "help_url": "", "hint": "Question will be considered correct if the scalar part of the student's answer is within &plusmn; this amount from the correct value.", "input_type": "code", "default_value": "0.1", "evaluate": true}, {"name": "restrict_angle", "label": "Less than 90\u00b0", "help_url": "", "hint": "When checked, angle must be between -90&deg; and +90&deg;.", "input_type": "checkbox", "default_value": true}, {"name": "C1", "label": "Close with units.", "help_url": "", "hint": "Partial Credit for close value with appropriate units.", "input_type": "percent", "default_value": "75"}, {"name": "close", "label": " Accuracy for close.", "help_url": "", "hint": "Question will be considered close if the scalar part of the student's answer is within &plusmn; this amount from the correct value.", "input_type": "code", "default_value": "0.5", "evaluate": true}, {"name": "C2", "label": "No units or wrong sign", "help_url": "", "hint": "Partial credit for forgetting units or using wrong sign.", "input_type": "percent", "default_value": "50"}, {"name": "C3", "label": "Close, no units.", "help_url": "", "hint": "Partial Credit for close value without units.", "input_type": "percent", "default_value": "25"}], "public_availability": "restricted", "published": false, "extensions": ["quantities"]}, {"source": {"pk": 19, "author": {"name": "William Haynes", "pk": 2530}, "edit_page": "/part_type/19/edit"}, "name": "Engineering Accuracy with units", "short_name": "engineering-answer", "description": "<p>A value with units marked right if within an adjustable % error of the correct value. &nbsp;Marked close if within a wider margin of error.</p>", "help_url": "", "input_widget": "string", "input_options": {"correctAnswer": "siground(settings['correctAnswer'],4)", "hint": {"static": true, "value": ""}, "allowEmpty": {"static": true, "value": true}}, "can_be_gap": true, "can_be_step": true, "marking_script": "mark:\nswitch( \n  right and good_units and right_sign, add_credit(1.0,'Correct.'),\n  right and good_units and not right_sign, add_credit(settings['C2'],'Wrong sign.'),\n  right and right_sign and not good_units, add_credit(settings['C2'],'Correct value, but wrong or missing units.'),\n  close and good_units, add_credit(settings['C1'],'Close.'),\n  close and not good_units, add_credit(settings['C3'],'Answer is close, but wrong or missing units.'),\n  incorrect('Wrong answer.')\n)\n\n\ninterpreted_answer:\nqty(student_scalar, student_units)\n\n\n\ncorrect_quantity:\nsettings[\"correctAnswer\"]\n\n\n\ncorrect_units:\nunits(correct_quantity)\n\n\nallowed_notation_styles:\n[\"plain\",\"en\"]\n\nmatch_student_number:\nmatchnumber(studentAnswer,allowed_notation_styles)\n\nstudent_scalar:\nmatch_student_number[1]\n\nstudent_units:\nreplace_regex('ohms','ohm',\n  replace_regex('\u00b0', ' deg',\n    replace_regex('-', ' ' ,\n      studentAnswer[len(match_student_number[0])..len(studentAnswer)])),\"i\")\n\ngood_units:\ntry(\ncompatible(quantity(1, student_units),correct_units),\nmsg,\nfeedback(msg);false)\n\n\nstudent_quantity:\nswitch(not good_units, \n       student_scalar * correct_units, \n       not right_sign,\n       -quantity(student_scalar, student_units),\n       quantity(student_scalar,student_units)\n)\n  \n\n\npercent_error:\ntry(\nscalar(abs((correct_quantity - student_quantity)/correct_quantity))*100  \n,msg,\nif(student_quantity=correct_quantity,0,100))\n   \n\nright:\npercent_error <= settings['right']\n\n\nclose:\nright_sign and percent_error <= settings['close']\n\nright_sign:\nsign(student_scalar) = sign(correct_quantity)", "marking_notes": [{"name": "mark", "description": "This is the main marking note. It should award credit and provide feedback based on the student's answer.", "definition": "switch( \n  right and good_units and right_sign, add_credit(1.0,'Correct.'),\n  right and good_units and not right_sign, add_credit(settings['C2'],'Wrong sign.'),\n  right and right_sign and not good_units, add_credit(settings['C2'],'Correct value, but wrong or missing units.'),\n  close and good_units, add_credit(settings['C1'],'Close.'),\n  close and not good_units, add_credit(settings['C3'],'Answer is close, but wrong or missing units.'),\n  incorrect('Wrong answer.')\n)\n"}, {"name": "interpreted_answer", "description": "A value representing the student's answer to this part.", "definition": "qty(student_scalar, student_units)\n\n"}, {"name": "correct_quantity", "description": "", "definition": "settings[\"correctAnswer\"]\n\n"}, {"name": "correct_units", "description": "", "definition": "units(correct_quantity)\n"}, {"name": "allowed_notation_styles", "description": "", "definition": "[\"plain\",\"en\"]"}, {"name": "match_student_number", "description": "", "definition": "matchnumber(studentAnswer,allowed_notation_styles)"}, {"name": "student_scalar", "description": "", "definition": "match_student_number[1]"}, {"name": "student_units", "description": "<p>Modify&nbsp;the&nbsp;unit portion of&nbsp;the student's answer by</p>\n<p>1. replacing \"ohms\" with \"ohm\" &nbsp;case insensitive</p>\n<p>2.&nbsp;replacing '-'&nbsp;with ' '&nbsp;</p>\n<p>3. replacing '&deg;' with ' deg'&nbsp;</p>\n<p>to allow answers like 10 ft-lb and 30&deg;</p>", "definition": "replace_regex('ohms','ohm',\n  replace_regex('\u00b0', ' deg',\n    replace_regex('-', ' ' ,\n      studentAnswer[len(match_student_number[0])..len(studentAnswer)])),\"i\")"}, {"name": "good_units", "description": "", "definition": "try(\ncompatible(quantity(1, student_units),correct_units),\nmsg,\nfeedback(msg);false)\n"}, {"name": "student_quantity", "description": "<p>This fixes the student answer for two common errors. &nbsp;</p>\n<p>If student_units are wrong&nbsp;&nbsp;- replace with correct units</p>\n<p>If student_scalar has the wrong sign - replace with right sign</p>\n<p>If student makes both errors, only one gets fixed.</p>", "definition": "switch(not good_units, \n       student_scalar * correct_units, \n       not right_sign,\n       -quantity(student_scalar, student_units),\n       quantity(student_scalar,student_units)\n)\n  \n"}, {"name": "percent_error", "description": "", "definition": "try(\nscalar(abs((correct_quantity - student_quantity)/correct_quantity))*100  \n,msg,\nif(student_quantity=correct_quantity,0,100))\n   "}, {"name": "right", "description": "", "definition": "percent_error <= settings['right']\n"}, {"name": "close", "description": "<p>Only marked close if the student actually has the right sign.</p>", "definition": "right_sign and percent_error <= settings['close']"}, {"name": "right_sign", "description": "", "definition": "sign(student_scalar) = sign(correct_quantity) "}], "settings": [{"name": "correctAnswer", "label": "Correct Quantity.", "help_url": "", "hint": "The correct answer given as a JME quantity.", "input_type": "code", "default_value": "", "evaluate": true}, {"name": "right", "label": "% Accuracy for right.", "help_url": "", "hint": "Question will be considered correct if the scalar part of the student's answer is within this % of correct value.", "input_type": "code", "default_value": "0.2", "evaluate": true}, {"name": "close", "label": "% Accuracy for close.", "help_url": "", "hint": "Question will be considered close if the scalar part of the student's answer is within this % of correct value.", "input_type": "code", "default_value": "1.0", "evaluate": true}, {"name": "C1", "label": "Close with units.", "help_url": "", "hint": "Partial Credit for close value with appropriate units. &nbsp;if correct answer is 100 N and close is &plusmn;1%,<br />99 &nbsp;N is accepted.", "input_type": "percent", "default_value": "75"}, {"name": "C2", "label": "No units or wrong sign", "help_url": "", "hint": "Partial credit for forgetting units or using wrong sign.<br />If the correct answer is 100 N, both 100 and -100 N are accepted.", "input_type": "percent", "default_value": "50"}, {"name": "C3", "label": "Close, no units.", "help_url": "", "hint": "Partial Credit for close value but forgotten units.<br />This value would be close&nbsp;if the expected units were provided. &nbsp;If the correct answer is 100 N, and close is &plusmn;1%,<br />99 is accepted.", "input_type": "percent", "default_value": "25"}], "public_availability": "always", "published": true, "extensions": ["quantities"]}], "resources": [], "navigation": {"allowregen": true, "showfrontpage": false, "preventleave": false, "typeendtoleave": false}, "contributors": [{"name": "William Haynes", "profile_url": "https://numbas.mathcentre.ac.uk/accounts/profile/2530/"}], "tags": [], "metadata": {"description": "<p>Find the reactions of a rigid body (a triangular plate) at a pin and roller, using the three-force body principle.</p>", "licence": "Creative Commons Attribution-NonCommercial 4.0 International"}, "statement": "<p>The triangular plate is secured by a pin at $A$ and a roller at $C$ <em>&nbsp;</em>and is subjected to a {FB} load acting at point $B$ as shown.</p>\n<p>Determine the reactions at the pin and the roller using the three-force body principle.&nbsp;</p>\n<p>{geogebra_applet('whu5xquv',[ 'FB':&nbsp;scalar(FB),&nbsp;'L':&nbsp;scalar(L),&nbsp;'&theta;':&nbsp;radians(theta),&nbsp;'&alpha;':&nbsp;radians(alpha1),&nbsp;'units':&nbsp;'\"'+units[1]+'\"', 'show': 'false', 'debug': 'false' ])}</p>", "advice": "<ol>\n<li>Draw a free body diagram.</li>\n<li>Apply $\\Sigma M_A=0$ to find the reaction at $C$. &nbsp;There's no $x$-component at $C$, because the support there is a roller. &nbsp;This should have been indicated on your free body diagram.</li>\n<li>Once $C$ and is&nbsp;known, apply $F_x = 0$ and $F_y=0$ to find components $A_x$ and $A_y$.</li>\n<li>With $A_x$ and $A_y$ known, use the pathagorean theorem to calculate the magnitude of $A$, and use trig to get the its direction.</li>\n</ol>", "rulesets": {}, "builtin_constants": {"e": true, "pi,\u03c0": true, "i": true}, "constants": [], "variables": {"theta": {"name": "theta", "group": "Inputs", "definition": "random(300..380#5)", "description": "<p>reference direction. &nbsp;Set by student choice.</p>", "templateType": "anything", "can_override": false}, "L": {"name": "L", "group": "Inputs", "definition": "qty(random(2..6#0.2),units[1])", "description": "", "templateType": "anything", "can_override": false}, "alpha": {"name": "alpha", "group": "Ungrouped variables", "definition": "qty(90-(360-theta),'deg')", "description": "", "templateType": "anything", "can_override": false}, "alpha1": {"name": "alpha1", "group": "Inputs", "definition": "random(25..60#5)", "description": "", "templateType": "anything", "can_override": false}, "FC": {"name": "FC", "group": "Ungrouped variables", "definition": "FB sin(scalar(gamma in 'radians'))/sin(scalar(beta in 'radians'))", "description": "", "templateType": "anything", "can_override": false}, "theta_a": {"name": "theta_a", "group": "Ungrouped variables", "definition": "qty(degrees(arctan(scalar(h/L))),'deg')", "description": "", "templateType": "anything", "can_override": false}, "units": {"name": "units", "group": "Inputs", "definition": "random([['kN','m'],['lb','ft'], ['lb','in'],['N','m']])", "description": "", "templateType": "anything", "can_override": false}, "gamma": {"name": "gamma", "group": "Ungrouped variables", "definition": "qty(180,'deg') - alpha -beta", "description": "", "templateType": "anything", "can_override": false}, "debug": {"name": "debug", "group": "Ungrouped variables", "definition": "false", "description": "", "templateType": "anything", "can_override": false}, "FA": {"name": "FA", "group": "Ungrouped variables", "definition": "FB sin(scalar(alpha in 'radians'))/sin(scalar(beta in 'radians'))", "description": "", "templateType": "anything", "can_override": false}, "FB": {"name": "FB", "group": "Inputs", "definition": "qty(random(1..15)random(10,20,50),units[0])", "description": "", "templateType": "anything", "can_override": false}, "beta": {"name": "beta", "group": "Ungrouped variables", "definition": "qty(90,'deg')- qty(degrees(arctan(scalar(h/l))),'deg')", "description": "", "templateType": "anything", "can_override": false}, "h": {"name": "h", "group": "Ungrouped variables", "definition": "l/2 ( (tan(radians(alpha1))) +  tan((radians(theta))))", "description": "<p>this is the y-coordinate of the intersection point</p>", "templateType": "anything", "can_override": false}}, "variablesTest": {"condition": "not (theta in [0,180,180+alpha1,360+alpha1,360-alpha1])", "maxRuns": 100}, "ungrouped_variables": ["debug", "h", "theta_a", "alpha", "beta", "gamma", "FA", "FC"], "variable_groups": [{"name": "Inputs", "variables": ["theta", "units", "alpha1", "FB", "L"]}], "functions": {}, "preamble": {"js": "", "css": ""}, "parts": [{"type": "gapfill", "useCustomName": true, "customName": "Height $h$", "marks": 0, "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": true, "showFeedbackIcon": true, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "prompt": "<p>A three-force body is an object acted upon by exactly three forces. &nbsp;When a three-force body is in equilibrium the lines of action of the three forces must either intersect at a common point or be parallel to each other. &nbsp;We can use this idea to find the reaction forces for&nbsp;three-force bodies.</p>\n<p>In this problem the lines of action of force $\\mathbf{B}$ and force $\\mathbf{C}$ are known and their intersection point $X$&nbsp;may be determined.&nbsp;</p>\n<p>Use&nbsp;the given geometric information&nbsp;to&nbsp;determine distance $h$.</p>\n<p>$h$ = [[0]]&nbsp;</p>\n<p><span data-jme-visible=\"debug\">h = {h}&nbsp;</span></p>", "gaps": [{"type": "engineering-answer", "useCustomName": true, "customName": "h", "marks": "5", "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": true, "showFeedbackIcon": true, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "settings": {"correctAnswer": "abs(siground(h,4))", "right": "0.2", "close": "1.0", "C1": "75", "C2": "50", "C3": "25"}}], "sortAnswers": false}, {"type": "gapfill", "useCustomName": true, "customName": "Direction of A", "marks": 0, "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": true, "showFeedbackIcon": true, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "prompt": "<p>With <em>h</em> known, the direction of force $\\mathbf{A}$ can be found since&nbsp;its&nbsp;line of action must pass through&nbsp;$X$.</p>\n<p>Use the given geometric information and determine $\\angle CAX $, which we will call $\\theta_A$</p>\n<p>$\\theta_A=$&nbsp;[[0]]</p>\n<p><span data-jme-visible=\"debug\">$\\theta_a$ = {theta_a}</span></p>", "gaps": [{"type": "angle-quantity-from-reference", "useCustomName": true, "customName": "$\\theta_A$", "marks": "5", "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": true, "showFeedbackIcon": true, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "settings": {"correct_quantity": "abs(precround(theta_a,2))", "right": "0.2", "restrict_angle": true, "C1": "75", "close": "1.0", "C2": "50", "C3": "25"}}], "sortAnswers": false}, {"type": "gapfill", "useCustomName": true, "customName": "Angles in Triangle", "marks": 0, "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": true, "showFeedbackIcon": true, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "prompt": "<p>The object&nbsp;is in equilibrium so when the three forces are added tip-to-tail they form a closed triangle as shown below.</p>\n<p>Determine the three angles in the force triangle.</p>\n<p>{geogebra_applet('sckn26vg',[ ['FB',scalar(FB)] , ['L',scalar(L)], ['&theta;',radians(theta)], ['&alpha;',radians(alpha1)],['units','\"'+units[1]+'\"' ]])}</p>\n<p>$\\alpha$ = [[0]] &nbsp;$\\beta$ = [[1]]&nbsp; &nbsp;$\\gamma$ =&nbsp;[[2]]</p>\n<p><span data-jme-visible=\"debug\">$\\alpha$ = {alpha} $\\beta$ = {beta} &nbsp;$\\gamma$ = {gamma}</span></p>\n<p><span data-jme-visible=\"debug\">A = {FA} &nbsp;B = {FB} &nbsp;C = {FC}</span></p>", "gaps": [{"type": "angle-quantity-from-reference", "useCustomName": true, "customName": "$\\alpha$", "marks": "5", "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": true, "showFeedbackIcon": true, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "settings": {"correct_quantity": "precround(alpha,2)", "right": "0.2", "restrict_angle": false, "C1": "75", "close": "1.0", "C2": "50", "C3": "25"}}, {"type": "angle-quantity-from-reference", "useCustomName": true, "customName": "$\\beta$", "marks": "5", "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": true, "showFeedbackIcon": true, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "settings": {"correct_quantity": "precround(beta,2)", "right": "0.2", "restrict_angle": false, "C1": "75", "close": "1.0", "C2": "50", "C3": "25"}}, {"type": "angle-quantity-from-reference", "useCustomName": true, "customName": "$\\gamma$", "marks": "5", "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": false, "showFeedbackIcon": true, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "settings": {"correct_quantity": "precround(gamma,2)", "right": "0.2", "restrict_angle": false, "C1": "75", "close": "1.0", "C2": "50", "C3": "25"}}], "sortAnswers": false}, {"type": "gapfill", "useCustomName": true, "customName": "Unknown Magnitudes", "marks": 0, "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": true, "showFeedbackIcon": true, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "prompt": "<p>Use the law of sines to determine the magnitudes of forces $\\mathbf{A}$ and $\\mathbf{C}$.</p>\n<p>$A$ =&nbsp;[[0]]</p>\n<p>$C$ = [[1]]</p>\n<p></p>", "gaps": [{"type": "engineering-answer", "useCustomName": true, "customName": "Fa", "marks": "5", "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": true, "showFeedbackIcon": true, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "settings": {"correctAnswer": "FA", "right": "0.2", "close": "1.0", "C1": "75", "C2": "50", "C3": "25"}}, {"type": "engineering-answer", "useCustomName": true, "customName": "Fc", "marks": "5", "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": true, "showFeedbackIcon": true, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "settings": {"correctAnswer": "FC", "right": "0.2", "close": "1.0", "C1": "75", "C2": "50", "C3": "25"}}], "sortAnswers": false}], "partsMode": "all", "maxMarks": 0, "objectives": [], "penalties": [], "objectiveVisibility": "always", "penaltyVisibility": "always"}, {"name": "Three force body method: Beam with angled load", "extensions": ["geogebra", "quantities"], "custom_part_types": [{"source": {"pk": 19, "author": {"name": "William Haynes", "pk": 2530}, "edit_page": "/part_type/19/edit"}, "name": "Engineering Accuracy with units", "short_name": "engineering-answer", "description": "<p>A value with units marked right if within an adjustable % error of the correct value. &nbsp;Marked close if within a wider margin of error.</p>", "help_url": "", "input_widget": "string", "input_options": {"correctAnswer": "siground(settings['correctAnswer'],4)", "hint": {"static": true, "value": ""}, "allowEmpty": {"static": true, "value": true}}, "can_be_gap": true, "can_be_step": true, "marking_script": "mark:\nswitch( \n  right and good_units and right_sign, add_credit(1.0,'Correct.'),\n  right and good_units and not right_sign, add_credit(settings['C2'],'Wrong sign.'),\n  right and right_sign and not good_units, add_credit(settings['C2'],'Correct value, but wrong or missing units.'),\n  close and good_units, add_credit(settings['C1'],'Close.'),\n  close and not good_units, add_credit(settings['C3'],'Answer is close, but wrong or missing units.'),\n  incorrect('Wrong answer.')\n)\n\n\ninterpreted_answer:\nqty(student_scalar, student_units)\n\n\n\ncorrect_quantity:\nsettings[\"correctAnswer\"]\n\n\n\ncorrect_units:\nunits(correct_quantity)\n\n\nallowed_notation_styles:\n[\"plain\",\"en\"]\n\nmatch_student_number:\nmatchnumber(studentAnswer,allowed_notation_styles)\n\nstudent_scalar:\nmatch_student_number[1]\n\nstudent_units:\nreplace_regex('ohms','ohm',\n  replace_regex('\u00b0', ' deg',\n    replace_regex('-', ' ' ,\n      studentAnswer[len(match_student_number[0])..len(studentAnswer)])),\"i\")\n\ngood_units:\ntry(\ncompatible(quantity(1, student_units),correct_units),\nmsg,\nfeedback(msg);false)\n\n\nstudent_quantity:\nswitch(not good_units, \n       student_scalar * correct_units, \n       not right_sign,\n       -quantity(student_scalar, student_units),\n       quantity(student_scalar,student_units)\n)\n  \n\n\npercent_error:\ntry(\nscalar(abs((correct_quantity - student_quantity)/correct_quantity))*100  \n,msg,\nif(student_quantity=correct_quantity,0,100))\n   \n\nright:\npercent_error <= settings['right']\n\n\nclose:\nright_sign and percent_error <= settings['close']\n\nright_sign:\nsign(student_scalar) = sign(correct_quantity)", "marking_notes": [{"name": "mark", "description": "This is the main marking note. It should award credit and provide feedback based on the student's answer.", "definition": "switch( \n  right and good_units and right_sign, add_credit(1.0,'Correct.'),\n  right and good_units and not right_sign, add_credit(settings['C2'],'Wrong sign.'),\n  right and right_sign and not good_units, add_credit(settings['C2'],'Correct value, but wrong or missing units.'),\n  close and good_units, add_credit(settings['C1'],'Close.'),\n  close and not good_units, add_credit(settings['C3'],'Answer is close, but wrong or missing units.'),\n  incorrect('Wrong answer.')\n)\n"}, {"name": "interpreted_answer", "description": "A value representing the student's answer to this part.", "definition": "qty(student_scalar, student_units)\n\n"}, {"name": "correct_quantity", "description": "", "definition": "settings[\"correctAnswer\"]\n\n"}, {"name": "correct_units", "description": "", "definition": "units(correct_quantity)\n"}, {"name": "allowed_notation_styles", "description": "", "definition": "[\"plain\",\"en\"]"}, {"name": "match_student_number", "description": "", "definition": "matchnumber(studentAnswer,allowed_notation_styles)"}, {"name": "student_scalar", "description": "", "definition": "match_student_number[1]"}, {"name": "student_units", "description": "<p>Modify&nbsp;the&nbsp;unit portion of&nbsp;the student's answer by</p>\n<p>1. replacing \"ohms\" with \"ohm\" &nbsp;case insensitive</p>\n<p>2.&nbsp;replacing '-'&nbsp;with ' '&nbsp;</p>\n<p>3. replacing '&deg;' with ' deg'&nbsp;</p>\n<p>to allow answers like 10 ft-lb and 30&deg;</p>", "definition": "replace_regex('ohms','ohm',\n  replace_regex('\u00b0', ' deg',\n    replace_regex('-', ' ' ,\n      studentAnswer[len(match_student_number[0])..len(studentAnswer)])),\"i\")"}, {"name": "good_units", "description": "", "definition": "try(\ncompatible(quantity(1, student_units),correct_units),\nmsg,\nfeedback(msg);false)\n"}, {"name": "student_quantity", "description": "<p>This fixes the student answer for two common errors. &nbsp;</p>\n<p>If student_units are wrong&nbsp;&nbsp;- replace with correct units</p>\n<p>If student_scalar has the wrong sign - replace with right sign</p>\n<p>If student makes both errors, only one gets fixed.</p>", "definition": "switch(not good_units, \n       student_scalar * correct_units, \n       not right_sign,\n       -quantity(student_scalar, student_units),\n       quantity(student_scalar,student_units)\n)\n  \n"}, {"name": "percent_error", "description": "", "definition": "try(\nscalar(abs((correct_quantity - student_quantity)/correct_quantity))*100  \n,msg,\nif(student_quantity=correct_quantity,0,100))\n   "}, {"name": "right", "description": "", "definition": "percent_error <= settings['right']\n"}, {"name": "close", "description": "<p>Only marked close if the student actually has the right sign.</p>", "definition": "right_sign and percent_error <= settings['close']"}, {"name": "right_sign", "description": "", "definition": "sign(student_scalar) = sign(correct_quantity) "}], "settings": [{"name": "correctAnswer", "label": "Correct Quantity.", "help_url": "", "hint": "The correct answer given as a JME quantity.", "input_type": "code", "default_value": "", "evaluate": true}, {"name": "right", "label": "% Accuracy for right.", "help_url": "", "hint": "Question will be considered correct if the scalar part of the student's answer is within this % of correct value.", "input_type": "code", "default_value": "0.2", "evaluate": true}, {"name": "close", "label": "% Accuracy for close.", "help_url": "", "hint": "Question will be considered close if the scalar part of the student's answer is within this % of correct value.", "input_type": "code", "default_value": "1.0", "evaluate": true}, {"name": "C1", "label": "Close with units.", "help_url": "", "hint": "Partial Credit for close value with appropriate units. &nbsp;if correct answer is 100 N and close is &plusmn;1%,<br />99 &nbsp;N is accepted.", "input_type": "percent", "default_value": "75"}, {"name": "C2", "label": "No units or wrong sign", "help_url": "", "hint": "Partial credit for forgetting units or using wrong sign.<br />If the correct answer is 100 N, both 100 and -100 N are accepted.", "input_type": "percent", "default_value": "50"}, {"name": "C3", "label": "Close, no units.", "help_url": "", "hint": "Partial Credit for close value but forgotten units.<br />This value would be close&nbsp;if the expected units were provided. &nbsp;If the correct answer is 100 N, and close is &plusmn;1%,<br />99 is accepted.", "input_type": "percent", "default_value": "25"}], "public_availability": "always", "published": true, "extensions": ["quantities"]}], "resources": [["question-resources/diagram_1.png", "/srv/numbas/media/question-resources/diagram_1.png"], ["question-resources/diagram_2.png", "/srv/numbas/media/question-resources/diagram_2.png"]], "navigation": {"allowregen": true, "showfrontpage": false, "preventleave": false, "typeendtoleave": false}, "contributors": [{"name": "William Haynes", "profile_url": "https://numbas.mathcentre.ac.uk/accounts/profile/2530/"}], "tags": ["Equilibrium", "equilibrium", "Mechanics", "mechanics", "rigid body", "Rigid Body", "Statics", "statics", "three force body", "Three force body"], "metadata": {"description": "Simple geometry to introduce the three-force-body procedure.", "licence": "Creative Commons Attribution-NonCommercial 4.0 International"}, "statement": "<p>{geogebra_applet(\"xfpyfgd9\",[['split',&nbsp;split], ['&theta;',theta+'&deg;']])}&nbsp;</p>\n<p>A beam is loaded with a {F} force at a {theta}&deg; angle from the horizontal, as shown. &nbsp;Distance&nbsp;$\\overline{AB}$ is {AB}, and $\\overline{BC}$ is {BC}.</p>\n<p>Use the three-force body method to determine the magnitudes of the reactions at pin $A$ and roller $C$.</p>", "advice": "<p><strong>Given:</strong></p>\n<ul>\n<li>$F$ = {F}</li>\n<li>$\\theta$ = {theta}&deg;</li>\n<li>$\\overline{AB}$ = {AB}</li>\n<li>$\\overline{BC}$ = {BC}</li>\n<li>Force $\\mathbf{C}$ acts straight up, due to the roller.</li>\n</ul>\n<p><strong>Required:&nbsp;</strong></p>\n<ul>\n<li>magnitudes&nbsp;of $\\mathbf{A}$ and $\\mathbf{C}$.</li>\n</ul>\n<p><strong>Procedure:</strong></p>\n<ol>\n<li>Start by drawing a clear diagram representing the situation and locate point \"$x$\" where the lines of action of $\\mathbf{F}$ and $\\mathbf{C}$ intersect. &nbsp;In three-force-bodies, the line of action of $\\mathbf{A}$ must pass through that point too. &nbsp;</li>\n<li>Draw the line of action of $\\mathbf{A}$ and define $\\alpha$.\n<p><img src=\"resources/question-resources/diagram_1.png\" width=\"448\" height=\"345\"/></p>\n</li>\n<li>Find $h$, using: &nbsp;\\[\\tan\\theta = \\frac{h}{\\overline{BC}}\\]</li>\n<li>Find $\\alpha$: &nbsp;\\[\\tan\\alpha&nbsp;=\\frac{h}{(\\overline{AB} + \\overline{BC})}\\]</li>\n<li>Rearrange the forces into a force triangle, tip-to-tail, and label it.\n<p><img src=\"resources/question-resources/diagram_2.png\" width=\"320\" height=\"288\"/></p>\n</li>\n<li>\n<p>Use the law of sines&nbsp;to&nbsp;solve for the unknown magnitudes. \\[ \\frac{F}{\\sin (90 + \\alpha)} = &nbsp; &nbsp;\\frac{A}{\\sin (90&deg; -&nbsp;\\theta)} =&nbsp;\\frac{C}{\\sin (\\theta-\\alpha)}\\]</p>\n</li>\n</ol>", "rulesets": {}, "builtin_constants": {"e": true, "pi,\u03c0": true, "i": true}, "constants": [], "variables": {"L": {"name": "L", "group": "inputs", "definition": "qty(random(1..5),'m')", "description": "<p>length of beam</p>\n<p></p>", "templateType": "anything", "can_override": false}, "split": {"name": "split", "group": "inputs", "definition": "random(0.2..0.8#0.5)", "description": "<p>percentage position of point B</p>", "templateType": "anything", "can_override": false}, "AB": {"name": "AB", "group": "Ungrouped variables", "definition": "split l", "description": "<p>segment AB</p>", "templateType": "anything", "can_override": false}, "BC": {"name": "BC", "group": "Ungrouped variables", "definition": "L-AB", "description": "", "templateType": "anything", "can_override": false}, "theta": {"name": "theta", "group": "inputs", "definition": "random(15..80#5)", "description": "", "templateType": "anything", "can_override": false}, "F": {"name": "F", "group": "inputs", "definition": "qty(random(25..150#5),'kN')", "description": "", "templateType": "anything", "can_override": false}, "h": {"name": "h", "group": "solution", "definition": "tan(radians(theta))BC", "description": "", "templateType": "anything", "can_override": false}, "alpha": {"name": "alpha", "group": "solution", "definition": "degrees(arctan(scalar(h/L)))", "description": "", "templateType": "anything", "can_override": false}, "K": {"name": "K", "group": "solution", "definition": "F/sin(radians(90+alpha))", "description": "", "templateType": "anything", "can_override": false}, "A": {"name": "A", "group": "solution", "definition": "K sin(radians(90-theta))", "description": "", "templateType": "anything", "can_override": false}, "C": {"name": "C", "group": "solution", "definition": "K sin(radians(theta-alpha))", "description": "", "templateType": "anything", "can_override": false}}, "variablesTest": {"condition": "", "maxRuns": 100}, "ungrouped_variables": ["AB", "BC"], "variable_groups": [{"name": "inputs", "variables": ["split", "L", "theta", "F"]}, {"name": "solution", "variables": ["h", "alpha", "K", "A", "C"]}], "functions": {}, "preamble": {"js": "", "css": ""}, "parts": [{"type": "gapfill", "useCustomName": false, "customName": "", "marks": 0, "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": true, "showFeedbackIcon": true, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "prompt": "<p>$A$ =&nbsp;[[0]]&nbsp;$\\qquad C$ =&nbsp;[[1]]</p>", "gaps": [{"type": "engineering-answer", "useCustomName": false, "customName": "", "marks": "10", "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": true, "showFeedbackIcon": true, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "settings": {"correctAnswer": "A", "right": "0.2", "close": "1.0", "C1": "75", "C2": "50", "C3": "25"}}, {"type": "engineering-answer", "useCustomName": false, "customName": "", "marks": "10", "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": true, "showFeedbackIcon": true, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "settings": {"correctAnswer": "C", "right": "0.2", "close": "1.0", "C1": "75", "C2": "50", "C3": "25"}}], "sortAnswers": false}], "partsMode": "all", "maxMarks": 0, "objectives": [], "penalties": [], "objectiveVisibility": "always", "penaltyVisibility": "always"}]}], "allowPrinting": true, "navigation": {"allowregen": true, "reverse": true, "browse": true, "allowsteps": true, "showfrontpage": false, "showresultspage": "oncompletion", "navigatemode": "menu", "onleave": {"action": "none", "message": ""}, "preventleave": true, "startpassword": ""}, "timing": {"allowPause": true, "timeout": {"action": "none", "message": ""}, "timedwarning": {"action": "none", "message": ""}}, "feedback": {"showactualmark": true, "showtotalmark": true, "showanswerstate": true, "allowrevealanswer": true, "advicethreshold": 0, "intro": "", "reviewshowscore": true, "reviewshowfeedback": true, "reviewshowexpectedanswer": true, "reviewshowadvice": true, "feedbackmessages": []}, "diagnostic": {"knowledge_graph": {"topics": [], "learning_objectives": []}, "script": "diagnosys", "customScript": ""}, "contributors": [{"name": "William Haynes", "profile_url": "https://numbas.mathcentre.ac.uk/accounts/profile/2530/"}], "extensions": ["/srv/numbas/media/user-extensions/extracted/41/geogebra", "/srv/numbas/media/user-extensions/extracted/55/quantities", "/srv/numbas/media/user-extensions/extracted/98/weh"], "custom_part_types": [{"source": {"pk": 24, "author": {"name": "William Haynes", "pk": 2530}, "edit_page": "/part_type/24/edit"}, "name": "Angle quantity", "short_name": "angle-quantity-from-reference", "description": "<p>Angle&nbsp;as a quantity in degrees.</p>", "help_url": "", "input_widget": "string", "input_options": {"correctAnswer": "plain_string(settings['correct_quantity'])", "hint": {"static": true, "value": ""}, "allowEmpty": {"static": true, "value": false}}, "can_be_gap": true, "can_be_step": true, "marking_script": "mark:\nswitch( \nright and good_units and right_sign and angle_in_range, add_credit(1.0,'Correct.'),\nright and good_units and not right_sign, add_credit(settings['C2'],'Wrong sign.'),\nright and right_sign and not good_units, add_credit(settings['C2'],'Correct value, but missing degree symbol.'),\nright and good_units and right_sign and not angle_in_range,add_credit(settings['C1'],'Angle is out of range.'),\nclose and good_units, add_credit(settings['C1'],'Close.'),\nclose and not good_units, add_credit(settings['C3'],'Answer is close, but missing degree symbol.'),\nincorrect('Wrong answer.')\n)\n\ninterpreted_answer:\nqty(student_scalar, student_units)\n\ncorrect_scalar:\nscalar(correct_quantity)\n  \n\ncorrect_quantity:\nsettings['correct_quantity']\n\ncorrect_units:\nunits(correct_quantity)\n\nallowed_notation_styles:\n[\"plain\",\"en\"]\n\nmatch_student_number:\nmatchnumber(studentAnswer,allowed_notation_styles)\n\nstudent_scalar:\nmatch_student_number[1]\n\nstudent_units:\njoin(\nsplit(studentAnswer[len(match_student_number[0])..len(studentAnswer)]\n,\"\u00b0\"),\" deg\")\n\n\n\ngood_units:\ntry(\ncompatible(quantity(1, student_units),correct_quantity),\nmsg,\nfeedback(msg);false)\n\nstudent_quantity:\nswitch(not good_units, \nstudent_scalar * correct_units, \nnot right_sign,\n-quantity(student_scalar, student_units),\nquantity(student_scalar,student_units)\n)\n\nright_sign:\nsign(student_scalar) = sign(correct_quantity)\n\nangle_in_range:\nif(settings['restrict_angle'], abs(student_scalar) <= 90, true)\n\nright:\nwithinTolerance(abs(student_scalar), abs(correct_scalar), settings['right'])\n\nclose:\nwithinTolerance(student_scalar, correct_scalar, settings['close'])", "marking_notes": [{"name": "mark", "description": "This is the main marking note. It should award credit and provide feedback based on the student's answer.", "definition": "switch( \nright and good_units and right_sign and angle_in_range, add_credit(1.0,'Correct.'),\nright and good_units and not right_sign, add_credit(settings['C2'],'Wrong sign.'),\nright and right_sign and not good_units, add_credit(settings['C2'],'Correct value, but missing degree symbol.'),\nright and good_units and right_sign and not angle_in_range,add_credit(settings['C1'],'Angle is out of range.'),\nclose and good_units, add_credit(settings['C1'],'Close.'),\nclose and not good_units, add_credit(settings['C3'],'Answer is close, but missing degree symbol.'),\nincorrect('Wrong answer.')\n)"}, {"name": "interpreted_answer", "description": "A value representing the student's answer to this part.", "definition": "qty(student_scalar, student_units)"}, {"name": "correct_scalar", "description": "", "definition": "scalar(correct_quantity)\n  "}, {"name": "correct_quantity", "description": "", "definition": "settings['correct_quantity']"}, {"name": "correct_units", "description": "", "definition": "units(correct_quantity)"}, {"name": "allowed_notation_styles", "description": "", "definition": "[\"plain\",\"en\"]"}, {"name": "match_student_number", "description": "", "definition": "matchnumber(studentAnswer,allowed_notation_styles)"}, {"name": "student_scalar", "description": "", "definition": "match_student_number[1]"}, {"name": "student_units", "description": "", "definition": "join(\nsplit(studentAnswer[len(match_student_number[0])..len(studentAnswer)]\n,\"\u00b0\"),\" deg\")\n\n"}, {"name": "good_units", "description": "", "definition": "try(\ncompatible(quantity(1, student_units),correct_quantity),\nmsg,\nfeedback(msg);false)"}, {"name": "student_quantity", "description": "", "definition": "switch(not good_units, \nstudent_scalar * correct_units, \nnot right_sign,\n-quantity(student_scalar, student_units),\nquantity(student_scalar,student_units)\n)"}, {"name": "right_sign", "description": "", "definition": "sign(student_scalar) = sign(correct_quantity)"}, {"name": "angle_in_range", "description": "", "definition": "if(settings['restrict_angle'], abs(student_scalar) <= 90, true)"}, {"name": "right", "description": "<p>Will check for correct sign elswhere.</p>", "definition": "withinTolerance(abs(student_scalar), abs(correct_scalar), settings['right'])"}, {"name": "close", "description": "<p>Must have correct sign to be close.</p>", "definition": "withinTolerance(student_scalar, correct_scalar, settings['close'])\n"}], "settings": [{"name": "correct_quantity", "label": "Correct Angle as quantity ", "help_url": "", "hint": "", "input_type": "code", "default_value": "qty(45,'deg')", "evaluate": true}, {"name": "right", "label": "Accuracy for right.", "help_url": "", "hint": "Question will be considered correct if the scalar part of the student's answer is within &plusmn; this amount from the correct value.", "input_type": "code", "default_value": "0.1", "evaluate": true}, {"name": "restrict_angle", "label": "Less than 90\u00b0", "help_url": "", "hint": "When checked, angle must be between -90&deg; and +90&deg;.", "input_type": "checkbox", "default_value": true}, {"name": "C1", "label": "Close with units.", "help_url": "", "hint": "Partial Credit for close value with appropriate units.", "input_type": "percent", "default_value": "75"}, {"name": "close", "label": " Accuracy for close.", "help_url": "", "hint": "Question will be considered close if the scalar part of the student's answer is within &plusmn; this amount from the correct value.", "input_type": "code", "default_value": "0.5", "evaluate": true}, {"name": "C2", "label": "No units or wrong sign", "help_url": "", "hint": "Partial credit for forgetting units or using wrong sign.", "input_type": "percent", "default_value": "50"}, {"name": "C3", "label": "Close, no units.", "help_url": "", "hint": "Partial Credit for close value without units.", "input_type": "percent", "default_value": "25"}], "public_availability": "restricted", "published": false, "extensions": ["quantities"]}, {"source": {"pk": 12, "author": {"name": "William Haynes", "pk": 2530}, "edit_page": "/part_type/12/edit"}, "name": "Angle quantity 2020", "short_name": "angle", "description": "<p>Adjusts all angles to 0 &lt; $\\theta$ &lt; 360.</p>\n<p>Accepts '&deg;' and 'deg' as units.</p>\n<p>Penalizes if not close enough or no units.</p>\n<p>90&deg; = -270&deg; = 450&deg;</p>", "help_url": "", "input_widget": "string", "input_options": {"correctAnswer": "plain_string(settings['expected_answer']) ", "hint": {"static": true, "value": ""}, "allowEmpty": {"static": true, "value": false}}, "can_be_gap": true, "can_be_step": true, "marking_script": "original_student_scalar:\nmatchnumber(studentAnswer,['plain','en'])[1]\n\nstudent_scalar:\nmod(original_student_scalar,360)\n\n\nstudent_unit:\nstudentAnswer[len(matchnumber(studentAnswer,['plain','en'])[0])..len(studentAnswer)]\n\ninterpreted_unit:\nif(trim(student_unit)='\u00b0','deg',student_unit)\n\ninterpreted_answer:\nqty(mod(student_scalar,360),'deg')\n\nclose:\nwithintolerance(student_scalar, correct_scalar,decimal(settings['close_tol']))\n\ncorrect_scalar:\nmod(scalar(settings['expected_answer']),360)\n\nright:\nwithintolerance(student_scalar, correct_scalar, decimal(settings['right_tol']))\n\ngood_unit:\nsame(qty(1,interpreted_unit),qty(1,'deg'))\n\nmark:\nassert(close,incorrect('Incorrect.');end());\nif(right,correct('Correct angle.'), set_credit(1 - settings['close_penalty'],'Angle is close.'));\nassert(good_unit,sub_credit(settings['unit_penalty'], 'Missing or incorrect units.'))", "marking_notes": [{"name": "original_student_scalar", "description": "<p>Retuns the scalar part of students answer (which is a quantity) as a number.</p>", "definition": "matchnumber(studentAnswer,['plain','en'])[1]"}, {"name": "student_scalar", "description": "<p>Normalize angle with mod 360</p>", "definition": "mod(original_student_scalar,360)\n"}, {"name": "student_unit", "description": "<p>matchnumber(studentAnswer,['plain','en'])[0] is a string \"12.34\"</p>", "definition": "studentAnswer[len(matchnumber(studentAnswer,['plain','en'])[0])..len(studentAnswer)]"}, {"name": "interpreted_unit", "description": "<p>Allows student to use degree symbol or 'deg' for units.</p>", "definition": "if(trim(student_unit)='\u00b0','deg',student_unit)"}, {"name": "interpreted_answer", "description": "A value representing the student's answer to this part.", "definition": "qty(mod(student_scalar,360),'deg')"}, {"name": "close", "description": "", "definition": "withintolerance(student_scalar, correct_scalar,decimal(settings['close_tol']))"}, {"name": "correct_scalar", "description": "<p>Normalize expected_answer with mod 360</p>", "definition": "mod(scalar(settings['expected_answer']),360)"}, {"name": "right", "description": "", "definition": "withintolerance(student_scalar, correct_scalar, decimal(settings['right_tol']))"}, {"name": "good_unit", "description": "", "definition": "same(qty(1,interpreted_unit),qty(1,'deg'))"}, {"name": "mark", "description": "This is the main marking note. It should award credit and provide feedback based on the student's answer.", "definition": "assert(close,incorrect('Incorrect.');end());\nif(right,correct('Correct angle.'), set_credit(1 - settings['close_penalty'],'Angle is close.'));\nassert(good_unit,sub_credit(settings['unit_penalty'], 'Missing or incorrect units.'))"}], "settings": [{"name": "expected_answer", "label": "Expected Answer", "help_url": "", "hint": "Expected angle as a quantity.", "input_type": "code", "default_value": "qty(30,'deg')", "evaluate": true}, {"name": "unit_penalty", "label": "Unit penalty", "help_url": "", "hint": "Penalty for not including degree sign or 'deg'.", "input_type": "percent", "default_value": "20"}, {"name": "close_penalty", "label": "Close Penalty", "help_url": "", "hint": "Penalty for close answer.", "input_type": "percent", "default_value": "20"}, {"name": "close_tol", "label": "Close", "help_url": "", "hint": "Angle must be $\\pm$ this many degrees to be marked close. &nbsp;&nbsp;", "input_type": "code", "default_value": "0.5", "evaluate": false}, {"name": "right_tol", "label": "Right ", "help_url": "", "hint": "Angle must be $\\pm$ this many degrees to be marked correct. &nbsp;", "input_type": "code", "default_value": "0.1", "evaluate": false}], "public_availability": "restricted", "published": false, "extensions": ["quantities"]}, {"source": {"pk": 19, "author": {"name": "William Haynes", "pk": 2530}, "edit_page": "/part_type/19/edit"}, "name": "Engineering Accuracy with units", "short_name": "engineering-answer", "description": "<p>A value with units marked right if within an adjustable % error of the correct value. &nbsp;Marked close if within a wider margin of error.</p>", "help_url": "", "input_widget": "string", "input_options": {"correctAnswer": "siground(settings['correctAnswer'],4)", "hint": {"static": true, "value": ""}, "allowEmpty": {"static": true, "value": true}}, "can_be_gap": true, "can_be_step": true, "marking_script": "mark:\nswitch( \n  right and good_units and right_sign, add_credit(1.0,'Correct.'),\n  right and good_units and not right_sign, add_credit(settings['C2'],'Wrong sign.'),\n  right and right_sign and not good_units, add_credit(settings['C2'],'Correct value, but wrong or missing units.'),\n  close and good_units, add_credit(settings['C1'],'Close.'),\n  close and not good_units, add_credit(settings['C3'],'Answer is close, but wrong or missing units.'),\n  incorrect('Wrong answer.')\n)\n\n\ninterpreted_answer:\nqty(student_scalar, student_units)\n\n\n\ncorrect_quantity:\nsettings[\"correctAnswer\"]\n\n\n\ncorrect_units:\nunits(correct_quantity)\n\n\nallowed_notation_styles:\n[\"plain\",\"en\"]\n\nmatch_student_number:\nmatchnumber(studentAnswer,allowed_notation_styles)\n\nstudent_scalar:\nmatch_student_number[1]\n\nstudent_units:\nreplace_regex('ohms','ohm',\n  replace_regex('\u00b0', ' deg',\n    replace_regex('-', ' ' ,\n      studentAnswer[len(match_student_number[0])..len(studentAnswer)])),\"i\")\n\ngood_units:\ntry(\ncompatible(quantity(1, student_units),correct_units),\nmsg,\nfeedback(msg);false)\n\n\nstudent_quantity:\nswitch(not good_units, \n       student_scalar * correct_units, \n       not right_sign,\n       -quantity(student_scalar, student_units),\n       quantity(student_scalar,student_units)\n)\n  \n\n\npercent_error:\ntry(\nscalar(abs((correct_quantity - student_quantity)/correct_quantity))*100  \n,msg,\nif(student_quantity=correct_quantity,0,100))\n   \n\nright:\npercent_error <= settings['right']\n\n\nclose:\nright_sign and percent_error <= settings['close']\n\nright_sign:\nsign(student_scalar) = sign(correct_quantity)", "marking_notes": [{"name": "mark", "description": "This is the main marking note. It should award credit and provide feedback based on the student's answer.", "definition": "switch( \n  right and good_units and right_sign, add_credit(1.0,'Correct.'),\n  right and good_units and not right_sign, add_credit(settings['C2'],'Wrong sign.'),\n  right and right_sign and not good_units, add_credit(settings['C2'],'Correct value, but wrong or missing units.'),\n  close and good_units, add_credit(settings['C1'],'Close.'),\n  close and not good_units, add_credit(settings['C3'],'Answer is close, but wrong or missing units.'),\n  incorrect('Wrong answer.')\n)\n"}, {"name": "interpreted_answer", "description": "A value representing the student's answer to this part.", "definition": "qty(student_scalar, student_units)\n\n"}, {"name": "correct_quantity", "description": "", "definition": "settings[\"correctAnswer\"]\n\n"}, {"name": "correct_units", "description": "", "definition": "units(correct_quantity)\n"}, {"name": "allowed_notation_styles", "description": "", "definition": "[\"plain\",\"en\"]"}, {"name": "match_student_number", "description": "", "definition": "matchnumber(studentAnswer,allowed_notation_styles)"}, {"name": "student_scalar", "description": "", "definition": "match_student_number[1]"}, {"name": "student_units", "description": "<p>Modify&nbsp;the&nbsp;unit portion of&nbsp;the student's answer by</p>\n<p>1. replacing \"ohms\" with \"ohm\" &nbsp;case insensitive</p>\n<p>2.&nbsp;replacing '-'&nbsp;with ' '&nbsp;</p>\n<p>3. replacing '&deg;' with ' deg'&nbsp;</p>\n<p>to allow answers like 10 ft-lb and 30&deg;</p>", "definition": "replace_regex('ohms','ohm',\n  replace_regex('\u00b0', ' deg',\n    replace_regex('-', ' ' ,\n      studentAnswer[len(match_student_number[0])..len(studentAnswer)])),\"i\")"}, {"name": "good_units", "description": "", "definition": "try(\ncompatible(quantity(1, student_units),correct_units),\nmsg,\nfeedback(msg);false)\n"}, {"name": "student_quantity", "description": "<p>This fixes the student answer for two common errors. &nbsp;</p>\n<p>If student_units are wrong&nbsp;&nbsp;- replace with correct units</p>\n<p>If student_scalar has the wrong sign - replace with right sign</p>\n<p>If student makes both errors, only one gets fixed.</p>", "definition": "switch(not good_units, \n       student_scalar * correct_units, \n       not right_sign,\n       -quantity(student_scalar, student_units),\n       quantity(student_scalar,student_units)\n)\n  \n"}, {"name": "percent_error", "description": "", "definition": "try(\nscalar(abs((correct_quantity - student_quantity)/correct_quantity))*100  \n,msg,\nif(student_quantity=correct_quantity,0,100))\n   "}, {"name": "right", "description": "", "definition": "percent_error <= settings['right']\n"}, {"name": "close", "description": "<p>Only marked close if the student actually has the right sign.</p>", "definition": "right_sign and percent_error <= settings['close']"}, {"name": "right_sign", "description": "", "definition": "sign(student_scalar) = sign(correct_quantity) "}], "settings": [{"name": "correctAnswer", "label": "Correct Quantity.", "help_url": "", "hint": "The correct answer given as a JME quantity.", "input_type": "code", "default_value": "", "evaluate": true}, {"name": "right", "label": "% Accuracy for right.", "help_url": "", "hint": "Question will be considered correct if the scalar part of the student's answer is within this % of correct value.", "input_type": "code", "default_value": "0.2", "evaluate": true}, {"name": "close", "label": "% Accuracy for close.", "help_url": "", "hint": "Question will be considered close if the scalar part of the student's answer is within this % of correct value.", "input_type": "code", "default_value": "1.0", "evaluate": true}, {"name": "C1", "label": "Close with units.", "help_url": "", "hint": "Partial Credit for close value with appropriate units. &nbsp;if correct answer is 100 N and close is &plusmn;1%,<br />99 &nbsp;N is accepted.", "input_type": "percent", "default_value": "75"}, {"name": "C2", "label": "No units or wrong sign", "help_url": "", "hint": "Partial credit for forgetting units or using wrong sign.<br />If the correct answer is 100 N, both 100 and -100 N are accepted.", "input_type": "percent", "default_value": "50"}, {"name": "C3", "label": "Close, no units.", "help_url": "", "hint": "Partial Credit for close value but forgotten units.<br />This value would be close&nbsp;if the expected units were provided. &nbsp;If the correct answer is 100 N, and close is &plusmn;1%,<br />99 is accepted.", "input_type": "percent", "default_value": "25"}], "public_availability": "always", "published": true, "extensions": ["quantities"]}], "resources": [["question-resources/fbd.png", "/srv/numbas/media/question-resources/fbd.png"], ["question-resources/diagram_1.png", "/srv/numbas/media/question-resources/diagram_1.png"], ["question-resources/diagram_2.png", "/srv/numbas/media/question-resources/diagram_2.png"]]}