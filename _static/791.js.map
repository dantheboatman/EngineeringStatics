{"version":3,"file":"791.js","mappings":"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","sources":["webpack://WebComponents/./node_modules/btm-expressions/src/reductions.js","webpack://WebComponents/./node_modules/btm-expressions/src/expression.js","webpack://WebComponents/./node_modules/btm-expressions/src/real_number.js","webpack://WebComponents/./node_modules/btm-expressions/src/rational_number.js","webpack://WebComponents/./node_modules/btm-expressions/src/scalar_expr.js","webpack://WebComponents/./node_modules/btm-expressions/src/variable_expr.js","webpack://WebComponents/./node_modules/btm-expressions/src/binop_expr.js","webpack://WebComponents/./node_modules/btm-expressions/src/unop_expr.js","webpack://WebComponents/./node_modules/btm-expressions/src/multiop_expr.js","webpack://WebComponents/./node_modules/btm-expressions/src/function_expr.js","webpack://WebComponents/./node_modules/btm-expressions/src/deriv_expr.js","webpack://WebComponents/./node_modules/btm-expressions/src/random.js","webpack://WebComponents/./node_modules/btm-expressions/src/BTM_root.js"],"sourcesContent":["/*!\n * menv JavaScript Library v@VERSION\n * https://github.com/dbrianwalton/menv\n *\n * Copyright D. Brian Walton\n * Released under the MIT license (https://opensource.org/licenses/MIT)\n *\n * Date: @DATE\n */\n\n/* *********************************************************************************\n**  Dealing with identities and reductions.\n********************************************************************************* */\n\nimport {MENV, exprType, exprValue } from \"./BTM_root.js\";\n\nclass Identity {\n    constructor(refExpr, eqExpr, description, isValid, idNum) {\n        this.refExpr = refExpr;\n        this.eqExpr = eqExpr;\n        this.description = description;\n        this.isValid = isValid;\n        this.isActive = true;\n        this.idNum = idNum;\n    }\n}\n\nclass Match {\n    constructor(testRule, bindings) {\n        // Find unbound variables.\n        var allVars = testRule.eqExpr.dependencies(),\n            missVars = [];\n        for (var j in allVars) {\n            if (typeof bindings[allVars[j]] == 'undefined') {\n                missVars.push(allVars[j]);\n            }\n        }\n        for (var j in missVars) {\n            bindings[missVars[j]] = \"input\"+(+j+1)+\"\";\n        }\n        var substExpr = testRule.eqExpr.compose(bindings);\n\n        this.subTeX = substExpr.toTeX();\n        this.subStr = substExpr.toString();\n        this.name = testRule.description;\n        if (substExpr.type == exprType.binop && substExpr.valueType == exprValue.bool) {\n            this.equation = testRule.refExpr.toTeX() + \" \\\\iff \" + testRule.eqExpr.toTeX();\n        } else {\n            this.equation = testRule.refExpr.toTeX() + \"=\" + testRule.eqExpr.toTeX();\n        }\n        this.bindings = bindings;\n        this.numInputs = missVars.length;\n        this.ruleID = testRule.idNum;\n    }\n}\n\n\n\nexport function newRule(menv, reductionList, equation, description, isValid, useOneWay, constraints) {\n    var exprFormulas = equation.split('==');\n    if (exprFormulas.length != 2) {\n        console.log(\"Invalid equation in identity list: \" + equation);\n    } else {\n        for (var refID=0; refID <= 1; refID++) {\n            if (refID == 1 && typeof useOneWay != 'undefined' && useOneWay) {\n                break;\n            }\n            var identity;\n\n            var refExpr = menv.parse(exprFormulas[refID],\"formula\");\n            var eqExpr = menv.parse(exprFormulas[1-refID],\"formula\");\n            var numVars = refExpr.dependencies().length;\n            var allRefExpr = [exprFormulas[refID]];\n            // this is a big slow down, so just make sure each rule is written in multiple ways.\n            //      var allRefExpr = refExpr.allStringEquivs();\n\n            var uniqueExpr = [];\n            for (var i in allRefExpr) {\n                var nextExpr = menv.parse(allRefExpr[i],\"formula\");\n                var isNew = true;\n                for (var j in uniqueExpr) {\n                    var bindings = uniqueExpr[j].match(nextExpr, {});\n                    if (bindings !== null) {\n                        isNew = false;\n                    }\n                }\n                if (isNew) {\n                    var ruleID = reductionList.length+1;\n                    identity = new Identity(nextExpr, eqExpr, description, isValid, ruleID);\n                    reductionList.push(identity);\n                    uniqueExpr.push(nextExpr);\n                }\n            }\n        }\n    }\n}\n\n// Disable a rule in the list.\nexport function disableRule(menv, reductionList, equation) {\n  // Match only on refExpr.\n  var exprFormulas = equation.split('==');\n  var refExpr, eqExpr;\n  if (exprFormulas.length > 2) {\n    console.log(\"Invalid equation in identity list: \" + equation);\n    return;\n  } else {\n    refExpr = menv.parse(exprFormulas[0],\"formula\");\n  }\n  for (var i in reductionList) {\n    var testRule = reductionList[i];\n    var bindings = testRule.refExpr.match(refExpr, {})\n    if (bindings !== null) {\n      reductionList[i].isActive = false;\n    }\n}\n}\n\n/* *******************\n** Given a list of reduction rules and a given expression,\n** test each reduction rule to see if it matches the structure.\n** Create an array of new objects with bindings stating what\n** substitutions are necessary to make the matches.\n******************* */\nexport function findMatchRules(reductionList, testExpr, doValidate) {\n    var matchList = [];\n    var i, testRule;\n    for (i in reductionList) {\n        testRule = reductionList[i];\n        var bindings = testRule.refExpr.match(testExpr, {})\n        if (testRule.isActive && bindings !== null) {\n            var match = new Match(testRule, bindings);\n            matchList.push(match);\n        }\n    }\n    return(matchList);\n}\n\n\nexport function defaultReductions(menv) {\n    var reduceRules = new Array();\n\n    newRule(menv, reduceRules, '0+x==x', 'Additive Identity', true, true);\n    newRule(menv, reduceRules, 'x+0==x', 'Additive Identity', true, true);\n    newRule(menv, reduceRules, '0-x==-x', 'Additive Inverse', true, true);\n    newRule(menv, reduceRules, 'x-0==x', 'Additive Identity', true, true);\n    newRule(menv, reduceRules, '0*x==0', 'Multiply by Zero', true, true);\n    newRule(menv, reduceRules, 'x*0==0', 'Multiply by Zero', true, true);\n    newRule(menv, reduceRules, '1*x==x', 'Multiplicative Identity', true, true);\n    newRule(menv, reduceRules, 'x*1==x', 'Multiplicative Identity', true, true);\n    newRule(menv, reduceRules, '0/x==0', 'Multiply by Zero', true, true);\n    newRule(menv, reduceRules, 'x/1==x', 'Divide by One', true, true);\n    newRule(menv, reduceRules, 'x^1==x', 'First Power', true, true);\n    newRule(menv, reduceRules, 'x^0==1', 'Zero Power', true, true);\n    newRule(menv, reduceRules, 'x^(-a)==1/(x^a)', 'Negative Power', true, true);\n    newRule(menv, reduceRules, '1^x==1', 'One to a Power', true, true);\n    newRule(menv, reduceRules, '-1*x==-x', 'Multiplicative Identity', true, true);\n    newRule(menv, reduceRules, 'x*-1==-x', 'Multiplicative Identity', true, true);\n    newRule(menv, reduceRules, 'x-x==0', 'Additive Inverses Cancel', true, true);\n    newRule(menv, reduceRules, 'x+-x==0', 'Additive Inverses Cancel', true, true);\n    newRule(menv, reduceRules, '-x+x==0', 'Additive Inverses Cancel', true, true);\n    newRule(menv, reduceRules, '(-x)+y==y-x', \"Swap Leading Negative\", true, true);\n    newRule(menv, reduceRules, 'x+(-y)==x-y', \"Subtraction\", true, true);\n    newRule(menv, reduceRules, '(-x)+(-y)==-(x+y)', \"Factor Negation from Addition\", true, true);\n    newRule(menv, reduceRules, '(-x)-y==-(x+y)', \"Factor Negation from Addition\", true, true);\n    newRule(menv, reduceRules, 'x-(-y)==x+y', \"Additive Inverse's Inverse\", true, true);\n    newRule(menv, reduceRules, '(-x)*y==-(x*y)', \"Factor Negation from Multiplication\", true, true);\n    newRule(menv, reduceRules, 'x*(-y)==-(x*y)', \"Factor Negation from Multiplication\", true, true);\n    newRule(menv, reduceRules, '(-x)/y==-(x/y)', \"Factor Negation from Multiplication\", true, true);\n    newRule(menv, reduceRules, 'x/(-y)==-(x/y)', \"Factor Negation from Multiplication\", true, true);\n    newRule(menv, reduceRules, '-(-x)==x', \"Additive Inverse's Inverse\", true, true);\n    newRule(menv, reduceRules, '/(/x)==x', \"Multiplicative Inverse's Inverse\", true, true);\n\n    return(reduceRules);\n}\n\nexport function defaultSumReductions(menv) {\n    var sumReductions = new Array();\n\n    newRule(menv, sumReductions, 'a+0==a', 'Simplify Addition by Zero', true, true);\n    newRule(menv, sumReductions, '0+a==a', 'Simplify Addition by Zero', true, true);\n    newRule(menv, sumReductions, 'a-a==0', 'Cancel Additive Inverses', true, true);\n    newRule(menv, sumReductions, 'a+-a==0', 'Cancel Additive Inverses', true, true);\n    newRule(menv, sumReductions, '-a+a==0', 'Cancel Additive Inverses', true, true);\n    newRule(menv, sumReductions, 'a*b+-a*b==0', 'Cancel Additive Inverses', true, true);\n    newRule(menv, sumReductions, '-a*b+a*b==0', 'Cancel Additive Inverses', true, true);\n    newRule(menv, sumReductions, 'a*(b+c)==a*b+a*c', 'Expand Products by Distributing', true, true);\n    newRule(menv, sumReductions, '(a+b)*c==a*c+b*c', 'Expand Products by Distributing', true, true);\n    newRule(menv, sumReductions, 'a*(b-c)==a*b-a*c', 'Expand Products by Distributing', true, true);\n    newRule(menv, sumReductions, '(a-b)*c==a*c-b*c', 'Expand Products by Distributing', true, true);\n\n    return(sumReductions);\n}\n\nexport function defaultProductReductions(menv) {\n    var productReductions = new Array();\n\n    newRule(menv, productReductions, '0*a==0', 'Simplify Multiplication by Zero', true, true);\n    newRule(menv, productReductions, 'a*0==0', 'Simplify Multiplication by Zero', true, true);\n    newRule(menv, productReductions, '1*a==a', 'Simplify Multiplication by One', true, true);\n    newRule(menv, productReductions, 'a*1==a', 'Simplify Multiplication by One', true, true);\n    newRule(menv, productReductions, 'a/a==1', 'Cancel Multiplicative Inverses', true, true);\n    newRule(menv, productReductions, 'a*/a==1', 'Cancel Multiplicative Inverses', true, true);\n    newRule(menv, productReductions, '/a*a==1', 'Cancel Multiplicative Inverses', true, true);\n    newRule(menv, productReductions, '(a*b)/(a*c)==b/c', 'Cancel Common Factors', true,true);\n    newRule(menv, productReductions, 'a^m/a^n==a^(m-n)', 'Cancel Common Factors', true,true);\n    newRule(menv, productReductions, '(a^m*b)/(a^n*c)==(a^(m-n)*b)/c', 'Cancel Common Factors', true,true);\n    newRule(menv, productReductions, 'a*a==a^2', 'Write Products of Common Terms as Powers', true, true);\n    newRule(menv, productReductions, 'a*a^n==a^(n+1)', 'Write Products of Common Terms as Powers', true, true);\n    newRule(menv, productReductions, 'a^n*a==a^(n+1)', 'Write Products of Common Terms as Powers', true, true);\n    newRule(menv, productReductions, 'a^m*a^n==a^(m+n)', 'Write Products of Common Terms as Powers', true, true);\n    newRule(menv, productReductions, '(a^-m*b)/c==b/(a^m*c)', 'Rewrite Using Positive Powers', true,true);\n    newRule(menv, productReductions, '(b*a^-m)/c==b/(a^m*c)', 'Rewrite Using Positive Powers', true,true);\n    newRule(menv, productReductions, 'b/(a^-m*c)==(a^m*b)/c', 'Rewrite Using Positive Powers', true,true);\n    newRule(menv, productReductions, 'b/(c*a^-m)==(a^m*b)/c', 'Rewrite Using Positive Powers', true,true);\n\n    return (productReductions);\n  }","/*!\n * BTM JavaScript Library v@VERSION\n * https://github.com/dbrianwalton/BTM\n *\n * Copyright D. Brian Walton\n * Released under the MIT license (https://opensource.org/licenses/MIT)\n *\n * Date: @DATE\n */\n\nimport { MENV, exprValue } from \"./BTM_root.js\"\nimport { findMatchRules } from \"./reductions.js\"\n\nexport class MathObject {\n    constructor(menv) {\n        this.menv = menv;\n\n        this.select = false;\n        this.parent = null;\n        this.inputs = [];\n        this.valueType = exprValue.undef;\n        this.context = undefined;\n    }\n    \n    // Method to *evaluate* the object.\n    // - Return undefined\n    value(bindings) {\n    }\n    \n    // Update context setting\n    setContext(context) {\n        this.context = context;\n        // Update context on inputs.\n        for (var i in this.inputs) {\n            this.inputs[i].setContext(context);\n        }\n    }\n\n    // When the parser throws an error, need to record it.\n    setParsingError(errorString) {\n        this.parseError = errorString;\n    }\n\n    // Errors from parsing. Check all possible children (recursively)\n    hasParsingError() {\n        var retValue = false,\n            i = 0;\n        if (this.parseError) {\n            retValue = true;\n        }\n\n        while (!retValue && i < this.inputs.length) {\n            // Check for reductions on inputs.\n            retValue = this.inputs[i].hasParsingError();\n            i++;\n        }\n        return retValue;\n    }\n    \n    // Errors from parsing. Find the *first* error in the parsing process.\n    getParsingError() {\n        var errString = this.parseError;\n        var i=0;\n        while (!errString && i < this.inputs.length) {\n            errString = this.inputs[i].getParsingError();\n        }\n        return (errString);\n    }\n    \n    // Method to generate the expression as input-style string.\n    toString(elementOnly) {\n        if (typeof elementOnly == 'undefined') {\n            elementOnly = false;\n        }\n        var theStr = '';\n        return(theStr);\n    }\n    \n    // Method to generate the expression using presentation-style (LaTeX)\n    // - showSelect is so that part of the expression can be highlighted\n    toTeX(showSelect) {\n        if (typeof showSelect == 'undefined') {\n            showSelect = false;\n        }\n        return(this.toString());\n    }\n\n    // Method to represent the expression using MathML\n    toMathML() {\n        return(\"<mi>\" + this.toString() + \"</mi>\");\n    }\n    \n    // Return an array containing all tested equivalent strings.\n    allStringEquivs() {\n        return([]);\n    }\n    \n    // To convert binary tree structure to n-ary tree for supported operations (+ and *)\n    // Most things can't flatten. Return a copy.\n    flatten() {\n        return this.copy();\n    }\n    \n    // Test if the expression evaluates to a constant.\n    isConstant() {\n        var retValue = false;\n        return(retValue);\n    }\n    \n    // Test if the expression evaluates to a constant.\n    isExpression() {\n        var retValue = false;\n        return(retValue);\n    }\n\n}\n\nexport class expression extends MathObject {\n  constructor(menv) {\n        super(menv);\n        this.select = false;\n        this.parent = null;\n        this.inputs = [];\n        this.valueType = exprValue.numeric;\n    }\n\n    // Method to *evaluate* the value of the expression using given symbol bindings.\n    // - Return native Number value\n    value(bindings) {\n        return(this.evaluate(bindings));\n    }\n\n    // When the parser throws an error, need to record it.\n    setParsingError(errorString) {\n        this.parseError = errorString;\n    }\n\n    // Errors from parsing. Check all possible children (recursively)\n    hasParsingError() {\n        var retValue = false,\n            i = 0;\n        if (this.parseError) {\n            retValue = true;\n        }\n\n        while (!retValue && i < this.inputs.length) {\n            // Check for reductions on inputs.\n            retValue = this.inputs[i].hasParsingError();\n            i++;\n        }\n        return retValue;\n    }\n\n    // Errors from parsing. Find the *first* error in the parsing process.\n    getParsingError() {\n        var errString = this.parseError;\n        var i=0;\n        while (!errString && i < this.inputs.length) {\n            errString = this.inputs[i].getParsingError();\n        }\n        return (errString);\n    }\n\n    // Method to generate the expression as input-style string.\n    toString(elementOnly) {\n        if (typeof elementOnly == 'undefined') {\n            elementOnly = false;\n        }\n        var theStr = '';\n        return(theStr);\n    }\n\n    // Method to generate the expression using presentation-style (LaTeX)\n    // - showSelect is so that part of the expression can be highlighted\n    toTeX(showSelect) {\n        if (typeof showSelect == 'undefined') {\n            showSelect = false;\n        }\n        return(this.toString());\n    }\n\n    // Method to represent the expression using MathML\n    toMathML() {\n        return(\"<mi>\" + this.toString() + \"</mi>\");\n    }\n\n    operateToTeX() {\n        return(this.toTeX());\n    }\n\n    treeToTeX(expand) {\n        var retStruct = {};\n        \n        retStruct.parent = (typeof this.parent === 'undefined' || this.parent === null) ? null : this.parent.operateToTeX();\n        if (typeof expand === 'undefined' || !expand) {\n            retStruct.current = this.toTeX();\n            retStruct.inputs = null;\n        } else {\n            retStruct.current = this.operateToTeX();\n            retStruct.inputs = [];\n            for (var i in this.inputs) {\n                retStruct.inputs[i] = this.inputs[i].toTeX();\n            }\n        }\n        return(retStruct);\n    }\n\n\n    // Return an array containing all tested equivalent strings.\n    allStringEquivs() {\n        return([]);\n    }\n\n    // To convert binary tree structure to n-ary tree for supported operations (+ and *)\n    // Most things can't flatten. Return a copy.\n    flatten() {\n        return this.copy();\n    }\n\n    // Create a new expression that is a copy.\n    copy() {\n        var myCopy = new expression();\n        myCopy.valueType = this.valueType;\n        myCopy.context = this.context;\n        for (var i in this.inputs) {\n            myCopy.inputs[i] = myCopy.inputs[i].copy();\n            myCopy.inputs[i].parent = myCopy;\n        }\n        return myCopy;\n    }\n\n    // When subtree only involves constants, simplify the formula to a value.\n    // Default: Look at all descendants (inputs) and simplify there.\n    simplifyConstants() {\n        for (var i in this.inputs) {\n            this.inputs[i] = this.inputs[i].simplifyConstants();\n            this.inputs[i].parent = this;\n        }\n        return(this);\n    }\n\n    // Find all dependencies (symbols) required to evaluate expression.\n    dependencies(forced) {\n        var inDeps;\n        var i, j;\n        var depArray = new Array();\n\n        var master = {};\n        if (forced != undefined) {\n            for (var i=0; i<forced.length; i++) {\n                depArray.push(forced[i]);\n                master[forced[i]] = true;\n            }\n        }\n        for (i in this.inputs) {\n            inDeps = this.inputs[i].dependencies();\n            for (j in inDeps) {\n                if (typeof master[inDeps[j]] == \"undefined\") {\n                    depArray.push(inDeps[j]);\n                    master[inDeps[j]] = true;\n                }\n            }\n        }\n\n        return(depArray);\n    }\n\n    // Method to return input at given index.\n    getInput(whichInput) {\n        var inputExpr = null;\n        if (whichInput < 0 || whichInput >= this.inputs.length) {\n            throw 'Attempt to get an undefined input expression.';\n        } else {\n            inputExpr = this.inputs[whichInput];\n        }\n        return(inputExpr);\n    }\n\n    // Test if the expression evaluates to a constant.\n    isConstant() {\n        var retValue = true;\n        for (var i in this.inputs) {\n            retValue = retValue & this.inputs[i].isConstant();\n        }\n        return(retValue);\n    }\n\n    // Evaluate the expression given the bindings to symbols.\n    evaluate(bindings) {\n        return(0);\n    }\n\n    // Create a *new* expression where a symbol is *replaced* by a bound expression\n    compose(bindings) {\n        return(new expression());\n    }\n\n    // Compare *this* expression to a given *testExpr*.\n    // *options* gives options associated with testing (e.g., relative tolerance)\n    // but also supports fixing certain bindings.\n    // Supports abstract input matching against variables using *matchInputs*\n    compare(testExpr, options, matchInputs) {\n        var isEqual = true;\n        var i, n;\n\n        if (matchInputs == undefined) {\n            matchInputs = false;\n        }\n        if (options == undefined) {\n            options = this.menv.options;\n        }\n        var knownBindings = Object.keys(options);\n        var unknownBindings = [];\n\n        var rTol = 1e-8;\n        if (typeof options.rTol !== 'undefined') {\n            rTol = options.rTol;\n            i = knownBindings.indexOf('rTol');\n            knownBindings.splice(i, 1);\n        }\n\n        var dependA = this.dependencies();\n        var dependB = testExpr.dependencies();\n\n        for (i=0; i<dependA.length; i++) {\n            if (knownBindings.indexOf(dependA[i]) < 0\n                && unknownBindings.indexOf(dependA[i]) < 0)\n            {\n                unknownBindings.push(dependA[i]);\n            }\n        }\n        for (i=0; i<dependB.length; i++) {\n            if (knownBindings.indexOf(dependB[i]) < 0\n                && unknownBindings.indexOf(dependB[i]) < 0)\n            {\n                unknownBindings.push(dependB[i]);\n            }\n        }\n\n        // Create the arrays of test points.\n        var variableList = [];\n        var testPointList = [];\n        var x, xOpt, xMin, xMax, dx, n, testPoints;\n        n = 10;\n        for (i=0; i<knownBindings.length; i++) {\n            x = knownBindings[i];\n            xOpt = options[x];\n            xMin = xOpt.min;\n            xMax = xOpt.max;\n            dx = (xMax-xMin)/n;\n            testPoints = [];\n            for (var j=0; j<n; j++) {\n                testPoints[j] = xMin+j*dx;\n            }\n            testPoints[n] = xMax;\n\n            // Add this to the list of testing arrays.\n            variableList.push(x);\n            testPointList.push(testPoints);\n        }\n        for (i=0; i<unknownBindings.length; i++) {\n            x = unknownBindings[i];\n            xMin = -2;\n            xMax = 2;\n            dx = (xMax-xMin)/n;\n            testPoints = [];\n            for (var j=0; j<n; j++) {\n                testPoints[j] = xMin+j*dx;\n            }\n            testPoints[n] = xMax;\n\n            // Add this to the list of testing arrays.\n            variableList.push(x);\n            testPointList.push(testPoints);\n        }\n\n        // Now we will proceed through all possible points.\n        // Analogy: Each variable is like one \"digit\" on an odometer.\n        // Go through full cycle of a variable's options and then advance the next variable.\n        // Use an odometer-like array that references which point from\n        // each list is being used. When the last entry reaches the end,\n        // the odometer rolls over until all entries are done.\n        var odometer = [];\n        for (i=0; i<variableList.length; i++)\n            odometer[i]=0;\n        var done = false;\n        while (!done && isEqual) {\n            var y1, y2;\n            var bindings = {};\n            for (i=0; i<variableList.length; i++) {\n                x = variableList[i];\n                bindings[x] = testPointList[i][odometer[i]];\n            }\n            y1 = this.evaluate(bindings);\n            y2 = testExpr.evaluate(bindings);\n            // Both finite? Check for relative error.\n            if (isFinite(y1) && isFinite(y2)) {\n                if (!(Math.abs(y1)<1e-12 && Math.abs(y2)<1e-12)\n                    && Math.abs(y1-y2)/Math.abs(y1)>rTol) {\n                    isEqual = false;\n                }\n                // If one is finite, other must be NaN\n                } else if ( (isFinite(y1) && !isNaN(y2))\n                            || (isFinite(y2) && !isNaN(y1)) ) {\n                    isEqual = false;\n                }\n\n                // Advance the odometer.\n                var j=0;\n                done = true; // This will only persist when the odometer is done.\n                while (j < variableList.length) {\n                    odometer[j]++;\n                    if (odometer[j] >= testPointList[j].length) {\n                        odometer[j] = 0;\n                        j++;\n                    } else {\n                        done = false;\n                        break;\n                    }\n                }\n            }\n            if (matchInputs && isEqual) {\n                var matchOp;\n                if (this.op == '+' || this.op == '-') {\n                    matchOp = '+';\n                } else if (this.op == '*' || this.op == '/') {\n                    matchOp = '*';\n                }\n                if ((matchOp=='+' && testExpr.op != '+' && testExpr.op != '-')\n                    || (matchOp=='*' && testExpr.op != '*' && testExpr.op != '/')) {\n                    isEqual = false;\n                }\n                if (isEqual) {\n                    var flatA, flatB;\n                    flatA = this.flatten();\n                    flatB = testExpr.flatten();\n                    if (flatA.inputs.length == flatB.inputs.length) {\n                    var inputMatched = [];\n                    for (i=0; i<flatA.inputs.length; i++) {\n                        inputMatched[i] = false;\n                    }\n                    // Go through each input of testExpr and see if it matches on of this inputs.\n                    for (i=0; i<flatB.inputs.length && isEqual; i++) {\n                        var matchFound = false;\n                        for (j=0; j<flatA.inputs.length && !matchFound; j++) {\n                            if (!inputMatched[j] && flatA.inputs[j].compare(flatB.inputs[i], options)) {\n                                inputMatched[j] = true;\n                                matchFound = true;\n                            }\n                        }\n                        if (!matchFound) {\n                            isEqual = false;\n                        }\n                    }\n                } else {\n                    isEqual = false;\n                }\n            }\n        }\n        return(isEqual);\n    }\n\n    // Apply reduction rules to create a reduced expression\n    reduce() {\n        var workExpr = this.simplifyConstants();\n        var matchRules;\n\n        // Check for reductions on inputs.\n        for (var i in workExpr.inputs) {\n            workExpr.inputs[i] = workExpr.inputs[i].reduce();\n        }\n        matchRules = findMatchRules(this.menv.reduceRules, workExpr, true);\n        while (matchRules.length > 0) {\n            workExpr = this.menv.parse(matchRules[0].subStr, this.context);\n            matchRules = findMatchRules(this.menv.reduceRules, workExpr, true);\n        }\n        return workExpr;\n    }\n\n    \n    derivative(ivar, varList) {\n        return(new scalar_expr(0));\n    }\n\n    /*\n        The match method is designed to compare \"this\" expression\n        to the given \"expr\" expression and see if it is consistent with\n        the current bindings. The bindings will be an object where\n        variables in \"this\" are assigned to strings representing expressions.\n        If there is a mismatch, return \"null\" and the matching process should terminate.\n\n        Overrides:\n            - numbers, to deal with scalar formula that simplify\n            - variables, which can match arbitrary expressions.\n            - indexed expressions might need a special method.\n            - multiop, where should see if a variable can match a subcollection of inputs.\n    */\n    match(expr, bindings) {\n        var retValue = null;\n        if (this.type == expr.type && this.operateToTeX() == expr.operateToTeX()) {\n            retValue = bindings;\n            for (var i=0; i<this.inputs.length; i++) {\n                if (retValue !== null) {\n                    retValue = this.inputs[i].match(expr.inputs[i], retValue);\n                }\n            }\n        }\n        return(retValue);\n    }\n\n    inputSubst(origExpr, subExpr) {\n        var i = this.inputs.indexOf(origExpr);\n        if (i >= 0) {\n            this.inputs[i] = subExpr;\n            if (subExpr !== undefined) {\n                subExpr.parent = this;\n            }\n        }\n    }\n}","/*!\n * BTM JavaScript Library v@VERSION\n * https://github.com/dbrianwalton/BTM\n *\n * Copyright D. Brian Walton\n * Released under the MIT license (https://opensource.org/licenses/MIT)\n *\n * Date: @DATE\n */\n\n/* *******************************\n** Define a generic class to work numbers\n******************************* */\n\nexport class real_number {\n    constructor(a) {\n      if (typeof a === 'number' || a instanceof Number) {\n        this.number = a;\n      } else if (a instanceof real_number) {\n        this.number = a.number;\n      }\n    }\n\n    // Return a numerical value of the rational expression.\n    value() {\n        return this.number;\n    }\n    \n    // Real numbers have no natural simplification, but declaring the method.\n    simplify() {\n    }\n\n    equal(other) {\n      if (typeof other === 'number') {\n        other = new real_number(other);\n      }\n        return (this.value()==other.value());\n    }\n\n    // Add numbers.\n    add(other) {\n      if (typeof other === 'number') {\n        other = new real_number(other);\n      }\n        var sum = new real_number(this.number + other.value());\n        return(sum);\n    }\n\n    // Subtract this - other\n    subtract(other) {\n      if (typeof other === 'number') {\n        other = new real_number(other);\n      }\n        var sum = new real_number(this.number - other.value());\n        return(sum);\n    }\n\n    // Multiply this rational by another rational number and create new object.\n    multiply(other) {\n      if (typeof other === 'number') {\n        other = new real_number(other);\n      }\n        var product = new real_number(this.number * other.value());\n        return(product);\n    }\n\n    // Divide this rational by another rational number and create new object.\n    divide(other) {\n      if (typeof other === 'number') {\n        other = new real_number(other);\n      }\n        var product;\n        if (other.value != 0) {\n            product = new real_number(this.number / other.value());\n        } else {\n            product = new real_number(NaN);\n        }\n        return(product);\n    }\n\n    // Additive Inverse\n    addInverse() {\n        var inverse = new real_number(-this.number);\n        return(inverse);\n    }\n\n    // Multiplicative Inverse\n    multInverse() {\n        var inverse;\n        if (this.number != 0) {\n            inverse = new real_number(this.number);\n        } else {\n            inverse = new real_number(NaN);\n        }\n        return(inverse);\n    }\n\n    toString(leadSign) {\n        if (typeof leadSign == 'undefined') {\n            leadSign = false;\n        }\n        var str = (leadSign && this.number>0) ? '+' : '';\n        if (isNaN(this.number)) {\n            str = 'NaN';\n        } else {\n            str = str + Number(this.number.toFixed(10));\n        }\n  \n        return(str);\n    }\n  \n    // Format the rational number as TeX string.\n    toTeX(leadSign) {\n        if (typeof leadSign == 'undefined') {\n            leadSign = false;\n        }\n        var str = (leadSign && this.number>0) ? '+' : '';\n        if (isNaN(this.number)) {\n            str = '\\\\mathrm{NaN}';\n        } else {\n            str = str + Number(this.toString(leadSign));\n        }\n        return(str);\n    }\n\n    // Format as a root MathML element.\n    toMathML(leadSign) {\n        return(\"<cn>\" + this.toString() + \"</cn>\");\n    }\n}\n\n\n\n\n\n \n\n\n\n","/*!\n * BTM JavaScript Library v@VERSION\n * https://github.com/dbrianwalton/BTM\n *\n * Copyright D. Brian Walton\n * Released under the MIT license (https://opensource.org/licenses/MIT)\n *\n * Date: @DATE\n */\n\n/* *******************************\n** Define a class to work with rational numbers\n******************************* */\n\nimport { real_number } from \"./real_number.js\";\n\n/* Private utility commands. */\n  \nfunction isInt(x) {\n    var retValue = false;\n    if (Number.isInteger === undefined) {\n    retValue = (x == Math.floor(x));\n    } else {\n    retValue = Number.isInteger(x);\n    }\n    return retValue;\n}\n\n\n // Implement Euclid's algorithm.\n export function findGCD(a,b) {\n    var c;\n    a = Math.abs(a);\n    b = Math.abs(b);\n    if (a < b) {\n        c=a; a=b; b=c;\n    }\n\n    if (b == 0)\n        return 0;\n\n    // In this loop, we always have a > b.\n    while (b > 0) {\n        c = a % b;\n        a = b;\n        b = c;\n    }\n    return a;\n}\n\nexport class rational_number extends real_number {\n    constructor(p,q) {\n        if (q == undefined) {\n            super(p);\n            this.p = p;\n            this.q = 1;\n        } else {\n            super(p/q);\n            if (q == 0) {\n                this.p = Math.sqrt(-1);\n                this.q = 1;\n            } else if (p == 0) {\n                this.p = 0;\n                this.q = 1;\n            } else {\n                if (q < 0) {\n                  this.p = -p;\n                  this.q = -q;\n                } else {\n                  this.p = p;\n                  this.q = q;\n                }\n                this.simplify();\n            }\n        }\n    }\n\n    // Return a numerical value of the rational expression.\n    value() {\n        return (this.p/this.q);\n    }\n    \n    // Use Euclid's algorithm to find the gcd, then reduce\n    simplify() {\n        var a;\n\n        // Don't simplify if not ratio of integers.\n        if (this.p % 1 != 0 || this.q % 1 != 0) {\n        return;\n        }\n        a = findGCD(this.p, this.q);\n        this.p /= a;\n        this.q /= a;\n    }\n\n    equal(other) {\n        if (other instanceof rational_number) {\n            return (this.p.valueOf()==other.p.valueOf()\n                    && this.q.valueOf() == other.q.valueOf());\n        } else {\n            return (this.value()==other.value());\n        }\n    }\n\n    // Add to this rational another rational number and create new object.\n    add(other) {\n        var sum;\n        if (other instanceof rational_number) {\n        sum = new rational_number(this.p*other.q+other.p*this.q, this.q*other.q);\n        } else if (isInt(other)) {\n        sum = new rational_number(this.p+other*this.q, this.q);\n        } else {\n        sum = new real_number(this.value() + other);\n        }\n        return(sum);\n    }\n\n    // Subtract from this rational another rational number and create new object.\n    subtract(other) {\n        var sum;\n        if (other instanceof rational_number) {\n            sum = new rational_number(this.p*other.q-other.p*this.q, this.q*other.q);\n        } else if (isInt(other)) {\n            sum = new rational_number(this.p-other*this.q, this.q);\n        } else {\n            sum = new real_number(this.value() - other);\n        }\n        return(sum);\n    }\n\n    // Multiply this rational by another rational number and create new object.\n    multiply(other) {\n        var product;\n        if (other instanceof rational_number) {\n            product = new rational_number(this.p*other.p, this.q*other.q);\n        } else if (isInt(other)) {\n            product = new rational_number(this.p*other, this.q);\n        } else {\n            product = new real_number(this.value() * other);\n        }\n\n        return(product);\n    }\n\n    // Divide this rational by another rational number and create new object.\n    divide(other) {\n        var product;\n        if (other instanceof rational_number) {\n            product = new rational_number(this.p*other.q, this.q*other.p);\n        } else if (isInt(other)) {\n            product = new rational_number(this.p, this.q*other);\n        } else {\n            product = new real_number(this.value() / other);\n        }\n\n        return(product);\n    }\n\n    // Additive Inverse\n    addInverse() {\n        var inverse = new rational_number(-this.p, this.q);\n        return(inverse);\n    }\n\n    // Multiplicative Inverse\n    multInverse() {\n        var inverse;\n        if (this.p != 0) {\n            inverse = new rational_number(this.q, this.p);\n        } else {\n            inverse = new real_number(NaN);\n        }\n        return(inverse);\n    }\n\n    // Format the rational number as string.\n    toString(leadSign) {\n        if (typeof leadSign == 'undefined') {\n            leadSign = false;\n        }\n        var str = (leadSign && this.p>0) ? '+' : '';\n        if (isNaN(this.p)) {\n            str = 'NaN';\n        } else if (this.q == 1) {\n            str = str + this.p;\n        } else {\n            str = str + this.p + '/' + this.q;\n        }\n\n        return(str);\n    }\n\n    // Format the rational number as TeX string.\n    toTeX(leadSign) {\n        if (typeof leadSign == 'undefined') {\n            leadSign = false;\n        }\n        var str = (leadSign && this.p>0) ? '+' : '';\n        if (isNaN(this.p)) {\n            str = '\\\\mathrm{NaN}';\n        } else if (this.q == 1) {\n            str = str + this.p;\n        } else {\n            if (this.p < 0) {\n                str = '-\\\\frac{' + -this.p + '}{' + this.q + '}';\n            } else {\n                str = str + '\\\\frac{' + this.p + '}{' + this.q + '}';\n            }\n        }\n\n        return(str);\n    }\n\n    toMathML() {\n        if (typeof leadSign == 'undefined') {\n            leadSign = false;\n        }\n        var opAStr = \"<cn>\" + this.p + \"</cn>\",\n            opBStr = \"<cn>\" + this.q + \"</cn>\";\n\n        return(\"<cn>\" + this.toString() + \"</cn>\");\n\n        if (isNaN(this.p)) {\n            str = \"<cn>?</cn>\";\n        } else if (this.q == 1) {\n            str = opAStr;\n        } else {\n            str = \"<apply><divide/>\"+opAStr+opBStr+\"</apply>\";\n        }\n    }\n}\n\n\n\n\n\n \n\n\n\n","/*!\n * BTM JavaScript Library v@VERSION\n * https://github.com/dbrianwalton/BTM\n *\n * Copyright D. Brian Walton\n * Released under the MIT license (https://opensource.org/licenses/MIT)\n *\n * Date: @DATE\n */\n\n/* ***************************************************\n* Define the Scalar Expression -- a numerical value\n* *************************************************** */\n\nimport { expression } from \"./expression.js\"\nimport { real_number } from \"./real_number.js\"\nimport { rational_number } from \"./rational_number.js\"\nimport { exprType } from \"./BTM_root.js\"\n\nexport class scalar_expr extends expression {\n    constructor(menv, number) {\n        super(menv);\n        this.type = exprType.number;\n        if (typeof number === \"number\" ||\n                number instanceof Number) {\n            if (Math.floor(number)==number) {\n                this.number = new rational_number(number, 1);\n            } else {\n                this.number = new real_number(number);\n            }\n        } else if (number instanceof real_number) {\n                this.number = number;\n        } else if (number instanceof scalar_expr) {\n            this.number = number.number;\n        } else {\n            console.log(\"Trying to instantiate a scalar_expr with a non-number object: \" + number);\n        }\n        this.context = \"number\";\n    }\n\n    // Parsed representation.\n    toString(elementOnly) {\n        if (typeof elementOnly == 'undefined') {\n            elementOnly = false;\n        }\n        return(this.number.toString());\n    }\n    \n    // Display representation.\n    toTeX(showSelect) {\n        if (typeof showSelect == 'undefined') {\n            showSelect = false;\n        }\n        var word = this.number.toTeX();\n        if (showSelect && this.select) {\n            word = \"{\\\\color{red}\" + word + \"}\";\n        }\n        return(word);\n    }\n    \n    // MathML representation.\n    toMathML() {\n        return(\"<cn>\" + this.toString() + \"</cn>\");\n    }\n    \n    // Return an array containing all tested equivalent strings.\n    allStringEquivs() {\n        return([this.toString()]);\n    }\n    \n    // Test if represents constant value.\n    isConstant() {\n        /*\n        This could just use expression.prototype.constant, but use this\n        because it ALWAYS is true for scalar_expr and does not need a check\n        */\n        return(true);\n    }\n    \n    // Combine constants where possible\n    simplifyConstants() {\n        var retValue;\n        if (!this.menv.options.negativeNumbers && this.number.p < 0) {\n            var theNumber = this.number.multiply(-1);\n            retValue = new unop_expr(this.menv, '-', new scalar_expr(this.menv, theNumber));\n        } else {\n            retValue = this;\n        }\n        return(retValue);\n    }\n    \n    value() {\n        return(this.number.value());\n    }\n\n    evaluate(bindings) {\n        return(this.value());\n    }\n    \n    copy() {\n        return(new scalar_expr(this.menv, this.number));\n    }\n    \n    compose(bindings) {\n        return(new scalar_expr(this.menv, this.number));\n    }\n    \n    derivative(ivar, varList) {\n        return(new scalar_expr(this.menv, 0));\n    }\n    \n    /*\n        See expressions.prototype.match for explanation.\n    \n        A scalar might match a constant formula.\n    */\n    match(expr, bindings) {\n        var retValue = null,\n            testExpr = expr;\n    \n        // Special named constants can not match expressions.\n        if (expr.isConstant() && expr.type != exprType.number) {\n            var testExpr = expr.copy().simplifyConstants();\n            if (this.toString() === testExpr.toString()) {\n              retValue = bindings;\n            }\n        }\n        else if (testExpr.type == exprType.number\n                && this.number.equal(testExpr.number)) {\n            retValue = bindings;\n        }\n    \n        return(retValue);\n    }    \n}\n\n","/*!\n * BTM JavaScript Library v@VERSION\n * https://github.com/dbrianwalton/BTM\n *\n * Copyright D. Brian Walton\n * Released under the MIT license (https://opensource.org/licenses/MIT)\n *\n * Date: @DATE\n */\n\n/* ***************************************************\n* Define the Variable Expression -- a value defined by a name\n* *************************************************** */\nimport { expression } from \"./expression.js\"\nimport { scalar_expr } from \"./scalar_expr.js\"\nimport { exprType, exprValue } from \"./BTM_root.js\"\n\nexport class variable_expr extends expression {\n    constructor(menv, name) {\n        super(menv);\n        this.type = exprType.variable;\n        this.name = name;\n\n        // Count how many derivatives.\n        var primePos = name.indexOf(\"'\");\n        this.derivs = 0;\n        if (primePos > 0) {\n            this.derivs = name.slice(primePos).length;\n        }\n\n        this.isConst = false;\n        this.isSpecial = false;\n        switch(this.name) {\n            case 'e':\n            case 'pi':\n            case 'dne':\n            case 'inf':\n                this.isConst = true;\n                this.isSpecial = true;\n                break;\n        }\n    }\n\n    toString(elementOnly) {\n        if (typeof elementOnly == 'undefined') {\n            elementOnly = false;\n        }\n        return(this.name);\n    }\n\n    // Return an array containing all tested equivalent strings.\n    allStringEquivs() {\n        return([this.toString()]);\n    }\n\n    toTeX(showSelect) {\n        if (typeof showSelect == 'undefined') {\n            showSelect = false;\n        }\n        var str = this.toString();\n\n        switch (this.name) {\n            case 'alpha':\n            case 'beta':\n            case 'gamma':\n            case 'delta':\n            case 'epsilon':\n            case 'zeta':\n            case 'eta':\n            case 'theta':\n            case 'kappa':\n            case 'lambda':\n            case 'mu':\n            case 'nu':\n            case 'xi':\n            case 'pi':\n            case 'rho':\n            case 'sigma':\n            case 'tau':\n            case 'upsilon':\n            case 'phi':\n            case 'chi':\n            case 'psi':\n            case 'omega':\n            case 'Gamma':\n            case 'Delta':\n            case 'Theta':\n            case 'Lambda':\n            case 'Xi':\n            case 'Pi':\n            case 'Sigma':\n            case 'Upsilon':\n            case 'Phi':\n            case 'Psi':\n            case 'Omega':\n                str = '\\\\' + this.name;\n                break;\n            case 'inf':\n                str = '\\\\infty';\n                break;\n            default:\n                if (this.isSpecial) {\n                    str = '\\\\mathrm{' + this.name + '}';\n                }\n                break;\n        }\n        if (this.name.indexOf(\"input\")==0) {\n            str = \"\\\\boxed{\\\\dots?^{\" + this.name.slice(5) + \"}}\";\n        }\n\n        if (showSelect && this.select) {\n            str = \"{\\\\color{red}\" + str + \"}\";\n        }\n        return(str);\n    }\n\n    dependencies(forced) {\n        var depArray = new Array();\n        if (forced != undefined) {\n            for (var i=0; i<forced.length; i++) {\n                depArray.push(forced[i]);\n            }\n        }\n        if (!this.isConst && depArray.indexOf(this.name) < 0) {\n            depArray.push(this.name);\n        }\n        return(depArray);\n    }\n\n    /*\n        A variable is constant only if referring to mathematical constants (e, pi)\n    */\n    isConstant() {\n        return(this.isConst);\n    }\n\n    evaluate(bindings) {\n        var retVal;\n\n        if (bindings[this.name] == undefined) {\n            switch(this.name) {\n                case 'e':\n                    retVal = Math.E;\n                    break;\n                case 'pi':\n                    retVal = Math.PI;\n                    break;\n                case 'inf':\n                    retVal = Infinity;\n                    break;\n                case 'dne':\n                    retVal = Number.NaN;\n                    break;\n                default:\n                    console.log(\"Variable evaluated without binding.\")\n                    break;\n            }\n        } else {\n            if (typeof bindings[this.name].value === 'function') {\n                retVal = bindings[this.name].value();\n            } else {\n                retVal = bindings[this.name];\n            }\n        }\n\n        return(retVal);\n    }\n\n    copy() {\n        return(new variable_expr(this.menv, this.name));\n    }\n\n    compose(bindings) {\n        var retVal;\n\n        if (bindings[this.name] == undefined) {\n            retVal = new variable_expr(this.menv, this.name);\n        } else {\n            retVal = bindings[this.name];\n        }\n\n        return(retVal);\n    }\n\n    derivative(ivar, varList) {\n        var retVal;\n        var ivarName = (typeof ivar == 'string') ? ivar : ivar.name;\n\n        if (this.name === ivarName) {\n            retVal = new scalar_expr(this.menv, 1);\n\n        // If either a constant or another independent variable, deriv=0\n        } else if (this.isConst || varList && varList[this.name] != undefined) {\n            retVal = new scalar_expr(this.menv, 0);\n\n        // Presuming other variables are dependent variables.\n        } else  {\n            retVal = new variable_expr(this.menv, this.name+\"'\");\n        }\n        return(retVal);\n    }\n\n    /*\n        See expressions.prototype.match for explanation.\n\n        A variable can match any expression. But we need to check\n        if the variable has already matched an expression. If so,\n        it must be the same again.\n    */\n    match(expr, bindings) {\n        var retValue = null;\n\n        // Special named constants can not match expressions.\n        if (this.isConst) {\n            if (expr.toString() === this.name) {\n                retValue = bindings;\n            }\n\n        // If never previously assigned, can match any expression.\n        } else if (bindings != null && bindings[this.name] == undefined && expr.valueType == exprValue.numeric) {\n            retValue = bindings;\n            retValue[this.name] = expr.toString();\n        } else if (bindings != null && bindings[this.name] == expr.toString()) {\n            retValue = bindings;\n        }\n\n        return(retValue);\n    }\n}\n\n    /* ***************************************************\n    * Define the Index Expression -- a reference into a list\n    * *************************************************** */\n\nexport class index_expr {\n    \n    constructor(name, index) {\n        this.type = exprType.variable;\n        this.name = name;\n        this.select = false;\n        this.boundName = \"[]\"+name;\n        this.parent = null;\n        this.index = index;\n        var depArray = index.dependencies();\n        if (depArray.length > 1) {\n            alert(\"An array reference can only have one index variable.\");\n        } else {\n            this.k = depArray[0];\n        }\n    }\n\n    toString(elementOnly) {\n        if (typeof elementOnly == 'undefined') {\n            elementOnly = false;\n        }\n        return(this.name + \"[\" + this.index.toString() + \"]\");\n    }\n\n    toTeX(showSelect) {\n        if (typeof showSelect == 'undefined') {\n            showSelect = false;\n        }\n        word = this.name + \"_{\" + this.index.toString() + \"}\";\n        if (showSelect && this.select) {\n            word = \"{\\\\color{red}\" + word + \"}\";\n        }\n        return(word);\n    }\n\n    toMathML() {\n        return(\"<apply><selector/><ci type=\\\"vector\\\">\" + this.name + \"</ci>\" + this.index.toString() + \"</apply>\");\n    }\n\n    dependencies(forced) {\n        var depArray = new Array();\n        if (forced != undefined) {\n            for (var i=0; i<forced.length; i++) {\n                depArray.push(forced[i]);\n            }\n        }\n        switch(this.name) {\n            default:\n                depArray.push(\"row\");\n                depArray.push(this.boundName);\n                break;\n        }\n        return(depArray);\n    }\n\n    evaluate(bindings) {\n        var retVal;\n\n        if (bindings[this.boundName] == undefined) {\n            switch(this.name) {\n                default:\n                    retVal = undefined;\n                    break;\n            }\n        } else {\n            var tmpBind = {};\n            if (this.k != undefined) {\n                tmpBind[this.k] = bindings[\"row\"];\n            }\n            var i = this.index.evaluate(tmpBind)-1;\n            if (i >= 0 && i<bindings[this.boundName].length) {\n                retVal = bindings[this.boundName][i];\n            }\n        }\n\n        return(retVal);\n    }\n}","/*!\n * BTM JavaScript Library v@VERSION\n * https://github.com/dbrianwalton/BTM\n *\n * Copyright D. Brian Walton\n * Released under the MIT license (https://opensource.org/licenses/MIT)\n *\n * Date: @DATE\n */\n\n/* ***************************************************\n* Define the Binary Expression -- defined by an operator and two inputs.\n* *************************************************** */\n\nimport { MENV, opPrec, exprType, exprValue } from \"./BTM_root.js\"\nimport { expression } from \"./expression.js\"\nimport { scalar_expr } from \"./scalar_expr.js\"\nimport { unop_expr } from \"./unop_expr.js\"\n\nexport class binop_expr extends expression {\n    constructor(menv, op, inputA, inputB) {\n        super(menv);\n        this.type = exprType.binop;\n        this.op = op;\n        if (typeof inputA == 'undefined')\n            inputA = new expression(this.menv);\n        if (typeof inputB == 'undefined')\n            inputB = new expression(this.menv);\n        this.inputs = [inputA, inputB];\n            inputA.parent = this;\n            inputB.parent = this;\n\n        switch (op) {\n            case '+':\n            case '-':\n                this.prec = opPrec.addsub;\n                break;\n            case '*':\n            case '/':\n                this.prec = opPrec.multdiv;\n                break;\n            case '^':\n                this.prec = opPrec.power;\n                break;\n            case '&':\n                this.prec = opPrec.conj;\n                this.valueType = exprValue.bool;\n                break;\n            case '$':\n                this.prec = opPrec.disj;\n                this.valueType = exprValue.bool;\n                break;\n            case '=':\n                this.prec = opPrec.equal;\n                this.valueType = exprValue.bool;\n                break;\n            default:\n                console.log(\"Unknown binary operator: '\"+op+\"'.\");\n                break;\n        }\n    }\n\n    toString() {\n        var theStr;\n        var opAStr, opBStr;\n        var isError = false;\n\n        if (typeof this.inputs[0] == 'undefined') {\n            opAStr = '?';\n            isError = true;\n        } else {\n            opAStr = this.inputs[0].toString();\n            if ((this.inputs[0].type >= exprType.unop\n                    && this.inputs[0].prec < this.prec)\n                || (this.inputs[0].type == exprType.number\n                    && opAStr.indexOf(\"/\") >= 0\n                    && opPrec.multdiv <= this.prec)\n                ) \n            {\n                opAStr = '(' + opAStr + ')';\n            }\n        }\n        if (typeof this.inputs[1] == 'undefined') {\n            opBStr = '?';\n            isError = true;\n        } else {\n            opBStr = this.inputs[1].toString();\n            if ((this.inputs[1].type >= exprType.unop\n                    && this.inputs[1].prec <= this.prec)\n                || (this.inputs[1].type == exprType.number\n                    && opBStr.indexOf(\"/\") >= 0\n                    && opPrec.multdiv <= this.prec)\n                ) \n            {\n                opBStr = '(' + opBStr + ')';\n            }\n        }\n\n        var theOp = this.op;\n        if (theOp == '|') {\n            theOp = ' $ ';\n        }\n\n        theStr = opAStr + theOp + opBStr;\n        return(theStr);\n    }\n\n    // Return an array containing all tested equivalent strings.\n    allStringEquivs() {\n        var allInputsA = this.inputs[0].allStringEquivs(),\n            allInputsB = this.inputs[1].allStringEquivs();\n\n        var retValue = [];\n\n        var theOp = this.op;\n        if (theOp == '|') {\n            theOp = ' $ ';\n        }\n\n        for (var i in allInputsA) {\n            for (var j in allInputsB) {\n                opAStr = allInputsA[i];\n                if (this.inputs[0].type >= exprType.unop && this.inputs[0].prec < this.prec) {\n                    opAStr = '(' + opAStr + ')';\n                }\n                opBStr = allInputsB[j];\n                if (this.inputs[1].type >= exprType.unop && this.inputs[1].prec <= this.prec) {\n                    opBStr = '(' + opBStr + ')';\n                }\n\n                retValue.push(opAStr + theOp + opBStr);\n\n                if (this.op == '+' || this.op == '*' || this.op == '&' || this.op == '$') {\n                    opBStr = allInputsB[j];\n                    if (this.inputs[1].type >= exprType.unop && this.inputs[1].prec < this.prec) {\n                        opBStr = '(' + opBStr + ')';\n                    }\n                    opAStr = allInputsA[i];\n                    if (this.inputs[0].type >= exprType.unop && this.inputs[0].prec <= this.prec) {\n                        opAStr = '(' + opAStr + ')';\n                    }\n                    retValue.push(opBStr + theOp + opAStr);\n                }\n            }\n        }\n\n        return(retValue);\n    }\n\n    toTeX(showSelect) {\n        var theStr;\n        var theOp;\n        var opAStr, opBStr;\n\n        if (typeof showSelect == 'undefined') {\n            showSelect = false;\n        }\n\n        if (typeof this.inputs[0] == 'undefined') {\n            opAStr = '?';\n        } else {\n            opAStr = this.inputs[0].toTeX(showSelect);\n        }\n        if (typeof this.inputs[1] == 'undefined') {\n            opBStr = '?';\n        } else {\n            opBStr = this.inputs[1].toTeX(showSelect);\n        }\n        theOp = this.op;\n        if (showSelect && this.select) {\n            switch (theOp) {\n                case '*':\n                    theOp = '\\\\cdot ';\n                    break;\n                case '/':\n                    theOp = '\\\\div ';\n                    break;\n                case '^':\n                    theOp = '\\\\wedge ';\n                    break;\n                case '|':\n                    theOp = '\\\\hbox{ or }';\n                    break;\n                case '$':\n                    theOp = '\\\\hbox{ or }';\n                    break;\n                case '&':\n                    theOp = '\\\\hbox{ and }';\n                    break;\n            }\n        } else {\n            switch (theOp) {\n                case '*':\n                    if (this.inputs[1] && this.inputs[1].type == exprType.number) {\n                        theOp = '\\\\cdot ';\n                    } else if (this.inputs[1] && this.inputs[1].type == exprType.binop\n                                && this.inputs[1].op=='^' && this.inputs[1].inputs[0].type==exprType.number) {\n                        theOp = '\\\\cdot ';\n                    } else {\n                        theOp = ' ';\n                    }\n                    break;\n                case '|':\n                    theOp = '\\\\hbox{ or }';\n                    break;\n                case '$':\n                    theOp = '\\\\hbox{ or }';\n                    break;\n                case '&':\n                    theOp = '\\\\hbox{ and }';\n                    break;\n            }\n        }\n        if (theOp == '/') {\n            theStr = '\\\\frac{' + opAStr + '}{' + opBStr + '}';\n        } else if (theOp == '^') {\n            if (this.inputs[0] && this.inputs[0].type >= exprType.fcn) {\n                theStr = '\\\\left(' + opAStr + '\\\\right)';\n            } else {\n                theStr = opAStr;\n            }\n            theStr += theOp + '{' + opBStr + '}';\n        } else {\n            var argStrL='', argStrR='', opStrL='', opStrR='';\n\n            if (showSelect && this.select) {\n                argStrL = '{\\\\color{blue}';\n                argStrR = '}';\n                opStrL = '{\\\\color{red}';\n                opStrR = '}';\n            }\n            if (this.inputs[0] && this.inputs[0].type >= exprType.unop && this.inputs[0].prec < this.prec) {\n                theStr = '\\\\left(' + argStrL + opAStr + argStrR + '\\\\right)';\n            } else {\n                theStr = argStrL + opAStr + argStrR;\n            }\n            theStr += opStrL + theOp + opStrR;\n            if (this.inputs[1] && this.inputs[1].type >= exprType.unop && this.inputs[1].prec <= this.prec) {\n                theStr += '\\\\left(' + argStrL + opBStr + argStrR + '\\\\right)';\n            } else {\n                theStr += argStrL + opBStr + argStrR;\n            }\n        }\n        if (showSelect && this.select) {\n          theStr = \"{\\\\color{red}\\\\boxed{\" + theStr + \"}}\";\n        }\n        theStr = theStr.replace(/\\+-/g, '-');\n        return(theStr);\n    }\n\n    toMathML() {\n        var theStr;\n        var theOp;\n        var opAStr, opBStr;\n\n        if (typeof this.inputs[0] == 'undefined') {\n            opAStr = '?';\n        } else {\n            opAStr = this.inputs[0].toMathML();\n        }\n        if (typeof this.inputs[1] == 'undefined') {\n            opBStr = '?';\n        } else {\n            opBStr = this.inputs[1].toMathML();\n        }\n        switch (this.op) {\n            case '+':\n                theOp = \"<plus/>\"\n                break;\n            case '-':\n                theOp = \"<minus/>\"\n                break;\n            case '*':\n                theOp = \"<times/>\"\n                break;\n            case '/':\n                theOp = \"<divide/>\"\n                break;\n            case '^':\n                theOp = \"<power/>\"\n                break;\n        }\n        theStr = \"<apply>\" + theOp + opAStr + opBStr + \"</apply>\";\n\n        return(theStr);\n    }\n\n    operateToTeX() {\n        var opString = this.op;\n\n        switch (opString) {\n            case '*':\n                opString = '\\\\times ';\n                break;\n            case '/':\n                opString = '\\\\div ';\n                break;\n            case '^':\n                opString = '\\\\wedge ';\n                break;\n            case '|':\n                opString = '\\\\hbox{ or }';\n                break;\n            case '$':\n                opString = '\\\\hbox{ or }';\n                break;\n            case '&':\n                opString = '\\\\hbox{ and }';\n                break;\n        }\n\n        return(opString);\n    }\n\n    isCommutative() {\n        var commutes = false;\n        if (this.op === '+' || this.op === '*') {\n            commutes = true;\n        }\n        return(commutes);\n    }\n\n    evaluate(bindings) {\n        var inputAVal = this.inputs[0].evaluate(bindings);\n        var inputBVal = this.inputs[1].evaluate(bindings);\n\n        if (inputAVal == undefined || inputBVal == undefined) {\n            return(undefined);\n        }\n\n        var retVal = undefined;\n        switch (this.op) {\n            case '+':\n                retVal = inputAVal + inputBVal;\n                break;\n            case '-':\n                retVal = inputAVal - inputBVal;\n                break;\n            case '*':\n                retVal = inputAVal * inputBVal;\n                break;\n            case '/':\n                retVal = inputAVal / inputBVal;\n                break;\n            case '^':\n                if (!this.inputs[1].isConstant()) {\n                    retVal = Math.exp(inputBVal * Math.log(inputAVal));\n                } else {\n                    if (inputAVal >= 0 || (inputBVal % 1 == 0)) {\n                        retVal = Math.pow(inputAVal,inputBVal);\n                    } else {\n                        retVal = Math.exp(inputBVal * Math.log(inputAVal));\n                    }\n                }\n                break;\n            case '=':\n                retVal = (Math.abs(inputAVal - inputBVal) < this.menv.options.absTol);\n                break;\n            case '&':\n                retVal = inputAVal && inputBVal;\n                break;\n            case '|':\n            case '$':\n                retVal = inputAVal || inputBVal;\n                break;\n            default:\n                console.log(\"The binary operator '\" + this.op + \"' is not defined.\");\n                retVal = undefined;\n                break;\n        }\n        return(retVal);\n    }\n\n    // See if this operator is now redundant.\n    // Return the resulting expression.\n    reduce() {\n        var newExpr = this;\n        if (this.inputs.length <= 1) {\n            if (this.inputs.length == 0) {\n                // Sum with no elements = 0\n                // Product with no elements = 1\n                newExpr = new scalar_expr(this.menv, this.op == '+' ? 0 : 1);\n            } else {\n                // Sum or product with one element *is* that element.\n                newExpr = this.inputs[0].reduce();\n            }\n            newExpr.parent = this.parent;\n            if (this.parent !== null) {\n                this.parent.inputSubst(this, newExpr);\n            }\n        }\n        return(newExpr);\n    }\n\n    simplifyConstants() {\n        var retVal = this;\n        this.inputs[0] = this.inputs[0].simplifyConstants();\n        this.inputs[0].parent = this;\n        this.inputs[1] = this.inputs[1].simplifyConstants();\n        this.inputs[1].parent = this;\n        if ((this.inputs[0].type == exprType.number\n                || (this.inputs[0].type == exprType.unop && this.inputs[0].inputs[0].type == exprType.number)\n            ) &&\n            (this.inputs[1].type == exprType.number\n                || (this.inputs[1].type == exprType.unop && this.inputs[1].inputs[0].type == exprType.number)\n            ))\n        {\n            var numA, numB, theNumber;\n            if (this.inputs[0].type == exprType.number) {\n                numA = this.inputs[0].number;\n            } else {\n                switch (this.inputs[0].op) {\n                    case '-':\n                        numA = this.inputs[0].inputs[0].number.addInverse();\n                        break;\n                    case '/':\n                        numA = this.inputs[0].inputs[0].number.multInverse();\n                        break;\n                }\n            }\n            if (this.inputs[1].type == exprType.number) {\n                numB = this.inputs[1].number;\n            } else {\n                switch (this.inputs[1].op) {\n                    case '-':\n                        numB = this.inputs[1].inputs[0].number.addInverse();\n                        break;\n                    case '/':\n                        numB = this.inputs[1].inputs[0].number.multInverse();\n                        break;\n                }\n            }\n            switch (this.op) {\n                case '+':\n                    theNumber = numA.add(numB);\n                    break;\n                case '-':\n                    theNumber = numA.subtract(numB);\n                    break;\n                case '*':\n                    theNumber = numA.multiply(numB);\n                    break;\n                case '/':\n                    theNumber = numA.divide(numB);\n                    break;\n                case '^':\n                    // Integer powers of a rational number can be represented exactly.\n                    if (numA instanceof rational_number && numB instanceof rational_number\n                            && numB.q == 1 && numB.p % 1 == 0 && numB.p > 0) {\n                        theNumber = new rational_number(Math.pow(numA.p, numB.p), Math.pow(numA.q, numB.p));\n                    }\n                    break;\n            }\n            if (theNumber !== undefined) {\n                if (!this.menv.options.negativeNumbers && theNumber.p < 0) {\n                    retVal = new unop_expr(this.menv, '-', new scalar_expr(this.menv, theNumber.multiply(-1)));\n                } else {\n                    retVal = new scalar_expr(this.menv, theNumber);\n                }\n            }\n        } else {\n            switch (this.op) {\n                case '+':\n                    // Simplify 0+a\n                    if (this.inputs[0].type == exprType.number\n                            && this.inputs[0].number.value()==0) {\n                        retVal = this.inputs[1];\n                    }\n                    // Simplify a+0\n                    else if (this.inputs[1].type == exprType.number\n                            && this.inputs[1].number.value() == 0) {\n                        retVal = this.inputs[0];\n                    }\n                    break;\n                case '-':\n                    // Simplify 0-a\n                    if (this.inputs[0].type == exprType.number\n                            && this.inputs[0].number.value()==0) {\n                        retVal = new unop_expr(this.menv, \"-\", this.inputs[1]);\n                    }\n                    // Simplify a-0\n                    else if (this.inputs[1].type == exprType.number\n                            && this.inputs[1].number.value() == 0) {\n                        retVal = this.inputs[0];\n                    }\n                    break;\n                case '*':\n                    // Simplify 1*a\n                    if (this.inputs[0].type == exprType.number\n                            && this.inputs[0].number.value()==1) {\n                        retVal = this.inputs[1];\n                    }\n                    // Simplify a*1\n                    else if (this.inputs[1].type == exprType.number\n                            && this.inputs[1].number.value() == 1) {\n                        retVal = this.inputs[0];\n                    }\n                    break;\n                case '/':\n                    // Simplify 1/a to unary operator of multiplicative inverse.\n                    if (this.inputs[0].type == exprType.number\n                            && this.inputs[0].number.value()==1) {\n                        retVal = new unop_expr(this.menv, \"/\", this.inputs[1]);\n                    }\n                    // Simplify a/1\n                    else if (this.inputs[1].type == exprType.number\n                            && this.inputs[1].number.value() == 1) {\n                        retVal = this.inputs[0];\n                    }\n                    break;\n                case '^':\n                    // Simplify 0^p\n                    if (this.inputs[0].type == exprType.number\n                            && this.inputs[0].number.value()==0) {\n                        retVal = new scalar_expr(this.menv, 0);\n                    }\n                    // Simplify 1^p\n                    else if (this.inputs[0].type == exprType.number\n                            && this.inputs[0].number.value() == 1) {\n                        retVal = new scalar_expr(this.menv, 1);\n                    }\n                    // Simplify p^1\n                    else if (this.inputs[1].type == exprType.number\n                            && this.inputs[1].number.value() == 1) {\n                        retVal = this.inputs[0];\n                    }\n                    break;\n            }\n        }\n        return(retVal);\n    }\n\n    flatten() {\n        var inA = this.inputs[0].flatten();\n        var inB = this.inputs[1].flatten();\n\n        var retVal;\n        switch (this.op) {\n            case '+':\n            case '-':\n                var inputs = [];\n                if ((inA.type == exprType.multiop || inA.type == exprType.binop)\n                    && (inA.op == '+' || inA.op == '-')) \n                {\n                    var newInput = inA.flatten();\n                    for (var i in newInput.inputs) {\n                        inputs.push(newInput.inputs[i]);\n                    }\n                } else {\n                    inputs.push(inA);\n                }\n                if ((inB.type == exprType.multiop || inB.type == exprType.binop)\n                    && (inB.op == '+' || inB.op == '-')) \n                {\n                    var newInput = inB.flatten();\n                    for (var i in newInput.inputs) {\n                        inputs.push(newInput.inputs[i]);\n                    }\n                } else {\n                    if (this.op == '-') {\n                        if ((inB.type == exprType.multiop || inB.type == exprType.binop)\n                            && (inB.op == '+' || inB.op == '-')) \n                        {\n                            var newInput = inB.flatten();\n                            for (var i in newInput.inputs) {\n                                inputs.push(new unop_expr(this.menv, '-',newInput.inputs[i]));\n                            }\n                        } else {\n                            inputs.push(new unop_expr(this.menv, '-',inB));\n                        }\n                    } else {\n                        inputs.push(inB);\n                    }\n                }\n                retVal = new multiop_expr(this.menv, '+', inputs);\n                break;\n            case '*':\n            case '/':\n                var inputs = [];\n                if ((inA.type == exprType.multiop || inA.type == exprType.binop)\n                    && (inA.op == '*' || inA.op == '/')) \n                {\n                    var newInput = inA.flatten();\n                    for (var i in newInput.inputs) {\n                        inputs.push(newInput.inputs[i]);\n                    }\n                } else {\n                    inputs.push(inA);\n                }\n                if ((inB.type == exprType.multiop || inB.type == exprType.binop)\n                    && (inB.op == '*' || inB.op == '/'))\n                {\n                    var newInput = inB.flatten();\n                    for (var i in newInput.inputs) {\n                        inputs.push(newInput.inputs[i]);\n                    }\n                } else {\n                    if (this.op == '/') {\n                        if ((inB.type == exprType.multiop || inB.type == exprType.binop)\n                            && (inB.op == '*' || inB.op == '/')) \n                        {\n                            var newInput = inB.flatten();\n                            for (var i in newInput.inputs) {\n                                inputs.push(new unop_expr(this.menv, '/',newInput.inputs[i]));\n                            }\n                        } else {\n                            inputs.push(new unop_expr(this.menv, '/',inB));\n                        }\n                    } else {\n                        inputs.push(inB);\n                    }\n                }\n                retVal = new multiop_expr(this.menv, '*', inputs);\n                break;\n            default:\n                retVal = new binop_expr(this.menv, this.op, inA, inB);\n        }\n        return(retVal);\n    }\n\n    copy() {\n      var inA = this.inputs[0].copy();\n      var inB = this.inputs[1].copy();\n      return (new binop_expr(this.menv, this.op, inA, inB));\n    }\n\n    compose(bindings) {\n        var inA = this.inputs[0].compose(bindings);\n        var inB = this.inputs[1].compose(bindings);\n\n        var retVal;\n        retVal = new binop_expr(this.menv, this.op, inA, inB);\n        if (inA.type == exprType.number && inB.type == exprType.number) {\n            switch (this.op) {\n                case '+':\n                    retVal = new scalar_expr(this.menv, inA.number.add(inB.number));\n                    break;\n                case '-':\n                    retVal = new scalar_expr(this.menv, inA.number.subtract(inB.number));\n                    break;\n                case '*':\n                    retVal = new scalar_expr(this.menv, inA.number.multiply(inB.number));\n                    break;\n                case '/':\n                    retVal = new scalar_expr(this.menv, inA.number.divide(inB.number));\n                    break;\n            }\n        }\n        return(retVal);\n    }\n\n    derivative(ivar, varList) {\n        var uConst = this.inputs[0].isConstant();\n        var vConst = this.inputs[1].isConstant();\n\n        var theDeriv;\n        if (uConst && vConst) {\n            theDeriv = new scalar_expr(this.menv, 0);\n        } else {\n            var dudx, dvdx;\n\n            if (uConst) {\n                dudx = new scalar_expr(this.menv, 0);\n            } else {\n                dudx = this.inputs[0].derivative(ivar, varList);\n            }\n            if (vConst) {\n                dvdx = new scalar_expr(this.menv, 0);\n            } else {\n                dvdx = this.inputs[1].derivative(ivar, varList);\n            }\n            switch (this.op) {\n                case '+':\n                    theDeriv = new binop_expr(this.menv, '+', dudx, dvdx);\n                    break;\n                case '-':\n                    theDeriv = new binop_expr(this.menv, '-', dudx, dvdx);\n                    break;\n                case '*':\n                    var udv = new binop_expr(this.menv, '*', this.inputs[0], dvdx)\n                    var vdu = new binop_expr(this.menv, '*', dudx, this.inputs[1])\n                    if (uConst) {\n                        theDeriv = udv;\n                    } else if (vConst) {\n                        theDeriv = vdu;\n                    } else {\n                        theDeriv = new binop_expr(this.menv, '+', vdu, udv);\n                    }\n                    break;\n                case '/':\n                    if (vConst) {\n                        theDeriv = new binop_expr(this.menv, '/', dudx, this.inputs[1]);\n                    } else if (uConst) {\n                        var numer = new unop_expr(this.menv, '-', new binop_expr(this.menv, '*', this.inputs[0], dvdx));\n                        var denom = new binop_expr(this.menv, '^', this.inputs[1], new scalar_expr(this.menv, 2));\n                        theDeriv = new binop_expr(this.menv, '/', numer, denom);\n                    } else {\n                        var udv = new binop_expr(this.menv, '*', this.inputs[0], dvdx)\n                        var vdu = new binop_expr(this.menv, '*', dudx, this.inputs[1])\n                        var numer = new binop_expr(this.menv, '-', vdu, udv);\n                        var denom = new binop_expr(this.menv, '^', this.inputs[1], new scalar_expr(this.menv, 2));\n                        theDeriv = new binop_expr(this.menv, '/', numer, denom);\n                    }\n                    break;\n                case '^':\n                    var powDep = this.inputs[1].dependencies();\n                    var ivarName = (typeof ivar == 'string') ? ivar : ivar.name;\n                    // See if the power depends on the variable\n                    if (powDep.length > 0 && powDep.indexOf(ivarName) >= 0) {\n                        var theArg = new binop_expr(this.menv, '*', this.inputs[1], new function_expr(this.menv, 'log', this.inputs[0]));\n                        var theFcn = new function_expr(this.menv, 'exp', theArg);\n                        theDeriv = theFcn.derivative(ivar, varList);\n                    // Otherwise this is a simple application of the power rule\n                    } else if (!uConst) {\n                        var newPow = new binop_expr(this.menv, '-', this.inputs[1], new scalar_expr(this.menv, 1));\n                        var dydu = new binop_expr(this.menv, '*', this.inputs[1], new binop_expr(this.menv, '^', this.inputs[0], newPow));\n                        if (this.inputs[0].type == exprType.variable\n                                && this.inputs[0].name == ivarName) {\n                            theDeriv = dydu;\n                        } else {\n                            var dudx = this.inputs[0].derivative(ivar, varList);\n                            theDeriv = new binop_expr(this.menv, '*', dydu, dudx);\n                        }\n                    } else {\n                        theDeriv = new scalar_expr(this.menv, 0);\n                    }\n                    break;\n                default:\n                    console.log(\"The binary operator '\" + this.op + \"' is not defined.\");\n                    theDeriv = undefined;\n                    break;\n            }\n        }\n        return(theDeriv);\n    }\n}\n","/*!\n * BTM JavaScript Library v@VERSION\n * https://github.com/dbrianwalton/BTM\n *\n * Copyright D. Brian Walton\n * Released under the MIT license (https://opensource.org/licenses/MIT)\n *\n * Date: @DATE\n */\n\n/* ***************************************************\n* Define the Unary Expression -- defined by an operator and an input.\n* *************************************************** */\n\nimport { expression } from \"./expression.js\"\nimport { scalar_expr } from \"./scalar_expr.js\"\nimport { binop_expr } from \"./binop_expr.js\"\nimport { exprType, opPrec } from \"./BTM_root.js\"\n\nexport class unop_expr extends expression {\n    constructor(menv, op, input) {\n        super(menv);\n        this.type = exprType.unop;\n        this.op = op;\n        if (typeof input == 'undefined')\n            input = new expression(menv);\n        this.inputs = [input];\n            input.parent = this;\n        switch (op) {\n            case '+':\n                this.prec = opPrec.multdiv;\n                break;\n            case '-':\n                this.prec = opPrec.multdiv;\n                break;\n            case '/':\n                this.prec = opPrec.power;\n                break;\n            default:\n                alert(\"Unknown unary operator: '\"+op+\"'.\");\n                break;\n        }\n    }\n\n    toString() {\n        var theStr;\n        var opStr;\n\n        if (typeof this.inputs[0] == 'undefined') {\n            opStr = '?';\n        } else {\n            opStr = this.inputs[0].toString();\n        }\n        if ((this.inputs[0].type >= exprType.unop\n                && this.inputs[0].prec < this.prec)\n            || (this.inputs[0].type == exprType.number\n                && opStr.indexOf('/') >= 0\n                && opPrec.multdiv <= this.prec)\n            ) \n        {\n            theStr = this.op + '(' + opStr + ')';\n        } else {\n            theStr = this.op + opStr;\n        }\n\n        return(theStr);\n    }\n\n    // Return an array containing all tested equivalent strings.\n    allStringEquivs() {\n        var allInputs = this.inputs[0].allStringEquivs();\n        var retValue = [];\n\n        for (var i in allInputs) {\n            if (this.inputs[0].type >= exprType.unop && this.inputs[0].prec <= this.prec) {\n                retValue[i] = this.op + '(' + allInputs[i] + ')';\n            } else {\n                retValue[i] = this.op + allInputs[i];\n            }\n        }\n\n        return(retValue);\n    }\n\n    toTeX(showSelect) {\n        var theStr;\n        var opStr, theOp;\n\n        if (typeof showSelect == 'undefined') {\n            showSelect = false;\n        }\n\n        if (typeof this.inputs[0] == 'undefined') {\n            opStr = '?';\n        } else {\n            opStr = this.inputs[0].toTeX(showSelect);\n        }\n\n        theOp = this.op;\n        if (theOp == '/') {\n            theOp = '\\\\div ';\n            if (showSelect && this.select) {\n                theStr = \"{\\\\color{red}\" + this.op + \"}\"\n                                + '\\\\left({\\\\color{blue}' + opStr + '}\\\\right)';\n            } else {\n                theStr = '\\\\frac{1}{' + opStr + '}';\n            }\n        } else {\n            if (showSelect && this.select) {\n                theStr = \"{\\\\color{red}\" + this.op + \"}\"\n                                + '\\\\left({\\\\color{blue}' + opStr + '}\\\\right)';\n            } else if (this.inputs[0].type >= exprType.unop && this.inputs[0].prec <= this.prec\n                && (this.inputs[0].type != exprType.unop || this.op != '-' || this.inputs[0].op != '/')) {\n                theStr = theOp + '\\\\left(' + opStr + '\\\\right)';\n            } else {\n                theStr = theOp + opStr;\n            }\n        }\n        return(theStr);\n    }\n\n    toMathML() {\n        var theStr;\n        var opStr;\n\n        if (typeof this.inputs[0] == 'undefined') {\n            opStr = '?';\n        } else {\n            opStr = this.inputs[0].toMathML();\n        }\n        switch (this.op) {\n            case '+':\n                theStr = opStr;\n                break;\n            case '-':\n                theStr = \"<apply><minus/>\" + opStr + \"</apply>\";\n                break;\n            case '/':\n                theStr = \"<apply><divide/><cn>1</cn>\" + opStr + \"</apply>\";\n                break;\n        }\n\n        return(theStr);\n    }\n\n    operateToTeX() {\n        var opString = this.op;\n\n        if (opString === '/') {\n            opString = '\\\\div';\n        }\n\n        return(opString);\n    }\n\n    evaluate(bindings) {\n        var inputVal = this.inputs[0].evaluate(bindings);\n\n        var retVal;\n        if (inputVal == undefined) {\n            return(undefined);\n        }\n        switch (this.op) {\n            case '+':\n                retVal = inputVal;\n                break;\n            case '-':\n                retVal = -1*inputVal;\n                break;\n            case '/':\n                // Even when divide by zero, we want to use this, since in the exception\n                // we want the value to be Infinite and not undefined.\n                retVal = 1/inputVal;\n                break;\n            default:\n                alert(\"The unary operator '\" + this.op + \"' is not defined.\");\n                retVal = undefined;\n                break;\n        }\n        return(retVal);\n    }\n\n    simplifyConstants() {\n        var retVal;\n\n        this.inputs[0] = this.inputs[0].simplifyConstants();\n        this.inputs[0].parent = this;\n        if (this.inputs[0].type == exprType.number) {\n            var theNumber = this.inputs[0].number;\n            switch (this.op) {\n                case '-':\n                    if (this.menv.options.negativeNumbers) {\n                    retVal = new scalar_expr(this.menv, theNumber.addInverse());\n                    } else {\n                    retVal = this;\n                    }\n                    break;\n                case '/':\n                    retVal = new scalar_expr(this.menv, theNumber.multInverse());\n                    break;\n            }\n        } else {\n            retVal = this;\n        }\n        return(retVal);\n    }\n\n    flatten() {\n      return(new unop_expr(this.menv, this.op, this.inputs[0].flatten()));\n    }\n\n    copy() {\n      return(new unop_expr(this.menv, this.op, this.inputs[0].copy()));\n    }\n\n    compose(bindings) {\n        return(new unop_expr(this.menv, this.op, this.inputs[0].compose(bindings)));\n    }\n\n    derivative(ivar, varList) {\n        var theDeriv;\n\n        var uConst = this.inputs[0].isConstant();\n        if (uConst) {\n            theDeriv = new scalar_expr(this.menv, 0);\n        } else {\n            switch (this.op) {\n                case '+':\n                    theDeriv = this.inputs[0].derivative(ivar, varList);\n                    break;\n                case '-':\n                    theDeriv = new unop_expr(this.menv, '-', this.inputs[0].derivative(ivar, varList));\n                    break;\n                case '/':\n                    var denom = new binop_expr(this.menv, '*', this.inputs[0], this.inputs[0]);\n                    theDeriv = new unop_expr(this.menv, '-', new binop_expr(this.menv, '/', this.inputs[0].derivative(ivar, varList), denom));\n                    break;\n                default:\n                    console.log(\"The derivative of the unary operator '\" + this.op + \"' is not defined.\");\n                    theDeriv = undefined;\n                    break;\n            }\n        }\n        return(theDeriv);\n    }\n\n    match(expr, bindings) {\n        var retValue = null;\n\n        // Special named constants can not match expressions.\n        if (this.isConstant() && expr.isConstant()) {\n            var newExpr = expr.simplifyConstants(),\n                newThis = this.simplifyConstants();\n\n            if (newExpr.toString() === newThis.toString()\n                || newExpr.type == exprType.number && newThis.type == exprType.number\n                    && newThis.number.equal(newExpr.number)) {\n                retValue = bindings;\n            }\n        } else {\n            retValue = expression.prototype.match.call(this, expr, bindings);\n        }\n\n        return(retValue);\n    }\n}\n","/*!\n * BTM JavaScript Library v@VERSION\n * https://github.com/dbrianwalton/BTM\n *\n * Copyright D. Brian Walton\n * Released under the MIT license (https://opensource.org/licenses/MIT)\n *\n * Date: @DATE\n */\n\n/* ***************************************************\n* Define the Multi-Operand Expression (for sum and product)\n* *************************************************** */\n\nimport { expression } from \"./expression.js\"\nimport { scalar_expr } from \"./scalar_expr.js\"\nimport { exprType, opPrec } from \"./BTM_root.js\"\n\nexport class multiop_expr extends expression {\n    constructor(menv, op, inputs) {\n        super(menv);\n        this.type = exprType.multiop;\n        this.op = op;\n        this.inputs = inputs; // an array\n        for (var i in inputs) {\n            if (typeof inputs[i] == 'undefined')\n                inputs[i] = new expression(menv);\n            inputs[i].parent = this;\n        }\n        switch (op) {\n            case '+':\n                this.prec = opPrec.addsub;\n                break;\n            case '*':\n                this.prec = opPrec.multdiv;\n                break;\n            default:\n                alert(\"Unknown multi-operand operator: '\"+op+\"'.\");\n                break;\n        }\n    }\n\n    toString() {\n        var theStr,\n            opStr,\n            isError = false,\n            showOp;\n\n        theStr = '';\n        for (var i in this.inputs) {\n            showOp = true;\n            if (typeof this.inputs[i] == 'undefined') {\n                opStr = '?';\n                isError = true;\n            } else {\n                opStr = this.inputs[i].toString();\n                if ((this.inputs[i].type >= exprType.unop\n                        && this.inputs[i].prec <= this.prec)\n                    || (this.inputs[i].type == exprType.number\n                        && this.inputs[i].number.q != 1\n                        && opPrec.multdiv <= this.prec)\n                ) {\n                    opStr = '(' + opStr + ')';\n                }\n            }\n            theStr += ( i>0 ? this.op : '' ) + opStr;\n        }\n\n        return(theStr);\n    }\n\n    // Return an array containing all tested equivalent strings.\n    allStringEquivs() {\n        var allInputsArrays = [];\n\n        var indexList = [];\n        for (var i in this.inputs) {\n            allInputsArrays[i] = this.inputs[i].allStringEquivs();\n            indexList.push(i);\n        }\n        var inputPerms = permutations(indexList);\n\n        var retValue = [];\n\n        var theOp = this.op;\n        if (theOp == '|') {\n            // Don't want \"or\" to be translated as absolute value\n            theOp = ' $ ';\n        }\n\n        function buildStringEquivs(indexList, leftStr) {\n            if (typeof leftStr == \"undefined\") {\n                leftStr = \"\";\n            } else if (indexList.length > 0) {\n                leftStr += theOp;\n            }\n            if (indexList.length > 0) {\n                var workInputs = allInputsArrays[indexList[0]];\n                for (var i in workInputs) {\n                    buildStringEquivs(indexList.slice(1), leftStr + \"(\" + workInputs[i] + \")\");\n                }\n            } else {\n                retValue.push(leftStr);\n            }\n        }\n\n        for (var i in inputPerms) {\n            buildStringEquivs(inputPerms[i]);\n        }\n\n        return(retValue);\n    }\n\n    toTeX(showSelect) {\n        var theStr;\n        var theOp;\n        var opStr;\n        var argStrL, argStrR, opStrL, opStrR;\n\n        if (typeof showSelect == 'undefined') {\n            showSelect = false;\n        }\n\n        theOp = this.op;\n        if (this.op == '*') {\n            if (showSelect && this.select) {\n                theOp = '\\\\times';\n            } else {\n                theOp = ' ';\n            }\n        }\n\n        if (showSelect && this.select) {\n            argStrL = '{\\\\color{blue}';\n            argStrR = '}';\n            opStrL = '{\\\\color{red}';\n            opStrR = '}';\n        } else {\n            argStrL = '';\n            argStrR = '';\n            opStrL = '';\n            opStrR = '';\n        }\n\n        theStr = '';\n        var minPrec = this.prec;\n        for (var i in this.inputs) {\n            if (typeof this.inputs[i] == 'undefined') {\n                opStr = '?';\n                theStr += ( i>0 ? opStrL + theOp + opStrR : '' ) + opStr;\n            } else {\n                if (this.op == '*'\n                        && this.inputs[i].type == exprType.unop && this.inputs[i].op == '/'\n                        && !(showSelect && this.select))\n                {\n                    opStr = argStrL + this.inputs[i].inputs[0].toTeX(showSelect) + argStrR;\n                    if (this.inputs[i].inputs[0].type >= exprType.unop && this.inputs[i].inputs[0].prec < minPrec) {\n                        opStr = '\\\\left(' + opStr + '\\\\right)';\n                    }\n                    if (theStr == '') {\n                        theStr = '1'\n                    }\n                    theStr = '\\\\frac{' + theStr + '}{' + opStr + '}';\n\n                } else if (this.op == '+'\n                        && this.inputs[i].type == exprType.unop && this.inputs[i].op == '-'\n                        && !(showSelect && this.select))\n                {\n                    opStr = argStrL + this.inputs[i].toTeX(showSelect) + argStrR;\n                    theStr += opStr;\n                } else {\n                    opStr = argStrL + this.inputs[i].toTeX(showSelect) + argStrR;\n                    if ((this.inputs[i].type >= exprType.unop\n                            && this.inputs[i].prec <= minPrec)\n                        || (i>0 && this.op == '*' && this.inputs[i].type == exprType.number)) {\n                        opStr = '\\\\left(' + opStr + '\\\\right)';\n                    }\n                    theStr += ( i>0 ? opStrL + theOp + opStrR : '' ) + opStr;\n                }\n            }\n        }\n\n        return(theStr);\n    }\n\n    toMathML() {\n        var theStr;\n        var theOp;\n        var opStr;\n\n        switch (this.op) {\n            case '+':\n                theOp = \"<plus/>\"\n                break;\n            case '*':\n                theOp = \"<times/>\"\n                break;\n        }\n\n        theStr = \"<apply>\" + theOp;\n        for (var i in this.inputs) {\n            if (typeof this.inputs[i] == 'undefined') {\n                opStr = '?';\n            } else {\n                opStr = this.inputs[i].toMathML();\n            }\n            theStr += opStr;\n        }\n        theStr += \"</apply>\";\n\n        return(theStr);\n    }\n\n    operateToTeX() {\n        var opString = this.op;\n\n        switch (opString) {\n            case '*':\n                opString = '\\\\times';\n                break;\n        }\n\n        return(opString);\n    }\n\n    isCommutative() {\n        var commutes = false;\n        if (this.op === '+' || this.op === '*') {\n            commutes = true;\n        }\n        return(commutes);\n    }\n\n    evaluate(bindings) {\n        var inputVal;\n        var i;\n        var retVal;\n\n        switch (this.op) {\n            case '+':\n                retVal = 0;\n                for (i in this.inputs) {\n                    inputVal = this.inputs[i].evaluate(bindings);\n                    retVal += inputVal;\n                }\n                break;\n            case '*':\n                retVal = 1;\n                for (i in this.inputs) {\n                    inputVal = this.inputs[i].evaluate(bindings);\n                    retVal *= inputVal;\n                }\n                break;\n            default:\n                console.log(\"The binary operator '\" + this.op + \"' is not defined.\");\n                retVal = undefined;\n                break;\n        }\n        return(retVal);\n    }\n\n    // Flatten and also sort terms.\n    flatten() {\n        var newInputs = [];\n        for (var i in this.inputs) {\n            var nextInput = this.inputs[i].flatten();\n            if (nextInput.type == exprType.multiop && nextInput.op == this.op) {\n                for (var j in nextInput.inputs) {\n                    newInputs.push(nextInput.inputs[j]);\n                }\n            } else {\n                newInputs.push(nextInput);\n            }\n        }\n\n        var retValue;\n        if (newInputs.length == 0) {\n            // Adding no elements = 0\n            // Multiplying no elements = 1\n            retValue = new scalar_expr(this.menv, this.op == '+' ? 0 : 1);\n        } else if (newInputs.length == 1) {\n            retValue = newInputs[0];\n        } else {\n            // Sort the inputs by precedence for products\n            // Usually very small, so bubble sort is good enough\n            if (this.op=='*') {\n                var tmp;\n                for (var i=0; i<newInputs.length-1; i++) {\n                    for (var j=i+1; j<newInputs.length; j++) {\n                        if (newInputs[i].type > newInputs[j].type) {\n                            tmp = newInputs[i];\n                            newInputs[i] = newInputs[j];\n                            newInputs[j] = tmp;\n                        }\n                    }\n                }\n            }\n            retValue = new multiop_expr(this.menv, this.op, newInputs);\n        }\n        return(retValue);\n    }\n\n    // See if this operator is now redundant.\n    // Return the resulting expression.\n    reduce() {\n        var newExpr = this;\n        if (this.inputs.length <= 1) {\n            if (this.inputs.length == 0) {\n                // Sum with no elements = 0\n                // Product with no elements = 1\n                newExpr = new scalar_expr(this.menv, this.op == '+' ? 0 : 1);\n            } else {\n                // Sum or product with one element *is* that element.\n                newExpr = this.inputs[0];\n            }\n            newExpr.parent = this.parent;\n            if (this.parent !== null) {\n                this.parent.inputSubst(this, newExpr);\n            }\n        }\n        return(newExpr);\n    }\n\n    simplifyConstants() {\n        var i,\n            constIndex = [],\n            newInputs = [];\n        // Simplify all inputs\n        // Notice which inputs are themselves constant \n        for (i in this.inputs) {\n            this.inputs[i] = this.inputs[i].simplifyConstants();\n            this.inputs[i].parent = this;\n            if (this.inputs[i].type == exprType.number) {\n                constIndex.push(i);\n            } else {\n                newInputs.push(this.inputs[i]);\n            }\n        }\n\n        // For all inputs that are constants, group them together and simplify.\n        var newExpr = this;\n        if (constIndex.length > 1) {\n            var newConstant = this.inputs[constIndex[0]].number;\n            for (i=1; i<constIndex.length; i++) {\n                switch (this.op) {\n                    case '+':\n                        newConstant = newConstant.add(this.inputs[constIndex[i]].number);\n                        break;\n                    case '*':\n                        newConstant = newConstant.multiply(this.inputs[constIndex[i]].number);\n                        break;\n                }\n            }\n\n            // For addition, the constant goes to the end.\n            // For multiplication, the constant goes to the beginning.\n            var newInput;\n            switch (this.op) {\n                case '+':\n                    newInputs.push(newInput = new scalar_expr(this.menv, newConstant));\n                    break;\n                case '*':\n                    newInputs.splice(0, 0, newInput = new scalar_expr(this.menv, newConstant));\n                    break;\n            }\n            if (newInputs.length == 1) {\n                newExpr = newInputs[0];\n            } else {\n                newInput.parent = this;\n                newExpr = new multiop_expr(this.menv, this.op, newInputs);\n            }\n        }\n        return(newExpr);\n    }\n\n    // This comparison routine needs to deal with two issues.\n    // (1) The passed expression has more inputs than this (in which case we group them)\n    // (2) Possibility of commuting makes the match work.\n    match(expr, bindings) {\n        function copyBindings(bindings)\n        {\n            var retValue = {};\n            for (var key in bindings) {\n                retValue[key] = bindings[key];\n            }\n            return(retValue);\n        }\n\n        var retValue = null,\n            n = this.inputs.length;\n        if (expr.type == exprType.multiop && this.op == expr.op\n                && n <= expr.inputs.length) {\n\n            // Match on first n-1 and group remainder at end.\n            var cmpExpr,\n                cmpInputs = [];\n\n            for (var i=0; i<n; i++) {\n                if (i<(n-1) || expr.inputs.length==n) {\n                    cmpInputs[i] = expr.inputs[i].copy();\n                } else {\n                    // Create copies of the inputs\n                    var newInputs = [];\n                    for (var j=0; j<=expr.inputs.length-n; j++) {\n                        newInputs[j] = expr.inputs[n+j-1].copy();\n                    }\n                    cmpInputs[i] = new multiop_expr(this.menv, expr.op, newInputs);\n                }\n            }\n            cmpExpr = new multiop_expr(this.menv, expr.op, cmpInputs);\n\n            // Now make the comparison.\n            retValue = copyBindings(bindings);\n            retValue = expression.prototype.match.call(this, cmpExpr, retValue);\n\n            // If still fail to match, try the reverse grouping: match on last n-1 and group beginning.\n            if (retValue == null && n < expr.inputs.length) {\n                var diff = expr.inputs.length - n;\n                cmpInputs = [];\n\n                for (var i=0; i<n; i++) {\n                    if (i==0) {\n                        // Create copies of the inputs\n                        var newInputs = [];\n                        for (var j=0; j<=diff; j++) {\n                            newInputs[j] = expr.inputs[j].copy();\n                        }\n                        cmpInputs[i] = new multiop_expr(this.menv, expr.op, newInputs);\n                    } else {\n                        cmpInputs[i] = expr.inputs[diff+i].copy();\n                    }\n                }\n                cmpExpr = new multiop_expr(this.menv, expr.op, cmpInputs);\n\n                // Now make the comparison.\n                retValue = copyBindings(bindings);\n                retValue = expression.prototype.match.call(this, cmpExpr, retValue);\n            }\n        }\n        return(retValue);\n    }\n\n    compose(bindings) {\n        var newInputs = [];\n\n        for (var i in this.inputs) {\n            newInputs.push(this.inputs[i].compose(bindings));\n        }\n\n        var retValue;\n        if (newInputs.length == 0) {\n            retValue = new scalar_expr(this.menv, this.op == '+' ? 0 : 1);\n        } else if (newInputs.length == 1) {\n            retValue = newInputs[0];\n        } else {\n            retValue = new multiop_expr(this.menv, this.op, newInputs);\n        }\n        return(retValue);\n    }\n\n    derivative(ivar, varList) {\n        var dTerms = [];\n\n        var theDeriv;\n        var i, dudx;\n        for (i in this.inputs) {\n            if (!this.inputs[i].isConstant()) {\n                dudx = this.inputs[i].derivative(ivar, varList);\n                switch (this.op) {\n                    case '+':\n                        dTerms.push(dudx);\n                        break;\n                    case '*':\n                        var dProdTerms = [];\n                        for (j in this.inputs) {\n                            if (i == j) {\n                                dProdTerms.push(dudx);\n                            } else {\n                                dProdTerms.push(this.inputs[j].compose({}));\n                            }\n                        }\n                        dTerms.push(new multiop_expr(this.menv, '*', dProdTerms));\n                        break;\n                }\n            }\n        }\n        if (dTerms.length == 0) {\n            theDeriv = new scalar_expr(this.menv, 0);\n        } else if (dTerms.length == 1) {\n            theDeriv = dTerms[0];\n        } else {\n            theDeriv = new multiop_expr(this.menv, '+', dTerms);\n        }\n        return(theDeriv);\n    }\n}","/*!\n * BTM JavaScript Library v@VERSION\n * https://github.com/dbrianwalton/BTM\n *\n * Copyright D. Brian Walton\n * Released under the MIT license (https://opensource.org/licenses/MIT)\n *\n * Date: @DATE\n */\n\n/* ***************************************************\n   * Define the Function Expression -- defined by a function name and input expression\n   * *************************************************** */\n\nimport { expression } from \"./expression.js\"\nimport { scalar_expr } from \"./scalar_expr.js\"\nimport { variable_expr } from \"./variable_expr.js\"\nimport { unop_expr } from \"./unop_expr.js\"\nimport { binop_expr } from \"./binop_expr.js\"\nimport { exprType } from \"./BTM_root.js\"\n\nexport class function_expr extends expression {\n    constructor(menv, name, inputExpr, restrictDomain) {\n        super(menv);\n        this.type = exprType.fcn;\n        // Count how many derivatives.\n        var primePos = name.indexOf(\"'\");\n        this.derivs = 0;\n        if (primePos > 0) {\n            this.name = name.slice(0,primePos);\n            this.derivs = name.slice(primePos).length;\n        } else {\n            this.name = name;\n        }\n        if (typeof inputExpr == 'undefined')\n            inputExpr = new expression();\n        this.inputs = [inputExpr];\n        inputExpr.parent = this;\n        this.domain = restrictDomain;\n\n        this.alternate = null;\n        this.builtin = true;\n        switch(this.name) {\n            case 'asin':\n            case 'acos':\n            case 'atan':\n            case 'asec':\n            case 'acsc':\n            case 'acot':\n                this.name = 'arc'+this.name.slice(1,4);\n                break;\n            case 'log':\n                this.name = 'ln';\n                break;\n            case 'sin':\n            case 'cos':\n            case 'tan':\n            case 'csc':\n            case 'sec':\n            case 'cot':\n            case 'arcsin':\n            case 'arccos':\n            case 'arctan':\n            case 'arcsec':\n            case 'arccsc':\n            case 'arccot':\n            case 'sqrt':\n            case 'root':\n            case 'abs':\n            case 'exp':\n            case 'expb':\n            case 'ln':\n            case 'log10':\n                break;\n            default:\n                this.builtin = false;\n                break;\n        }\n        // If using a derivative of a known function, then we should compute that in advance.\n        if (this.builtin && this.derivs > 0) {\n            var xvar = new variable_expr(this.menv, \"x\");\n            var deriv = new function_expr(this.menv, this.name, xvar);\n            for (var i=0; i<this.derivs; i++) {\n                deriv = deriv.derivative(xvar, {\"x\":0});\n            }\n            var binding = {};\n            binding[\"x\"] = inputExpr;\n            this.alternate = deriv.compose(binding);\n        }\n    }\n\n    getName() {\n        return (this.name + \"'\".repeat(this.derivs));\n    }\n\n    toString(elementOnly) {\n        var fcnString, retString;\n        if (typeof elementOnly == 'undefined') {\n            elementOnly = false;\n        }\n        fcnString = this.getName();\n        if (elementOnly) {\n            retString = fcnString;\n        } else {\n            var argStrings = [];\n            if (this.inputs.length == 0 || typeof this.inputs[0] == 'undefined') {\n                argStrings.push('?');\n            } else {\n                for (var i in this.inputs) {\n                    argStrings.push(this.inputs[i].toString());\n                }\n            }\n            retString = fcnString + '(' + argStrings.join(',') + ')';\n        }\n        return(retString);\n    }\n\n    // Return an array containing all tested equivalent strings.\n    allStringEquivs() {\n        var allInputs = [], inputOptions = [];\n        for (var i in this.inputs) {\n            inputOptions.push(this.inputs[i].allStringEquivs());\n        }\n        var retValue = [];\n        var fcnString = this.getName();\n        // Want to create a list of all possible input representations.\n        function generateArgs(left, rightOptions) {\n            if (rightOptions.length==0) {\n                allInputs.push(left);\n            } else {\n                var N = left.length;\n                var newLeft = [];\n                for (var k in left) {\n                    newLeft.push(left[k]);\n                }\n                for (var k in rightOptions[0]) {\n                    newLeft[N] = rightOptions[0][k];\n                    generateArgs(newLeft, rightOptions.slice(1));\n                }\n            }\n        }\n        generateArgs([], inputOptions);\n        for (var i in allInputs) {\n            retValue[i] = fcnString+'(' + allInputs[i].join('+') + ')';\n        }\n\n        return(retValue);\n    }\n\n    toTeX(showSelect) {\n        if (typeof showSelect == 'undefined') {\n            showSelect = false;\n        }\n        var texString = '';\n        var fcnString;\n        var argStrings = [];\n        if (typeof this.inputs[0] == 'undefined') {\n            argStrings.push('?');\n        } else {\n            for (var i in this.inputs) {\n                argStrings.push(this.inputs[i].toTeX(showSelect));\n                if (showSelect && this.select) {\n                    argStrings[i] = \"{\\\\color{blue}\" + argStrings[i] + \"}\";\n                }\n            }\n        }\n\n        switch(this.name) {\n            case 'sin':\n                fcnString = '\\\\sin';\n                break;\n            case 'cos':\n                fcnString = '\\\\cos';\n                break;\n            case 'tan':\n                fcnString = '\\\\tan';\n                break;\n            case 'csc':\n                fcnString = '\\\\csc';\n                break;\n            case 'sec':\n                fcnString = '\\\\sec';\n                break;\n            case 'cot':\n                fcnString = '\\\\cot';\n                break;\n            case 'arcsin':\n                fcnString = '\\\\sin^{-1}';\n                break;\n            case 'arccos':\n                fcnString = '\\\\cos^{-1}';\n                break;\n            case 'arctan':\n                fcnString = '\\\\tan^{-1}';\n                break;\n            case 'arccsc':\n                fcnString = '\\\\csc^{-1}';\n                break;\n            case 'arcsec':\n                fcnString = '\\\\sec^{-1}';\n                break;\n            case 'arccot':\n                fcnString = '\\\\cot^{-1}';\n                break;\n            case 'sqrt':\n                fcnString = '\\\\mathrm{sqrt}';\n                texString = '\\\\sqrt{' + argStrings[0] + '}';\n                break;\n            case 'root':\n                fcnString = '\\\\mathrm{root}';\n                texString = '\\\\sqrt[' + argStrings[1] +']{' + argStrings[0] + '}';\n                break;\n            case 'abs':\n                fcnString = '\\\\abs';\n                texString = '\\\\left|' + argStrings[0] + '\\\\right|';\n                break;\n            case 'exp':\n                fcnString = 'e^';\n                texString = 'e^{' + argStrings[0] + '}';\n                break;\n            case 'expb':\n                fcnString = '\\\\exp';\n                break;\n            case 'ln':\n                fcnString = '\\\\ln'\n                break;\n            case 'log10':\n                fcnString = '\\\\log_{10}'\n                break;\n            default:\n                if (this.name.length > 1) {\n                    fcnString = '\\\\mathrm{' + this.name + '}';\n                } else {\n                    fcnString = this.name;\n                }\n                break;\n        }\n        if (this.derivs > 0) {\n            if (this.derivs <= 3) {\n                fcnString = fcnString + \"'\".repeat(this.derivs);\n            } else {\n                fcnString = fcnString + \"^{(\"+this.derivs+\")}\";\n            }\n        }\n\n        if (showSelect && this.select) {\n            fcnString = \"\\\\color{red}{\" + fcnString + \"}\";\n            texString = '';\n        }\n        if (texString == '') {\n            texString = fcnString + ' \\\\mathopen{}\\\\left(' + argStrings.join(',') + '\\\\right)\\\\mathclose{}';\n        }\n        return(texString);\n    }\n\n    toMathML() {\n        var texString;\n        var argString;\n        if (typeof this.inputs[0] == 'undefined') {\n            argString = '?';\n        } else {\n            argString = this.inputs[0].toMathML();\n        }\n        switch(this.name) {\n            case 'sin':\n            case 'cos':\n            case 'tan':\n            case 'csc':\n            case 'sec':\n            case 'cot':\n            case 'arcsin':\n            case 'arccos':\n            case 'arctan':\n            case 'exp':\n            case 'expb':\n            case 'ln':\n            case 'abs':\n                texString = '<apply><' + this.name + '/>' + argString + '</apply>';\n                break;\n            case 'sqrt':\n                texString = '<apply><root/>' + argString + '</apply>';\n                break;\n            case 'log10':\n                texString = '<apply><log/><logbase><cn>10</cn></logbase>' + argString + '</apply>';\n                break;\n            default:\n                texString = '<apply><ci>' + this.name + '</ci>' + argString + '</apply>';\n                break;\n        }\n        return(texString);\n    }\n\n    operateToTeX() {\n        var fcnString;\n        switch(this.name) {\n            case 'sin':\n                fcnString = '\\\\sin';\n                break;\n            case 'cos':\n                fcnString = '\\\\cos';\n                break;\n            case 'tan':\n                fcnString = '\\\\tan';\n                break;\n            case 'csc':\n                fcnString = '\\\\csc';\n                break;\n            case 'sec':\n                fcnString = '\\\\sec';\n                break;\n            case 'cot':\n                fcnString = '\\\\cot';\n                break;\n            case 'arcsin':\n                fcnString = '\\\\sin^{-1}';\n                break;\n            case 'arccos':\n                fcnString = '\\\\cos^{-1}';\n                break;\n            case 'arctan':\n                fcnString = '\\\\tan^{-1}';\n                break;\n            case 'arccsc':\n                fcnString = '\\\\csc^{-1}';\n                break;\n            case 'arcsec':\n                fcnString = '\\\\sec^{-1}';\n                break;\n            case 'arccot':\n                fcnString = '\\\\cot^{-1}';\n                break;\n            case 'sqrt':\n                fcnString = '\\\\mathrm{sqrt}';\n                break;\n            case 'abs':\n                fcnString = '\\\\abs';\n                break;\n            case 'exp':\n            case 'expb':\n                fcnString = '\\\\exp';\n                break;\n            case 'ln':\n                fcnString = '\\\\ln'\n                break;\n            case 'log10':\n                fcnString = '\\\\log_{10}'\n                break;\n            default:\n                if (this.name.length > 1) {\n                    fcnString = '\\\\mathrm{' + this.name + '}';\n                } else {\n                    fcnString = this.name;\n                }\n                break;\n        }\n        if (this.derivs > 0) {\n            if (this.derivs <= 3) {\n                fcnString = fcnString + \"'\".repeat(this.derivs);\n            } else {\n                fcnString = fcnString + \"^{(\"+this.derivs+\")}\";\n            }\n        }\n\n        return(fcnString+\"(\\\\Box)\");\n    }\n\n    evaluate(bindings) {\n        var inputVal = this.inputs[0].evaluate(bindings);\n        var retVal = undefined;\n\n        if (inputVal == undefined) {\n            return(undefined);\n        }\n\n        // Built-in functions with derivatives have computed derivative earlier.\n        if (this.builtin && this.derivs > 0) {\n            if (this.alternate != undefined) {\n                retVal = this.alternate.evaluate(bindings);\n            } else {\n                console.log(\"Error: Built-in function called with unspecified derivative formula.\");\n            }\n        } else {\n            if (bindings[this.name] == undefined) {\n                // Check the list of common mathematical functions.\n                switch(this.name) {\n                    case 'sin':\n                        retVal = Math.sin(inputVal);\n                        break;\n                    case 'cos':\n                        retVal = Math.cos(inputVal);\n                        break;\n                    case 'tan':\n                        retVal = Math.tan(inputVal);\n                        break;\n                    case 'csc':\n                        retVal = 1/Math.sin(inputVal);\n                        break;\n                    case 'sec':\n                        retVal = 1/Math.cos(inputVal);\n                        break;\n                    case 'cot':\n                        retVal = 1/Math.tan(inputVal);\n                        break;\n                    case 'arcsin':\n                        if (Math.abs(inputVal) <= 1) {\n                            retVal = Math.asin(inputVal);\n                        }\n                        break;\n                    case 'arccos':\n                        if (Math.abs(inputVal) <= 1) {\n                            retVal = Math.acos(inputVal);\n                        }\n                        break;\n                    case 'arctan':\n                        retVal = Math.atan(inputVal);\n                        break;\n                    case 'arccsc':\n                        if (Math.abs(inputVal) >= 1) {\n                            retVal = Math.asin(1/inputVal);\n                        }\n                        break;\n                    case 'arcsec':\n                        if (Math.abs(inputVal) >= 1) {\n                            retVal = Math.acos(1/inputVal);\n                        }\n                        break;\n                    case 'arccot':\n                        if (inputVal == 0) {\n                            retVal = Math.PI/2;\n                        } else {\n                            retVal = Math.PI/2 - Math.atan(1/inputVal);\n                        }\n                        break;\n                    case 'sqrt':\n                        if (inputVal >= 0) {\n                            retVal = Math.sqrt(inputVal);\n                        }\n                        break;\n                    case 'abs':\n                        retVal = Math.abs(inputVal);\n                        break;\n                    case 'exp':\n                    case 'expb':\n                        retVal = Math.exp(inputVal);\n                        break;\n                    case 'ln':\n                        if (inputVal > 0) {\n                            retVal = Math.log(inputVal);\n                        }\n                        break;\n                    case 'log10':\n                        if (inputVal > 0) {\n                            retVal = Math.LOG10E * Math.log(inputVal);\n                        }\n                        break;\n                    default:\n                        // See if we have already used this function.\n                        // For consistency, we should keep it the same.\n                        var functionEntry = this.menv.functions[this.name];\n                        // If never used previously, generate a random function.\n                        // This will allow valid comparisons to occur.\n                        if (functionEntry == undefined) {\n                            console.log(\"Error: A custom function never had a backend definition.\");\n                        }\n                        // Copy the bindings.\n                        var fBind = {};\n                        Object.keys(bindings).forEach(function(key) {\n                            fBind[ key ] = bindings[ key ];\n                        });\n                        // Now, use the variable of the function.\n                        var inVar = functionEntry[\"input\"];\n                        if (Array.isArray(inVar)) {\n                            console.log(\"Error: Function is defined to expect multiple inputs. Not yet implemented.\");\n                        }\n                        fBind[inVar] = inputVal;\n                        // See if we need additional derivatives in binding\n                        if (this.derivs >= functionEntry[\"value\"].length) {\n                            var ivar = new variable_expr(this.menv, inVar);\n                            var varBind = {};\n                            varBind[ivar] = 0;\n                            for (var i=functionEntry[\"value\"].length; i <= this.derivs; i++) {\n                                functionEntry[\"value\"][i] = functionEntry[\"value\"][i-1].derivative(ivar, varBind);\n                            }\n                        }\n                        retVal = functionEntry[\"value\"][this.derivs].evaluate(fBind);\n                        break;\n                }\n            } else {\n                var functionEntry = bindings[this.name];\n                // Copy the bindings.\n                var fBind = {};\n                Object.keys(bindings).forEach(function(key) {\n                    fBind[ key ] = bindings[ key ];\n                });\n                // Now, use the variable of the function.\n                var inVar = functionEntry[\"input\"];\n                if (Array.isArray(inVar)) {\n                    console.log(\"Error: Function is defined to expect multiple inputs. Not yet implemented.\");\n                }\n                fBind[inVar] = inputVal;\n                // See if we need additional derivatives in binding\n                if (this.derivs >= functionEntry[\"value\"].length) {\n                    var ivar = new variable_expr(this.menv, inVar);\n                    var varBind = {};\n                    varBind[ivar] = 0;\n                    for (var i=functionEntry[\"value\"].length; i <= this.derivs; i++) {\n                        functionEntry[\"value\"][i] = functionEntry[\"value\"][i-1].derivative(ivar, varBind);\n                    }\n                }\n                retVal = functionEntry[\"value\"][this.derivs].evaluate(fBind);\n            }\n        }\n        return(retVal);\n    }\n\n    flatten() {\n        return(new function_expr(this.menv, this.getName(), this.inputs[0].flatten()));\n    }\n\n    copy() {\n      return(new function_expr(this.menv, this.getName(), this.inputs[0].copy()));\n    }\n\n    compose(bindings) {\n        return(new function_expr(this.menv, this.getName(), this.inputs[0].compose(bindings)));\n    }\n\n    derivative(ivar, varList) {\n        var theDeriv;\n        var depArray = this.inputs[0].dependencies();\n        var uConst = true;\n        var ivarName = (typeof ivar == 'string') ? ivar : ivar.name;\n        for (var i=0; i<depArray.length; i++) {\n            if (depArray[i] == ivarName) {\n                uConst = false;\n            }\n        }\n\n        if (uConst) {\n            theDeriv = new scalar_expr(this.menv, 0);\n        } else {\n            var dydu;\n\n            switch(this.name) {\n                    case 'sin':\n                        dydu = new function_expr(this.menv, 'cos', this.inputs[0]);\n                        break;\n                    case 'cos':\n                        dydu = new unop_expr(this.menv, '-', new function_expr(this.menv, 'sin', this.inputs[0]));\n                        break;\n                    case 'tan':\n                        var theSec = new function_expr(this.menv, 'sec', this.inputs[0]);\n                        dydu = new binop_expr(this.menv, '^', theSec, new scalar_expr(this.menv, 2));\n                        break;\n                    case 'csc':\n                        var theCot = new function_expr(this.menv, 'cot', this.inputs[0]);\n                        dydu = new unop_expr(this.menv, '-', new binop_expr(this.menv, '*', this, theCot));\n                        break;\n                    case 'sec':\n                        var theTan = new function_expr(this.menv, 'tan', this.inputs[0]);\n                        dydu = new binop_expr(this.menv, '*', this, theTan);\n                        break;\n                    case 'cot':\n                        var theCsc = new function_expr(this.menv, 'csc', this.inputs[0]);\n                        dydu = new unop_expr(this.menv, '-', new binop_expr(this.menv, '^', theCsc, new scalar_expr(this.menv, 2)));\n                        break;\n                    case 'arcsin':\n                        var theCos = new binop_expr(this.menv, '-', new scalar_expr(this.menv, 1), new binop_expr(this.menv, '^', this.inputs[0], new scalar_expr(this.menv, 2)));\n                        dydu = new binop_expr(this.menv, '/', new scalar_expr(this.menv, 1), new function_expr(this.menv, 'sqrt', theCos));\n                        break;\n                    case 'arccos':\n                        var theSin = new binop_expr(this.menv, '-', new scalar_expr(this.menv, 1), new binop_expr(this.menv, '^', this.inputs[0], new scalar_expr(this.menv, 2)));\n                        dydu = new binop_expr(this.menv, '/', new scalar_expr(this.menv, -1), new function_expr(this.menv, 'sqrt', theSin));\n                        break;\n                    case 'arctan':\n                        var tanSq = new binop_expr(this.menv, '^', this.inputs[0], new scalar_expr(this.menv, 2));\n                        dydu = new binop_expr(this.menv, '/', new scalar_expr(this.menv, 1), new binop_expr(this.menv, '+', new scalar_expr(this.menv, 1), tanSq));\n                        break;\n                    case 'arcsec':\n                        var theSq = new binop_expr(this.menv, '^', this.inputs[0], new scalar_expr(this.menv, 2));\n                        var theRad = new binop_expr(this.menv, '-', theSq, new scalar_expr(this.menv, 1));\n                        dydu = new binop_expr(this.menv, '/', new scalar_expr(this.menv, 1), new binop_expr(this.menv, '*', new function_expr(this.menv, 'abs', this.inputs[0]), new function_expr(this.menv, 'sqrt', theRad)));\n                        break;\n                    case 'arccsc':\n                        var theSq = new binop_expr(this.menv, '^', this.inputs[0], new scalar_expr(this.menv, 2));\n                        var theRad = new binop_expr(this.menv, '-', theSq, new scalar_expr(this.menv, 1));\n                        dydu = new binop_expr(this.menv, '/', new scalar_expr(this.menv, -1), new binop_expr(this.menv, '*', new function_expr(this.menv, 'abs', this.inputs[0]), new function_expr(this.menv, 'sqrt', theRad)));\n                        break;\n                    case 'arccot':\n                        var cotSq = new binop_expr(this.menv, '^', this.inputs[0], new scalar_expr(this.menv, 2));\n                        dydu = new binop_expr(this.menv, '/', new scalar_expr(this.menv, -1), new binop_expr(this.menv, '+', new scalar_expr(this.menv, 1), cotSq));\n                        break;\n                    case 'sqrt':\n                        dydu = new binop_expr(this.menv, '/', new scalar_expr(this.menv, 1), new binop_expr(this.menv, '*', new scalar_expr(this.menv, 2), this));\n                        break;\n                    case 'abs':\n                        dydu = new binop_expr(this.menv, '/', this, this.inputs[0]);\n                        break;\n                    case 'exp':\n                    case 'expb':\n                        dydu = new function_expr(this.menv, this.name, this.inputs[0]);\n                        break;\n                    case 'ln':\n                        dydu = new binop_expr(this.menv, '/', new scalar_expr(this.menv, 1), this.inputs[0]);\n                        break;\n                    case 'log10':\n                        dydu = new binop_expr(this.menv, '/', new scalar_expr(this.menv, Math.LOG10E), this.inputs[0]);\n                        break;\n                    default:\n                        dydu = new function_expr(this.menv, this.getName()+\"'\", this.inputs[0]);\n                        break;\n            }\n            if (!uConst && this.inputs[0].type == exprType.variable) {\n                theDeriv = dydu;\n            } else {\n                var dudx = this.inputs[0].derivative(ivar, varList);\n\n                if (dudx == undefined) {\n                    theDeriv = undefined;\n                } else {\n                    theDeriv = new binop_expr(this.menv, '*', dydu, dudx);\n                }\n            }\n        }\n        return(theDeriv);\n    }\n}","/*!\n * BTM JavaScript Library v@VERSION\n * https://github.com/dbrianwalton/BTM\n *\n * Copyright D. Brian Walton\n * Released under the MIT license (https://opensource.org/licenses/MIT)\n *\n * Date: @DATE\n */\n\n/* ***************************************************\n* Define the Derivative of an Expression\n* *************************************************** */\n\nimport { expression } from \"./expression.js\"\nimport { variable_expr } from \"./variable_expr.js\"\nimport { exprType } from \"./BTM_root.js\"\n\nexport class deriv_expr extends expression {\n    constructor(menv, formula, variable, atValue) {\n        super(menv);\n        this.type = exprType.operator;\n        this.op = \"D\";\n        if (typeof formula == 'undefined')\n            formula = new expression(menv);\n        if (typeof variable == 'undefined') {\n            variable = new variable_expr(menv, 'x');\n        } else if (typeof variable == 'string') {\n            variable = new variable_expr(menv, variable);\n        }\n        this.ivar = variable;\n        this.ivarValue = atValue;\n        this.inputs = [formula];\n        this.isRate = false;\n        formula.parent = this;\n    }\n\n    toString() {\n        var theStr;\n        var exprStr, varStr, valStr;\n\n        varStr = this.ivar.toString();\n        exprStr = this.inputs[0].toString();\n        if (typeof this.ivarValue != 'undefined') {\n            valStr = this.ivarValue.toString();\n            theStr = \"D(\"+exprStr+\",\"+varStr+\",\"+valStr+\")\";\n        } else {\n            theStr = \"D(\"+exprStr+\",\"+varStr+\")\";\n        }\n        return(theStr);\n    }\n\n    toTeX(showSelect) {\n        var theStr;\n        var opStr, varStr, exprStr, valStr;\n\n        varStr = this.ivar.toTeX();\n        exprStr = this.inputs[0].toTeX();\n        if (this.isRate && this.inputs[0].type == exprType.variable) {\n            if (typeof this.ivarValue != 'undefined') {\n                valStr = this.ivarValue.toTeX();\n                theStr = \"\\\\left. \\\\frac{d\" + exprStr + \"}{d\"+varStr+\"} \\\\right|_{\"\n                    + varStr + \"=\" + valStr + \"}\";\n            } else {\n                theStr = \"\\\\frac{d\" + exprStr +\"}{d\"+varStr+\"}\";\n            }\n        } else {\n            if (typeof this.ivarValue != 'undefined') {\n                valStr = this.ivarValue.toTeX();\n                opStr = \"\\\\left. \\\\frac{d}{d\"+varStr+\"} \\\\right|_{\"\n                    + varStr + \"=\" + valStr + \"}\";\n            } else {\n                opStr = \"\\\\frac{d}{d\"+varStr+\"}\";\n            }\n            theStr = opStr + \"\\\\Big[\" + exprStr + \"\\\\Big]\";\n        }\n        return(theStr);\n    }\n\n    // Return an array containing all tested equivalent strings.\n    allStringEquivs() {\n        var allInputs = this.inputs[0].allStringEquivs();\n        var varStr, valStr;\n        var retValue = [];\n\n        varStr = this.ivar.toString();\n        if (typeof this.ivarValue != 'undefined') {\n            valStr = this.ivarValue.toString();\n        }\n        for (var i in allInputs) {\n            if (typeof this.ivarValue != 'undefined') {\n                retValue[i] = \"D(\"+allInputs[i]+\",\"+varStr+\",\"+valStr+\")\";\n            } else {\n                retValue[i] = \"D(\"+allInputs[i]+\",\"+varStr+\")\";\n            }\n        }\n\n        return(allInputs);\n    }\n\n    toMathML() {\n        var theStr;\n        var exprStr;\n\n        if (typeof this.inputs[0] == 'undefined') {\n            exprStr = '?';\n        } else {\n            exprStr = this.inputs[0].toMathML();\n        }\n        theStr = \"<apply><derivative/>\" + exprStr + \"</apply>\";\n\n        return(theStr);\n    }\n\n    evaluate(bindings) {\n        var retVal;\n        var derivExpr;\n        var dbind = {};\n\n        if (typeof this.ivarValue != 'undefined') {\n            dbind[this.ivar.name] = this.ivarValue;\n        }\n        // Compute the derivative of the expression, then evaluate at binding\n        derivExpr = this.inputs[0].derivative(this.ivar, bindings);\n        derivExpr = derivExpr.compose(dbind);\n        retVal = derivExpr.evaluate(bindings);\n        return(retVal);\n    }\n\n    simplifyConstants() {\n        return(this);\n    }\n\n    flatten() {\n      return (new deriv_expr(this.menv, this.inputs[0].flatten(), this.ivar, this.ivarValue));\n    }\n\n    copy() {\n      return (new deriv_expr(this.menv, this.inputs[0].copy(), this.ivar, this.ivarValue));\n    }\n\n\n    compose(bindings) {\n    }\n\n    derivative(ivar, varList) {\n        var dbind = {};\n\n        if (typeof this.ivarValue != 'undefined') {\n            dbind[this.ivar] = this.ivarValue;\n        }\n        // Evaluate the main expression using original binding\n        var firstDeriv = this.inputs[0].derivative(this.ivar, varList);\n        firstDeriv.compose(dbind);\n\n        // Now differentiate that expression using new binding.\n        return firstDeriv.derivative(ivar, varList);\n    }\n}\n","/*!\n * BTM JavaScript Library v@VERSION\n * https://github.com/dbrianwalton/BTM\n *\n * Copyright D. Brian Walton\n * Released under the MIT license (https://opensource.org/licenses/MIT)\n *\n * Date: @DATE\n */\n\nimport { rational_number } from \"./rational_number.js\"\n\n/* ****************************************************\n*    Routines for dealing with random values\n* **************************************************** */\n\n/* To use a seeded RNG, we rely on an open source project for the underlying mechanics. */\n\n/*////////////////////////////////////////////////////////////////\naleaPRNG 1.1\n//////////////////////////////////////////////////////////////////\nhttps://github.com/macmcmeans/aleaPRNG/blob/master/aleaPRNG-1.1.js\n//////////////////////////////////////////////////////////////////\nOriginal work copyright  2010 Johannes Baage, under MIT license\nThis is a derivative work copyright (c) 2017-2020, W. Mac\" McMeans, under BSD license.\nRedistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n////////////////////////////////////////////////////////////////*/\nfunction aleaPRNG() {\n    return( function( args ) {\n        \"use strict\";\n\n        const version = 'aleaPRNG 1.1.0';\n\n        var s0\n            , s1\n            , s2\n            , c\n            , uinta = new Uint32Array( 3 )\n            , initialArgs\n            , mashver = ''\n        ;\n\n        /* private: initializes generator with specified seed */\n        function _initState( _internalSeed ) {\n            var mash = Mash();\n\n            // internal state of generator\n            s0 = mash( ' ' );\n            s1 = mash( ' ' );\n            s2 = mash( ' ' );\n\n            c = 1;\n\n            for( var i = 0; i < _internalSeed.length; i++ ) {\n                s0 -= mash( _internalSeed[ i ] );\n                if( s0 < 0 ) { s0 += 1; }\n\n                s1 -= mash( _internalSeed[ i ] );\n                if( s1 < 0 ) { s1 += 1; }\n                \n                s2 -= mash( _internalSeed[ i ] );\n                if( s2 < 0 ) { s2 += 1; }\n            }\n\n            mashver = mash.version;\n\n            mash = null;\n        };\n\n        /* private: dependent string hash function */\n        function Mash() {\n            var n = 4022871197; // 0xefc8249d\n\n            var mash = function( data ) {\n                data = data.toString();\n                \n                // cache the length\n                for( var i = 0, l = data.length; i < l; i++ ) {\n                    n += data.charCodeAt( i );\n                    \n                    var h = 0.02519603282416938 * n;\n                    \n                    n  = h >>> 0;\n                    h -= n;\n                    h *= n;\n                    n  = h >>> 0;\n                    h -= n;\n                    n += h * 4294967296; // 0x100000000      2^32\n                }\n                return ( n >>> 0 ) * 2.3283064365386963e-10; // 2^-32\n            };\n\n            mash.version = 'Mash 0.9';\n            return mash;\n        };\n\n\n        /* private: check if number is integer */\n        function _isInteger( _int ) { \n            return parseInt( _int, 10 ) === _int; \n        };\n\n        /* public: return a 32-bit fraction in the range [0, 1]\n        This is the main function returned when aleaPRNG is instantiated\n        */\n        var random = function() {\n            var t = 2091639 * s0 + c * 2.3283064365386963e-10; // 2^-32\n            \n            s0 = s1;\n            s1 = s2;\n\n            return s2 = t - ( c = t | 0 );\n        };\n\n        /* public: return a 53-bit fraction in the range [0, 1] */\n        random.fract53 = function() {\n            return random() + ( random() * 0x200000  | 0 ) * 1.1102230246251565e-16; // 2^-53\n        };\n\n        /* public: return an unsigned integer in the range [0, 2^32] */\n        random.int32 = function() {\n            return random() * 0x100000000; // 2^32\n        };\n\n        /* public: advance the generator the specified amount of cycles */\n        random.cycle = function( _run ) {\n            _run = typeof _run === 'undefined' ? 1 : +_run;\n            if( _run < 1 ) { _run = 1; }\n            for( var i = 0; i < _run; i++ ) { random(); }\n        };\n\n        /* public: return inclusive range */\n        random.range = function() { \n            var loBound\n                , hiBound\n            ;\n            \n            if( arguments.length === 1 ) {\n                loBound = 0;\n                hiBound = arguments[ 0 ];\n\n            } else {\n                loBound = arguments[ 0 ];\n                hiBound = arguments[ 1 ];\n            }\n\n            if( arguments[ 0 ] > arguments[ 1 ] ) { \n                loBound = arguments[ 1 ];\n                hiBound = arguments[ 0 ];\n            }\n\n            // return integer\n            if( _isInteger( loBound ) && _isInteger( hiBound ) ) { \n                return Math.floor( random() * ( hiBound - loBound + 1 ) ) + loBound; \n\n            // return float\n            } else {\n                return random() * ( hiBound - loBound ) + loBound; \n            }\n        };\n\n        /* public: initialize generator with the seed values used upon instantiation */\n        random.restart = function() {\n            _initState( initialArgs );\n        };\n\n        /* public: seeding function */\n        random.seed = function() { \n            _initState( Array.prototype.slice.call( arguments ) );\n        }; \n\n        /* public: show the version of the RNG */\n        random.version = function() { \n            return version;\n        }; \n\n        /* public: show the version of the RNG and the Mash string hasher */\n        random.versions = function() { \n            return version + ', ' + mashver;\n        }; \n\n        // when no seed is specified, create a random one from Windows Crypto (Monte Carlo application) \n        if( args.length === 0 ) {\n             window.crypto.getRandomValues( uinta );\n             args = [ uinta[ 0 ], uinta[ 1 ], uinta[ 2 ] ];\n        };\n\n        // store the seed used when the RNG was instantiated, if any\n        initialArgs = args;\n\n        // initialize the RNG\n        _initState( args );\n\n        return random;\n\n    })( Array.prototype.slice.call( arguments ) );\n};\n\nexport class RNG {\n    constructor(rngSettings) {\n        if (rngSettings.rand) {\n          this.rand = rngSettings.rand;\n        } else {\n          let seed;\n          if (rngSettings.seed == undefined) {\n            seed = new Date().getTime().toString();\n          } else {\n            seed = rngSettings.seed;\n          }\n          this.rand = aleaPRNG(seed);\n        }\n    }\n\n    setSeed(seed) {\n        this.alea.seed(seed.toString());\n    }\n\n    // Standard uniform generator values in [0,1)\n    random() {\n        return(this.rand());\n    }\n\n    // Randomly choose +1 or -1.\n    randSign() {\n        var a = 2*Math.floor(2*this.random())-1;\n        return(a);\n    }\n\n    // Randomly choose integer uniformly in {min, ..., max}.\n    randInt(min, max) {\n        var a = min+Math.floor( (max-min+1)*this.random() );\n        return(a);\n    }\n    \n    // Randomly choose floating point uniformly in [min,max)\n    randUniform(min, max) {\n        var a = min+(max-min)*this.random();\n        return(a);\n    }\n\n    // Randomly choose floating point uniformly in [min,max)\n    randDiscrete(min, max, by, nonzero) {\n        if (arguments.length < 3 || by == 0) {\n            by = 1;\n        }\n        if (arguments.length < 4) {\n            nonzero=false;\n        }\n        var rndVal;\n        let Nvals = Math.floor((max-min) / by)+1;\n        do {\n            rndVal = min + by * this.randInt(0,Nvals-1);\n        } while (nonzero && Math.abs(rndVal) < 1e-16);\n        return(rndVal);\n    }\n\n    // Randomly a k-length permuted subsequence of {min, ..., max}\n    randChoice(min, max, k) {\n        var a = new Array();\n        var b = new Array();\n        var i,j;\n        for (i=0; i<=max-min; i++) {\n            a[i] = min+i;\n        }\n        for (i=0; i<k; i++) {\n            j = Math.floor( (max-min+1-i)*this.random() );\n            b[i] = a.splice(j,1)[0];\n        }\n\n        return (b);\n    }\n\n    // Generate a random rational number, passing in 2-len arrays for limits.\n    randRational(pLims, qLims) {\n        var p, q;\n\n        // Find the raw rational number\n        p = this.randInt(pLims[0], pLims[1]);\n        q = this.randInt(qLims[0], qLims[1]);\n\n        return (new rational_number(p,q));\n    }\n\n    // Generate a random hex code of desired length.\n    randHexHash(n) {\n      var hash = '';\n      var chars = '0123456789abcdef';\n      for (var i=0; i<n; i++) {\n        hash += chars[this.randInt(0,15)];\n      }\n      return hash;\n    }\n}","/*!\n * BTM JavaScript Library v@VERSION\n * https://github.com/dbrianwalton/BTM\n *\n * Copyright D. Brian Walton\n * Released under the MIT license (https://opensource.org/licenses/MIT)\n *\n * Date: @DATE\n */\n\n/* ***********************\n** Evaluating expressions occurs in the context of a BTM environment.\n************************* */\n\nimport { defaultReductions, defaultSumReductions, defaultProductReductions, disableRule, newRule, findMatchRules } from \"./reductions.js\"\nimport { scalar_expr } from \"./scalar_expr.js\";\nimport { variable_expr, index_expr } from \"./variable_expr.js\";\nimport { unop_expr } from \"./unop_expr.js\";\nimport { binop_expr } from \"./binop_expr.js\";\nimport { multiop_expr } from \"./multiop_expr.js\";\nimport { function_expr } from \"./function_expr.js\";\nimport { deriv_expr } from \"./deriv_expr.js\";\nimport { RNG } from \"./random.js\"\nimport { expression } from \"./expression.js\";\n\nexport const opPrec = {\n    disj: 0,\n    conj: 1,\n    equal: 2,\n    addsub: 3,\n    multdiv: 4,\n    power: 5,\n    fcn: 6,\n    fop: 7\n};\n\nexport const exprType = {\n    number: 0,\n    variable: 1,\n    fcn: 2,\n    unop: 3,\n    binop: 4,\n    multiop: 5,\n    operator: 6,\n    array: 7,\n    matrix: 8\n};\n\nexport const exprValue = { undef: -1, bool : 0, numeric : 1 };\n\nexport function toTeX(expr) {\n    return typeof expr.toTeX === \"function\" ? expr.toTeX() : expr;\n}\n\n// Class to define parsing and reduction rules.\nexport class MENV {\n    constructor(settings) {\n        if (settings === undefined) {\n            settings = {};\n            settings.seed = '1234';\n        }\n        // Each instance of BTM environment needs bindings across all expressions.\n        this.randomBindings = {};\n        this.bindings = {};\n        this.functions = {};\n        this.opPrec = opPrec;\n        this.exprType = exprType;\n        this.exprValue = exprValue;\n        this.options = {\n            negativeNumbers: true,\n            absTol: 1e-8,\n            relTol: 1e-4,\n            useRelErr: true,\n            doFlatten: false \n        };\n        this.setReductionRules();\n        this.multiop_expr = multiop_expr;\n        this.binop_expr = binop_expr;\n\n        // Generate a random generator. We might be passed either a pre-seeded `rand` function or a seed for our own.\n        let rngOptions = {};\n        if (typeof settings.rand !== 'undefined') {\n            rngOptions.rand = settings.rand;\n        }\n        if (typeof settings.seed !== 'undefined') {\n            rngOptions.seed = settings.seed;\n        }\n        rngOptions.absTol = this.options.absTol;\n        this.rng = new RNG(rngOptions);\n    }\n\n    // Perform approximate comparison tests using environment settings\n    // a < b: -1\n    // a ~= b: 0\n    // a > b: 1\n    numberCmp(a,b,override) {\n        // Work with actual values.\n        var valA, valB, cmpResult;\n        var useRelErr = this.options.useRelErr,\n            relTol = this.options.relTol,\n            absTol = this.options.absTol;\n\n        if (typeof a === 'number' || typeof a === 'Number') {\n            valA = a;\n        } else {\n            valA = a.value();\n        }\n        if (typeof b === 'number' || typeof b === 'Number') {\n            valB = b;\n        } else {\n            valB = b.value();\n        }\n\n        // Pull out the options.\n        if (typeof override !== 'undefined') {\n            if (typeof override.useRelErr !== 'undefined') {\n                useRelErr = override.useRelErr;\n            }\n            if (typeof override.relTol !== 'undefined') {\n                relTol = override.relTol;\n            }\n            if (typeof override.absTol !== 'undefined') {\n                absTol = override.absTol;\n            }\n        }\n\n        if (!useRelErr || Math.abs(valA) < absTol) {\n            if (Math.abs(valB-valA) < absTol) {\n                cmpResult = 0;\n            } else if (valA < valB) {\n                cmpResult = -1;\n            } else {\n                cmpResult = 1;\n            }\n        } else {\n            if (Math.abs(valB-valA)/Math.abs(valA) < relTol) {\n                cmpResult = 0;\n            } else if (valA < valB) {\n                cmpResult = -1;\n            } else {\n                cmpResult = 1;\n            }\n        }\n        return cmpResult;\n    }\n\n    /* Block of methods to deal with reduction rules in context */\n    setReductionRules() {\n        this.reduceRules = defaultReductions(this);\n    }\n\n    addReductionRule(equation, description, useOneWay) {\n        newRule(this, this.reduceRules, equation, description, true, useOneWay);\n    }\n\n    disableReductionRule(equation) {\n        disableRule(this, this.reduceRules, equation);\n    }\n\n    addRule(ruleList, equation, description, useOneWay){\n        newRule(this, ruleList, equation, description, true, useOneWay);\n    }\n\n    findMatchRules(reductionList, testExpr, doValidate) {\n        return findMatchRules(reductionList, testExpr, doValidate);\n    }\n\n    generateRandom(distr, options) {\n        var rndVal, rndScalar;\n        var min, max, by, nonzero;\n        switch (distr) {\n            case 'uniform':\n                min=options.min;\n                if (typeof min.value === 'function') {\n                    min = min.value();\n                }\n                if (min == undefined) {\n                    min = 0;\n                }\n                max=options.max;\n                if (typeof max.value === 'function') {\n                    max = max.value();\n                }\n                if (max == undefined) {\n                    max = 1;\n                }\n                rndVal = this.rng.randUniform(min,max);\n                break;\n            case 'sign':\n                rndVal = this.rng.randSign();\n                break;\n            case 'integer':\n                min=options.min;\n                if (typeof min.value === 'function') {\n                    min = min.value();\n                }\n                if (min == undefined) {\n                    min = 0;\n                }\n                min = Math.floor(min);\n                max=options.max;\n                if (typeof max.value === 'function') {\n                    max = max.value();\n                }\n                if (max == undefined) {\n                    max = 1;\n                }\n                max = Math.floor(max);\n                rndVal = this.rng.randInt(min,max);\n                break;\n            case 'discrete':\n                min = options.min;\n                if (typeof min.value === 'function') {\n                    min = min.value();\n                }\n                max = options.max;\n                if (typeof max.value === 'function') {\n                    max = max.value();\n                }\n                by = options.by;\n                if (typeof by.value === 'function') {\n                    by = by.value();\n                }\n                nonzero = options.nonzero ? true : false;\n                rndVal = this.rng.randDiscrete(min,max,by,nonzero);\n                break;\n        }\n        rndScalar = new scalar_expr(this, rndVal);\n        return rndScalar;\n    }\n\n    addFunction(name, input, expression) {\n        if (arguments.length < 2) {\n            input = \"x\";\n        }\n        // No expression? Make it random.\n        if (arguments.length < 3) {\n            var formula = new scalar_expr(this, this.rng.randRational([-20,20],[1,15]));\n            var newTerm;\n            for (var i=1; i<=6; i++) {\n                if (Array.isArray(input)) {\n                    newTerm = this.parse(\"sin(\"+i+\"*\"+input[0]+\")\", \"formula\");\n                    for (var j=1; j<input.length; j++) {\n                        newTerm = new binop_expr(this, \"*\",\n                            this.parse(\"sin(\"+i+\"*\"+input[j]+\")\", \"formula\"),\n                            newTerm\n                        );\n                    }\n                } else {\n                    newTerm = this.parse(\"sin(\"+i+\"*\"+input+\")\", \"formula\");\n                }\n                newTerm = new binop_expr(this, \"*\",\n                                new scalar_expr(this, this.rng.randRational([-20,20],[1,10])),\n                                newTerm);\n                formula = new binop_expr(this, \"+\", formula, newTerm);\n            }\n            expression = formula;\n        }\n        var functionEntry = {};\n        functionEntry[\"input\"] = input;\n        functionEntry[\"value\"] = expression;\n        this.functions[name] = functionEntry;\n    }\n\n    compareMathObjects(expr1, expr2) {\n        if (typeof expr1 === 'string') {\n            expr1 = this.parse(expr1, \"formula\")\n        }\n        if (typeof expr2 === 'string') {\n            expr2 = this.parse(expr2, \"formula\")\n        }\n        return (expr1.compare(expr2));\n    }\n\n    getParser(context) {\n        var self=this,\n            parseContext=context;\n        return (function(exprString){ return self.parse(exprString, parseContext); })\n    }\n \n  /* ****************************************\n    parse() is the workhorse.\n\n      Take a string representing a formula, and decompose it into an appropriate\n      tree structure suitable for recursive evaluation of the function.\n      Returns the root element to the tree.\n  ***************************************** */\n  parse(formulaStr, context, bindings, options) {\n    if (arguments.length < 2) {\n        context = \"formula\";\n    }\n    if (arguments.length < 3) {\n      bindings = {};\n    }\n    if (arguments.length < 4) {\n      options = {};\n    }\n\n    const numberMatch = /\\d|(\\.\\d)/;\n    const nameMatch = /[a-zA-Z]/;\n    const unopMatch = /[\\+\\-/]/;\n    const opMatch = /[\\+\\-*/^=\\$&]/;\n\n    var charPos = 0, endPos;\n    var parseError = '';\n\n    // Strip any extraneous white space and parentheses.\n    var workingStr;\n    workingStr = formulaStr.trim();\n\n    // Test if parentheses are all balanced.\n    var hasExtraParens = true;\n    while (hasExtraParens) {\n      hasExtraParens = false;\n      if (workingStr.charAt(0) == '(') {\n        var endExpr = completeParenthesis(workingStr, 0);\n        if (endExpr+1 >= workingStr.length) {\n          hasExtraParens = true;\n          workingStr = workingStr.slice(1,-1);\n        }\n      }\n    }\n\n    // We build the tree as it is parsed. \n    // Two stacks keep track of operands (expressions) and operators\n    // which we will identify as the string is parsed left to right\n    // At the time an operand is parsed, we don't know to which operator \n    // it ultimately belongs, so we push it onto a stack until we know.\n    var operandStack = new Array();\n    var operatorStack = new Array();\n\n    // When an operator is pushed, we want to compare it to the previous operator\n    // and see if we need to apply the operators to some operands.\n    // This is based on operator precedence (order of operations).\n    // An empty newOp means to finish resolve the rest of the stacks.\n    function resolveOperator(menv, operatorStack, operandStack, newOp) {\n      // Test if the operator has lower precedence.\n      var oldOp = 0;\n      while (operatorStack.length > 0) {\n        oldOp = operatorStack.pop();\n        if (newOp && (newOp.type==exprType.unop || oldOp.prec < newOp.prec)) {\n            break;\n        }\n\n        // To get here, the new operator must be *binary*\n        // and the operator to the left has *higher* precedence.\n        // So we need to peel off the operator to the left with its operands\n        // to form an expression as a new compound operand for the new operator.\n        var newExpr;\n        // Unary: Either negative or reciprocal require *one* operand\n        if (oldOp.type == exprType.unop) {\n          if (operandStack.length > 0) {\n            var input = operandStack.pop();\n\n            // Deal with negative numbers separately.\n            if (menv.options.negativeNumbers && input.type == exprType.number && oldOp.op == '-') {\n              newExpr = new scalar_expr(menv, input.number.multiply(-1));\n            } else {\n              newExpr = new unop_expr(menv, oldOp.op, input);\n            }\n          } else {\n            newExpr = new expression(menv);\n            newExpr.setParsingError(\"Incomplete formula: missing value for \" + oldOp.op);\n          }\n        // Binary: Will be *two* operands.\n        } else {\n          if (operandStack.length > 1) {\n            var inputB = operandStack.pop();\n            var inputA = operandStack.pop();\n            newExpr = new binop_expr(menv, oldOp.op, inputA, inputB);\n          } else {\n            newExpr = new expression(menv);\n            newExpr.setParsingError(\"Incomplete formula: missing value for \" + oldOp.op);\n          }\n        }\n        operandStack.push(newExpr);\n        oldOp = 0;\n      }\n      // The new operator is unary or has higher precedence than the previous op.\n      // We need to push the old operator back on the stack to use later.\n      if (oldOp != 0) {\n        operatorStack.push(oldOp);\n      }\n      // A new operation was added to deal with later.\n      if (newOp) {\n        operatorStack.push(newOp);\n      }\n    }\n\n    // Now we begin to process the string representing the expression.\n    var lastElement = -1, newElement; // 0 for operand, 1 for operator.\n\n    // Read string left to right.\n    // Identify what type of math object starts at this character.\n    // Find the other end of that object by completion.\n    // Interpret that object, possibly through a recursive parsing.\n    for (charPos = 0; charPos<workingStr.length; charPos++) {\n      // Identify the next element in the string.\n      if (workingStr.charAt(charPos) == ' ') {\n        continue;\n\n      // It might be a close parentheses that was not matched on the left.\n      } else if (workingStr.charAt(charPos) == ')') {\n        // Treat this like an implicit open parenthesis on the left.\n        resolveOperator(this, operatorStack, operandStack);\n        newElement = 0;\n        lastElement = -1;\n\n      // It could be an expression surrounded by parentheses -- use recursion\n      } else if (workingStr.charAt(charPos) == '(') {\n        endPos = completeParenthesis(workingStr, charPos);\n        var subExprStr = workingStr.slice(charPos+1,endPos);\n        var subExpr = this.parse(subExprStr, context, bindings);\n        operandStack.push(subExpr);\n        newElement = 0;\n        charPos = endPos;\n\n      // It could be an absolute value\n      } else if (workingStr.charAt(charPos) == '|') {\n        endPos = completeAbsValue(workingStr, charPos);\n        var subExprStr = workingStr.slice(charPos+1,endPos);\n        var subExpr = this.parse(subExprStr, context, bindings);\n        var newExpr = new function_expr(this, 'abs', subExpr);\n        operandStack.push(newExpr);\n        newElement = 0;\n        charPos = endPos;\n\n      // It could be a number. Just read it off\n      } else if (workingStr.substr(charPos).search(numberMatch) == 0) {\n        endPos = completeNumber(workingStr, charPos, options);\n        var newExpr = new scalar_expr(this, new Number(workingStr.slice(charPos, endPos)));\n        if (options && options.noDecimals && workingStr.charAt(charPos) == '.') {\n          newExpr.setParsingError(\"Whole numbers only. No decimal values are allowed.\")\n        }\n        operandStack.push(newExpr);\n        newElement = 0;\n        charPos = endPos-1;\n\n      // It could be a name, either a function or variable.\n      } else if (workingStr.substr(charPos).search(nameMatch) == 0) {\n        endPos = completeName(workingStr, charPos);\n        var theName = workingStr.slice(charPos,endPos);\n        // If not a known name, break it down using composite if possible.\n        if (bindings[theName]=== undefined) {\n          // Returns the first known name, or theName not composite.\n          var testResults = TestNameIsComposite(theName, bindings);\n          if (testResults.isComposite) {\n            theName = testResults.name;\n            endPos = charPos + theName.length;\n          }\n        }\n        // Test if a function.\n        // Expand this once we allow parsing of user-defined functions.\n        if (workingStr.charAt(endPos) == '(' && \n            (bindings[theName]===undefined)) {\n          var endParen = completeParenthesis(workingStr, endPos);\n\n          var fcnName = theName;\n          var newExpr;\n          // See if this is a derivative\n          if (fcnName == 'D') {\n            var expr, ivar, ivarValue;\n            var entries = workingStr.slice(endPos+1,endParen).split(\",\");\n            expr = this.parse(entries[0], context, bindings);\n            if (entries.length == 1) {\n              newExpr = new deriv_expr(this, expr, 'x');\n            } else {\n              ivar = this.parse(entries[1], context, bindings);\n              // D(f(x),x,c) means f'(c)\n              if (entries.length > 2) {\n                ivarValue = this.parse(entries[2], context, bindings);\n              }\n              newExpr = new deriv_expr(this, expr, ivar, ivarValue);\n            }\n          } else {\n            var subExpr = this.parse(workingStr.slice(endPos+1,endParen), context, bindings);\n            newExpr = new function_expr(this, theName, subExpr);\n          }\n          operandStack.push(newExpr);\n          newElement = 0;\n          charPos = endParen;\n        }\n        // or a variable.\n        else {\n          // Test if needs index\n          if (workingStr.charAt(endPos) == '[') {\n            var endParen, hasError=false;\n            try {\n              endParen = completeBracket(workingStr, endPos, true);\n            } catch (error) {\n              parseError = error;\n              hasError = true;\n              endParen = endPos+1;\n            }\n            var indexExpr = this.parse(workingStr.slice(endPos+1,endParen), context, bindings);\n            var newExpr = new index_expr(this, theName, indexExpr);\n            if (hasError) {\n              newExpr.setParsingError(parseError);\n              parseError = \"\";\n            }\n            operandStack.push(newExpr);\n            newElement = 0;\n            charPos = endParen;\n          } else {\n            var newExpr = new variable_expr(this, theName);\n            operandStack.push(newExpr);\n            newElement = 0;\n            charPos = endPos-1;\n          }\n        }\n\n      // It could be an operator.\n      } else if (workingStr.substr(charPos).search(opMatch) == 0) {\n        newElement = 1;\n        var op = workingStr.charAt(charPos);\n        var newOp = new operator(op);\n\n        // Consecutive operators?    Better be sign change or reciprocal.\n        if (lastElement != 0) {\n          if (op == \"-\" || op == \"/\") {\n            newOp.type = exprType.unop;\n            newOp.prec = opPrec.multdiv;\n          } else {\n            // ERROR!!!\n            parseError = \"Error: consecutive operators\";\n          }\n        }\n        resolveOperator(this, operatorStack, operandStack, newOp);\n      }\n\n      // Two consecutive operands must have an implicit multiplication between them\n      if (lastElement == 0 && newElement == 0) {\n        var holdElement = operandStack.pop();\n\n        // Push a multiplication\n        var newOp = new operator('*');\n        resolveOperator(this, operatorStack, operandStack, newOp);\n\n        // Then restore the operand stack.\n        operandStack.push(holdElement);\n      }\n      lastElement = newElement;\n    }\n\n    // Now finish up the operator stack: nothing new to include\n    resolveOperator(this, operatorStack, operandStack);\n    var finalExpression = operandStack.pop();\n    if (parseError.length > 0) {\n        finalExpression.setParsingError(parseError);\n    } else {\n        // Substitute any expressions provided\n        finalExpression = finalExpression.compose(bindings);\n        // Test if context is consistent\n        switch (context) {\n            case 'number':\n                if (!finalExpression.isConstant()) {\n                    throw new TypeError(`The expression ${formulaStr} is expected to be a constant but depends on variables.`);\n                }\n                finalExpression.simplifyConstants();\n                break;\n            case 'formula':\n                break;\n        }\n        finalExpression.setContext(context);\n    }\n    if (options.doFlatten) {\n      finalExpression.flatten();\n    }\n    return finalExpression;\n  }\n}\n\n// Used in parse\nfunction operator(opStr) {\n  this.op = opStr;\n  switch(opStr) {\n    case '+':\n    case '-':\n      this.prec = opPrec.addsub;\n      this.type = exprType.binop;\n      this.valueType = exprValue.numeric;\n      break;\n    case '*':\n    case '/':\n      this.prec = opPrec.multdiv;\n      this.type = exprType.binop;\n      this.valueType = exprValue.numeric;\n      break;\n    case '^':\n      this.prec = opPrec.power;\n      this.type = exprType.binop;\n      this.valueType = exprValue.numeric;\n      break;\n    case '&':\n      this.prec = opPrec.conj;\n      this.type = exprType.binop;\n      this.valueType = exprValue.bool;\n      break;\n    case '$':  // $=or since |=absolute value bar\n//    this.op = '|'\n      this.prec = opPrec.disj;\n      this.type = exprType.binop;\n      this.valueType = exprValue.bool;\n      break;\n    case '=':\n      this.prec = opPrec.equal;\n      this.type = exprType.binop;\n      this.valueType = exprValue.bool;\n      break;\n    case ',':\n      this.prec = opPrec.fop;\n      this.type = exprType.array;\n      this.valueType = exprValue.vector;\n      break;\n    default:\n      this.prec = opPrec.fcn;\n      this.type = exprType.fcn;\n      break;\n  }\n}\n\n\n\n/* An absolute value can be complicated because also a function. \nMay not be clear if nested: |2|x-3|- 5|.\nIs that 2x-15 or abs(2|x-3|-5)?\nResolve by requiring explicit operations: |2*|x-3|-5| or |2|*x-3*|-5|\n*/\nfunction completeAbsValue(formulaStr, startPos) {\n    var pLevel = 1;\n    var charPos = startPos;\n    var wasOp = true; // open absolute value implicitly has previous operation.\n\n    while (pLevel > 0 && charPos < formulaStr.length) {\n        charPos++;\n        // We encounter another absolute value.\n        if (formulaStr.charAt(charPos) == '|') {\n            if (wasOp) { // Must be opening a new absolute value.\n                pLevel++;\n                // wasOp is still true since can't close immediately\n            } else {  // Assume closing absolute value. If not wanted, need operator.\n                pLevel--;\n                // wasOp is still false since just closed a value.\n            }\n        // Keep track of whether just had operator or not.\n        } else if (\"+-*/([\".search(formulaStr.charAt(charPos)) >= 0) {\n            wasOp = true;\n        } else if (formulaStr.charAt(charPos) != ' ') {\n            wasOp = false;\n        }\n    }\n    return(charPos);\n}\n\n// Find the balancing closing parenthesis.\nfunction completeParenthesis(formulaStr, startPos) {\n    var pLevel = 1;\n    var charPos = startPos;\n\n    while (pLevel > 0 && charPos < formulaStr.length) {\n        charPos++;\n        if (formulaStr.charAt(charPos) == ')') {\n            pLevel--;\n        } else if (formulaStr.charAt(charPos) == '(') {\n            pLevel++;\n        }\n    }\n    return(charPos);\n}\n\n// Brackets are used for sequence indexing, not regular grouping.\nfunction completeBracket(formulaStr, startPos, asSubscript) {\n    var pLevel = 1;\n    var charPos = startPos;\n    var fail = false;\n\n    while (pLevel > 0 && charPos < formulaStr.length) {\n        charPos++;\n        if (formulaStr.charAt(charPos) == ']') {\n            pLevel--;\n        } else if (formulaStr.charAt(charPos) == '[') {\n            if (asSubscript) {\n                fail = true;\n            }\n            pLevel++;\n        }\n    }\n    if (asSubscript && fail) {\n        throw \"Nested brackets used for subscripts are not supported.\";\n    }\n    return(charPos);\n}\n\n/* Given a string and a starting position of a name, identify the entire name. */\n/* Require start with letter, then any sequence of *word* character */\n/* Also allow primes for derivatives at the end. */\nfunction completeName(formulaStr, startPos) {\n    var matchRule = /[A-Za-z]\\w*'*/;\n    var match = formulaStr.substr(startPos).match(matchRule);\n    return(startPos + match[0].length);\n}\n\n/* Given a string and a starting position of a number, identify the entire number. */\nfunction completeNumber(formulaStr, startPos, options) {\n    var matchRule;\n    if (options && options.noDecimals) {\n        matchRule = /[0-9]*/;\n    } else {\n        matchRule = /[0-9]*(\\.[0-9]*)?(e-?[0-9]+)?/;\n    }\n    var match = formulaStr.substr(startPos).match(matchRule);\n    return(startPos + match[0].length);\n}\n\n/* Tests a string to see if it can be constructed as a concatentation of known names. */\n/* For example, abc could be a name or could be a*b*c */\n/* Pass in the bindings giving the known names and see if we can build this name */\n/* Return the *first* name that is part of the whole. */\nfunction TestNameIsComposite(text, bindings) {\n    var retStruct = new Object();\n    retStruct.isComposite = false;\n\n    if (bindings !== undefined) {\n        var remain, nextName;\n        if (bindings[text] !== undefined) {\n            retStruct.isComposite = true;\n            retStruct.name = text;\n        } else {\n            // See if the text *starts* with a known name\n            var knownNames = Object.keys(bindings);\n            for (var ikey in knownNames) {\n                nextName = knownNames[ikey];\n                // If *this* name is the start of the text, see if the rest from known names.\n                if (text.search(nextName)==0) {\n                    remain = TestNameIsComposite(text.slice(nextName.length), bindings);\n                    if (remain.isComposite) {\n                        retStruct.isComposite = true;\n                        retStruct.name = nextName;\n                        break;\n                    }\n                }\n            }\n        }\n    }\n    return retStruct;\n}\n  \nexport class BTM {\n    constructor(settings) {\n        this.menv = new MENV(settings);\n\n        // Each instance of BTM environment needs bindings across all expressions.\n        this.data = {};\n        this.data.allValues = {};\n        this.data.params = {};\n        this.data.variables = {};\n        this.data.expressions = {};\n    }\n\n\n    addMathObject(name, context, newObject) {\n        switch(context) {\n            case 'number':\n                if (newObject.isConstant()) {\n                    this.data.params[name] = newObject;\n                    this.data.allValues[name] = newObject;\n                } else {\n                    throw `Attempt to add math object '${name}' with context '${context}' that does not match.`;\n                }\n                break;\n            case 'formula':\n                this.data.allValues[name] = newObject;\n                break;\n        }\n        return newObject;\n    }\n\n    generateRandom(distr, options) {\n       return this.menv.generateRandom(distr,options);\n    }\n\n    addVariable(name, options) {\n        var newVar = new variable_expr(this.menv, name);\n        \n        this.data.variables[name] = newVar;\n        this.data.allValues[name] = newVar;\n\n        return newVar;\n    }\n\n    parseExpression(expression, context) {\n        var newExpr;\n        // Not yet parsed\n        if (typeof expression === 'string') {\n            var formula = this.decodeFormula(expression);\n            newExpr = this.menv.parse(formula, context, this.data.allValues)\n                            .compose(this.data.allValues);\n        // Already parsed\n        } else if (typeof expression === 'object') {\n            newExpr = expression;\n        }\n        return newExpr;\n    }\n\n    evaluateExpression(expression, context, bindings) {\n        var theExpr, newExpr, retValue;\n        // Not yet parsed\n        if (typeof expression === 'string') {\n            var formula = this.decodeFormula(expression);\n            theExpr = this.menv.parse(formula, \"formula\");\n        // Already parsed\n        } else if (typeof expression === 'object') {\n            theExpr = expression;\n        }\n        retValue = theExpr.evaluate(bindings);\n        newExpr = new scalar_expr(this.menv, retValue);\n        return newExpr;\n    }\n\n    composeExpression(expression, substitution) {\n        var myExpr;\n        // Not yet parsed\n        if (typeof expression === 'string') {\n            var formula = this.decodeFormula(expression);\n            myExpr = this.menv.parse(formula, \"formula\");\n        // Already parsed\n        } else if (typeof expression === 'object') {\n            myExpr = expression;\n        }\n        var mySubs = Object.entries(substitution);\n        var substVar, substExpr;\n        [substVar, substExpr] = mySubs[0];\n        if (typeof substExpr == \"string\") {\n            substExpr = this.menv.parse(substExpr, \"formula\");\n        }\n        var binding = {};\n        binding[substVar] = substExpr;\n        return myExpr.compose(binding);\n    }\n\n    addExpression(name, expression) {\n        var newExpr = this.parseExpression(expression, \"formula\");\n        \n        this.data.expressions[name] = newExpr;\n        this.data.allValues[name] = newExpr;\n\n        return newExpr;\n    }\n\n    addFunction(name, input, expression) {\n        this.menv.addFunction(name, input, expression);\n    }\n\n    // This routine takes the text and looks for strings in mustaches {{name}}\n    // It replaces this element with the corresponding parameter, variable, or expression.\n    // These should have been previously parsed and stored in this.data.\n    decodeFormula(statement, displayMode) {\n        // First find all of the expected substitutions.\n        var substRequestList = {};\n        var matchRE = /\\{\\{[A-Za-z]\\w*\\}\\}/g;\n        var substMatches = statement.match(matchRE);\n        if (substMatches != null) {\n            for (var i=0; i<substMatches.length; i++) {\n                var matchName = substMatches[i];\n                matchName = matchName.substr(2,matchName.length-4);\n                // Now see if the name is in our substitution rules.\n                if (this.data.allValues[matchName] != undefined) {\n                    if (displayMode != undefined && displayMode) {\n                        substRequestList[matchName] = '{'+this.data.allValues[matchName].toTeX()+'}';\n                    } else {\n                        substRequestList[matchName] = '('+this.data.allValues[matchName].toString()+')';\n                    }\n                }\n            }\n        }\n\n        // We are now ready to make the substitutions.\n        var retString = statement;\n        for (var match in substRequestList) {\n            var re = new RegExp(\"{{\" + match + \"}}\", \"g\");\n            var subst = substRequestList[match];\n            retString = retString.replace(re, subst);\n        }\n        return retString;\n    }\n\n    compareExpressions(expr1, expr2) {\n        var myExpr1, myExpr2;\n        // Not yet parsed\n        if (typeof expr1 === 'string') {\n            var formula1 = this.decodeFormula(expr1);\n            myExpr1 = this.menv.parse(formula1, \"formula\");\n        // Already parsed\n        } else if (typeof expr1 === 'object') {\n            myExpr1 = expr1;\n        }\n        if (typeof expr2 === 'string') {\n            var formula2 = this.decodeFormula(expr2);\n            myExpr2 = this.menv.parse(formula2, \"formula\");\n        // Already parsed\n        } else if (typeof expr2 === 'object') {\n            myExpr2 = expr2;\n        }\n\n        return this.menv.compareMathObjects(myExpr1,myExpr2);\n    }\n\n    getParser(context) {\n        return this.menv.getParser(context);\n    }\n}\n"],"names":["Identity","constructor","refExpr","eqExpr","description","isValid","idNum","this","isActive","Match","testRule","bindings","allVars","dependencies","missVars","j","push","substExpr","compose","subTeX","toTeX","subStr","toString","name","type","exprType","binop","valueType","exprValue","bool","equation","numInputs","length","ruleID","newRule","menv","reductionList","useOneWay","constraints","exprFormulas","split","console","log","refID","identity","parse","allRefExpr","uniqueExpr","i","nextExpr","isNew","match","findMatchRules","testExpr","doValidate","matchList","MathObject","select","parent","inputs","undef","context","undefined","value","setContext","setParsingError","errorString","parseError","hasParsingError","retValue","getParsingError","errString","elementOnly","showSelect","toMathML","allStringEquivs","flatten","copy","isConstant","isExpression","expression","super","numeric","evaluate","operateToTeX","treeToTeX","expand","retStruct","current","myCopy","simplifyConstants","forced","inDeps","depArray","Array","master","getInput","whichInput","compare","options","matchInputs","isEqual","knownBindings","Object","keys","unknownBindings","rTol","indexOf","splice","dependA","dependB","x","xOpt","xMin","xMax","dx","n","testPoints","variableList","testPointList","min","max","odometer","matchOp","flatA","flatB","done","y1","y2","isFinite","Math","abs","isNaN","op","inputMatched","matchFound","reduce","matchRules","workExpr","reduceRules","derivative","ivar","varList","scalar_expr","expr","inputSubst","origExpr","subExpr","real_number","a","Number","number","simplify","equal","other","add","subtract","multiply","divide","NaN","addInverse","multInverse","leadSign","str","toFixed","isInt","isInteger","floor","p","q","sqrt","b","c","findGCD","valueOf","word","negativeNumbers","theNumber","unop_expr","variable_expr","variable","primePos","derivs","slice","isConst","isSpecial","retVal","E","PI","Infinity","ivarName","index_expr","index","boundName","alert","k","tmpBind","binop_expr","inputA","inputB","prec","opPrec","addsub","multdiv","power","conj","disj","opAStr","opBStr","unop","theOp","allInputsA","allInputsB","theStr","fcn","argStrL","argStrR","opStrL","opStrR","replace","opString","isCommutative","commutes","inputAVal","inputBVal","pow","exp","absTol","newExpr","numA","numB","rational_number","inA","inB","multiop","newInput","multiop_expr","theDeriv","dvdx","uConst","vConst","dudx","udv","vdu","numer","denom","powDep","theArg","function_expr","newPow","dydu","input","opStr","allInputs","inputVal","newThis","prototype","call","allInputsArrays","indexList","inputPerms","permutations","buildStringEquivs","leftStr","workInputs","minPrec","newInputs","nextInput","tmp","constIndex","newConstant","copyBindings","key","cmpExpr","cmpInputs","diff","dTerms","dProdTerms","inputExpr","restrictDomain","domain","alternate","builtin","xvar","deriv","binding","getName","repeat","fcnString","retString","argStrings","join","inputOptions","generateArgs","left","rightOptions","N","newLeft","texString","argString","sin","cos","tan","asin","acos","atan","LOG10E","functionEntry","functions","fBind","forEach","inVar","isArray","varBind","theSec","theCot","theTan","theCsc","theCos","theSin","tanSq","theSq","theRad","cotSq","deriv_expr","formula","atValue","operator","ivarValue","isRate","exprStr","varStr","valStr","dbind","firstDeriv","RNG","rngSettings","rand","seed","Date","getTime","args","version","s0","s1","s2","initialArgs","uinta","Uint32Array","mashver","_initState","_internalSeed","mash","data","l","h","charCodeAt","Mash","_isInteger","_int","parseInt","random","t","fract53","int32","cycle","_run","range","loBound","hiBound","arguments","restart","versions","window","crypto","getRandomValues","aleaPRNG","setSeed","alea","randSign","randInt","randUniform","randDiscrete","by","nonzero","rndVal","Nvals","randChoice","randRational","pLims","qLims","randHexHash","hash","fop","array","matrix","MENV","settings","randomBindings","relTol","useRelErr","doFlatten","setReductionRules","rngOptions","rng","numberCmp","override","valA","valB","addReductionRule","disableReductionRule","disableRule","addRule","ruleList","generateRandom","distr","addFunction","newTerm","compareMathObjects","expr1","expr2","getParser","self","parseContext","exprString","formulaStr","numberMatch","nameMatch","opMatch","endPos","workingStr","charPos","trim","hasExtraParens","charAt","completeParenthesis","operandStack","operatorStack","resolveOperator","newOp","oldOp","pop","newElement","lastElement","subExprStr","completeAbsValue","substr","search","completeNumber","noDecimals","completeName","theName","testResults","TestNameIsComposite","isComposite","endParen","entries","hasError","completeBracket","error","indexExpr","holdElement","finalExpression","TypeError","vector","startPos","pLevel","wasOp","asSubscript","fail","matchRule","text","nextName","knownNames","ikey","BTM","allValues","params","variables","expressions","addMathObject","newObject","addVariable","newVar","parseExpression","decodeFormula","evaluateExpression","theExpr","composeExpression","substitution","myExpr","substVar","mySubs","addExpression","statement","displayMode","substRequestList","substMatches","matchName","re","RegExp","subst","compareExpressions","myExpr1","myExpr2","formula1","formula2"],"sourceRoot":""}