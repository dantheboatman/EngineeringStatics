<!DOCTYPE html>
<!--
Copyright 2011-16 Newcastle University

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
-->
<html lang="en-GB">
    <head>
        
    <title>Chapter 4 Exercises - Numbas</title>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="icon" type="image/png" href="resources/numbas-icon.png"/>

    <!-- CSS -->
<style>
    /* This rule will be overriden in styles.css, so the page content is only shown when the stylesheet has loaded
    */
    body > #with-stylesheet {
        display: none;
    }
</style>
<link rel="stylesheet" type="text/css" href="styles.css?build_time=1755788940.505458" />
    <!-- mathjax stuff -->
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        TeX: {
            extensions: ['begingroup.js']
        },
        tex2jax: {
            inlineMath: [['$','$'], ['\\(','\\)']],
            displayMath: [['\\[','\\]'], ['$$','$$']],
            processEscapes: true
        },
        "CommonHTML": {
            mtextFontInherit: true
        },
        skipStartupTypeset: true,
        displayAlign: "center",
        displayIndent: "0.1em"
    });
    MathJax.Hub.processSectionDelay = 0;
</script>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js?config=TeX-AMS_CHTML.js"></script>

<!-- numbas stuff -->
<script charset="UTF-8" type="text/javascript" src="scripts.js?build_time=1755788940.505458" charset="utf-8"></script>

<script>
    Numbas.queueScript('go',['start-exam'], function() {
        Numbas.locale.set_preferred_locale('en-GB');
    });
    if(document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', Numbas.checkAllScriptsLoaded);
    } else {
        Numbas.checkAllScriptsLoaded();
    }
</script>


	</head>
	
    <body data-bind="with: exam, css: css">
        <div id="no-stylesheet">
            <p data-localise="page.no stylesheet loaded"></p>
        </div>

        <div id="with-stylesheet">
            <!-- modal dialog boxes -->
<div class="modal fade" id="alert-modal" tabindex="-1" role="dialog" aria-hidden="true" aria-labelledby="alert-modal-title" aria-describedby="alert-modal-body">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h4 id="alert-modal-title" data-localise="modal.alert"></h4>
            </div>
            <div class="modal-body" id="alert-modal-body">
            </div>
            <div class="modal-footer">
                <button type="button" class="ok btn btn-primary" data-dismiss="modal" data-localise="modal.ok"></button>
            </div>
        </div>
    </div>
</div>

<div class="modal fade" id="confirm-modal" tabindex="-1" role="dialog" aria-hidden="true" aria-labelledby="confirm-modal-title" aria-describedby="confirm-modal-body">
    <div class="modal-dialog" role="document">
        <div class="modal-content">
            <div class="modal-header">
                <h4 id="confirm-modal-title" data-localise="modal.confirm"></h4>
            </div>
            <div class="modal-body" id="confirm-modal-body">
            </div>
            <div class="modal-footer">
                <button type="button" class="cancel btn btn-default" data-dismiss="modal" data-localise="modal.cancel"></button>
                <button type="button" class="ok btn btn-primary" data-dismiss="modal" data-localise="modal.ok"></button>
            </div>
        </div>
    </div>
</div>

<div class="modal fade" id="confirm-end-exam-modal" tabindex="-1" role="dialog" aria-hidden="true"
    aria-labelledby="confirm-end-exam-modal-title" aria-describedby="confirm-end-exam-modal-body">
    <div class="modal-dialog" role="document">
        <div class="modal-content">
            <div class="modal-header">
                <h4 id="confirm-end-exam-modal-title" data-localise="modal.confirm"></h4>
            </div>
            <div class="modal-body" id="confirm-end-exam-modal-body" data-bind="with: $root.exam">
                <p id="confirm-end-exam-modal-message"></p>
                <form class="form-inline" data-bind="submit: $root.modal.ok">
                    <label for="confirm-end-text-input" id="confirm-end-exam-modal-input-message"></label>
                    <input class="form-control" id="confirm-end-text-input" type="text" data-bind="textInput: confirmEndHandler.value, autosize: confirmEndHandler.value">
                    <span class="password-feedback feedback-icon" data-bind="css: confirmEndHandler.feedback().iconClass, attr: {title: confirmEndHandler.feedback().title}"></span>
                </form>
            </div>
            <div class="modal-footer">
                <button type="button" class="cancel btn btn-default" data-dismiss="modal" data-localise="modal.cancel"></button>
                <button type="button" class="ok btn btn-primary" data-dismiss="modal" data-bind="disable: !confirmEndHandler.valid(), css: confirmEndHandler.feedback().buttonClass" data-localise="modal.end exam button"></button>
            </div>
        </div>
    </div>
</div>

<div class="modal fade" id="style-modal" tabindex="-1" role="dialog" aria-hidden="true" aria-labelledby="style-modal-title" aria-describedby="style-modal-explanation">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h4 id="style-modal-title" data-localise="control.style options"></h4>
            </div>
            <div class="modal-body">
                <p class="help-block" id="style-modal-explanation" data-localise="modal.style.explanation"></p>
                <form data-bind="submit: function(){}, with: $root.style">
                    <div class="row">
                        <div class="form-group col-sm-6">
                            <label for="background-colour-picker" data-localise="modal.style.background colour"></label>
                            <input class="form-control" id="background-colour-picker" type="color" data-bind="value: backgroundColour">
                        </div>
                        <div class="form-group col-sm-6">
                            <label for="text-colour-picker" data-localise="modal.style.text colour"></label>
                            <input class="form-control" id="text-colour-picker" type="color" data-bind="value: textColour">
                        </div>
                    </div>
                    <div class="row">
                        <div class="form-group col-sm-6">
                            <label for="text-size-picker" data-localise="modal.style.text size"></label>
                            <input class="form-control" id="text-size-picker" type="number" step="0.1" min="0.1" data-bind="value: $root.staged_style.textSize">
                        </div>
                        <div class="col-sm-6" id="text-size-preview" data-localise="modal.style.text preview"></div>
                    </div>
                </form>

                
                <hr/>
                <p class="help-block"><a href="https://docs.numbas.org.uk/en/latest/accessibility/exam.html" target="_blank" data-localise="accessibility statement"></a></p>
                
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-danger btn-sm pull-left" data-localise="modal.style.reset to defaults" data-bind="click: $root.resetStyle"></button>
                <button type="button" class="cancel btn btn-default" data-dismiss="modal" data-localise="modal.cancel"></button>
                <button type="button" class="ok btn btn-primary" data-dismiss="modal" data-localise="modal.ok"></button>
            </div>
        </div>
    </div>
</div>

<div class="modal fade" id="next-actions-modal" tabindex="-1" role="dialog" aria-hidden="true" data-backdrop="static" data-keyboard="false" aria-labelledby="next-actions-modal-title">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h4 id="next-actions-modal-title" data-localise="diagnostic.make a choice"></h4>
            </div>
            <div class="modal-body" data-bind="with: diagnostic_next_actions">
                <div data-bind="latex: feedback"></div>

                <ul data-bind="foreach: actions" class="list-unstyled actions">
                    <li>
                        <button type="button" data-bind="click: go, css: {blog: true}"><span data-bind="latex: label"></span></button>
                    </li>
                </ul>
            </div>
        </div>
    </div>
</div>

<div id="lightbox" tabindex="-1" role="dialog" aria-hidden="true">
</div>
            <div id="die">
    <h1 data-localise="die.numbas failed">Numbas failed</h1>
    <p data-localise="die.sorry"></p>
    <div class="error" tabindex="1">
        <div class="message"></div>
        <div class="stack"></div>
    </div>
</div>
            <div id="loading">
    <div class="progress">
        <div class="progress-bar" role="progressbar"><span data-localise="page.loading">Loading...</span></div>
    </div>
</div>

<div id="saving" data-bind="visible: saving" style="display:none">
    <div class="text" data-localise="page.saving"></div>
</div>

            <div id="everything" style="display:none">
                <a class="sr-only" id="skip-link" data-bind="attr: {href: infoPage() ? '#infoDisplay' : '#questionContainer'}" data-localise="page.skip to content"></a>
                <!-- ko if: exam.settings.navigateMode=='sequence' -->
    <!-- side menu, slides out on narrow screens -->
<nav id="navMenu" class="navmenu navmenu-default question-nav" role="navigation">

    <div id="navMenu-wrapper">

        <div class="navmenu-header">
            <div class="navmenu-brand">
                <img class="logo center-block" src="resources/Engineering_statics_logo_numbas.svg" alt="Engineering Statics"/>
            </div>
            <h1 class="exam-name navmenu-brand" data-bind="text: exam.settings.name, typeset: exam.settings.name"></h1>
            <button type="button" class="navbar-toggle btn btn-default" data-toggle="navMenu">
                <span aria-hidden="true">×</span>
                <span class="sr-only" data-localise="control.toggle navigation menu"></span>
            </button>
            <!--
            <button class="btn btn-default" id="hide-nav-menu" data-bind="click: hideNavMenu">
                <span aria-hidden="true">x</span>
                <span class="sr-only" data-localise="control.toggle navigation menu"></span>
            </button>
            -->
        </div>

        <!-- ko if: numQuestions() > 1 -->
        <label class="sr-only" for="exam-progress" data-localise="exam.progress"></label>
        <progress id="exam-progress" data-bind="attr: {max: numQuestions(), value: questionsAttempted(), title: questionsAttemptedDisplay}, text: questionsAttemptedDisplay"></progress>
        <!-- /ko -->

        <ul id="questionList" class="nav navmenu-nav">
            <li class="introduction" data-bind="visible: exam.hasIntro, css: {active: $root.exam().infoPage()=='introduction'}">
                <a href="#" class="clearfix" role="button" tabindex="0" data-bind="click: Numbas.controls.showIntroduction, attr: {'aria-current': $root.exam().infoPage()=='introduction' ? 'step' : false}" data-localise="control.show introduction"></a>
           </li>
            <!-- ko foreach: question_groups -->
                <!-- ko if: $root.exam().showQuestionGroupNames -->
                <li class="question-group-header" data-bind="visible: show_name">
                    <h2 data-bind="text: name, typeset: name"></h2>
                </li>
                <!-- /ko -->
                <!-- ko foreach: questions -->
                <li class="questionSelector" data-bind="visible: visible, css: {active: $root.exam().currentQuestion()==$data}">
                    <a href="#" class="clearfix" role="button" tabindex="0" data-bind="click: Numbas.controls.makeQuestionJumper(question.number), attr: {'aria-current': $root.exam().currentQuestion()==$data ? 'step' : false}">
                        <div class="info">
                            <span class="feedback-icon" data-bind="css: scoreFeedback.iconClass, attr: scoreFeedback.iconAttr" aria-hidden="true"></span>
                            <span class="name" data-bind="text: displayName"></span>
                            <span class="sr-only" data-bind="text: scoreFeedback.iconAttr().title"></span>
                            <span class="score" data-bind="html: scoreFeedback.message"></span>
                        </div>
                        <div class="messages">
                            <div class="answered-state" data-bind="">
                                <span data-bind="text: scoreFeedback.answeredString"></span>
                            </div>
                            <div data-bind="visible: isDirty" class="dirty-message">
                                <span class="warning-icon icon-exclamation-sign"></span>
                                <span data-localise="question.selector.unsubmitted changes"></span>
                            </div>
                        </div>
                    </a>
                </li>
                <!-- /ko -->
            <!-- /ko -->
            <!-- total exam score display -->
            <li class="examScore fake-nav-link" data-bind="visible: scoreFeedback.showActualMark">
                <a class="clearfix">
                    <span class="pull-left" data-localise="control.total"></span> 
                    <span class="pull-right" id="examScore" data-bind="html: examScoreDisplay"></span>
                </a>
            </li>
        </ul>

        <div class="stopWatch" data-bind="visible: displayTime">
            <span class="" data-localise="timing.time remaining"></span>
            <time class="time" data-bind="text: displayTime"></time>
        </div>

        <ul class="nav navmenu-nav menuButtons">
            <li><button class="btn btn-default navbar-btn center-block thin-button" type="button" data-bind="click: Numbas.display.showStyleModal" data-localise="control.style options"></button></li>
            <li data-bind="visible: allowPause && mode()=='normal'"><button class="btn btn-primary navbar-btn center-block thin-button" id="pauseBtn" data-localise="control.pause" data-bind="click: Numbas.controls.pauseExam"></button></li>
            <li data-bind="visible: mode()=='normal'"><button class="btn btn-danger navbar-btn center-block" id="endBtn" data-localise="control.end exam" data-bind="click: Numbas.controls.endExam"></button></li>
            <li data-bind="visible: mode()=='review'"><button class="btn btn-primary navbar-btn center-block" data-localise="control.back to results" data-bind="click: Numbas.controls.backToResults"></button></li>
        </ul>

    </div>

</nav>

<!-- top menu shown on narrow screens -->
<div id="topNav" class="hamburger navbar navbar-default question-nav">
    <ul class="nav">
        <!-- ko if: numQuestions() > 1 -->
        <li class="prev"><button type="button" class="btn navbar-btn btn-primary" data-bind="click: reverse, attr: {disabled: !canReverse()}"><span class="sr-only" data-localise="control.previous"></span>&larr;</button></li>
        <li class="next"><button type="button" class="btn navbar-btn btn-primary" data-bind="click: advance, attr: {disabled: !canAdvance()}"><span class="sr-only" data-localise="control.next"></span>&rarr;</span></button></li>
        <!-- /ko -->
        <li class="end"><button class="btn btn-danger navbar-btn" data-localise="control.end exam" data-bind="click: Numbas.controls.endExam, visible: mode()=='normal' && !canAdvance()"></button></li>
        <li class="titleBits" data-bind="with: currentQuestion">
            <span class="review-header" data-bind="visible: $root.exam().mode()=='review'" data-localise="exam.review header"></span>
            <span id="questionNameDisplay" data-bind="text: displayName"></span>
        </li>

        <li class="stopWatch" data-bind="visible: displayTime">
            <span class="" data-localise="timing.time remaining"></span>
            <span class="time" data-bind="text: displayTime"></span>
        </li>
    </ul>

    <button type="button" class="navbar-toggle btn btn-default" data-toggle="navMenu">
        <span class="hamburger-bar"></span>
        <span class="hamburger-bar"></span>
        <span class="hamburger-bar"></span>
        <span class="sr-only" data-localise="control.toggle navigation menu"></span>
    </button>
</div>
<!-- /ko -->

<!-- ko if: exam.settings.navigateMode=='menu' -->
    <div id="topNav" class="hamburger navbar navbar-default question-nav">
    <ul class="nav">
        <li class="back-to-menu"><button type="button" class="btn navbar-btn btn-primary" data-bind="click: Numbas.controls.backToMenu">&larr; <span data-localise="control.back to menu"></span></button></li>
        <li class="titleBits" data-bind="with: currentQuestion">
            <span class="review-header" data-bind="visible: $root.exam().mode()=='review'" data-localise="exam.review header"></span>
            <span id="questionNameDisplay" data-bind="latex: displayName"></span>
        </li>
        <li class="display-options"><button class="btn btn-default navbar-btn center-block thin-button" type="button" data-bind="click: Numbas.display.showStyleModal" data-localise="control.style options"></button></li>
    </ul>
</div>
<!-- /ko -->

<!-- ko if: exam.settings.navigateMode=='diagnostic' -->
    <nav id="navMenu" class="navmenu navmenu-default question-nav" role="navigation">

    <div id="navMenu-wrapper">

        <div class="navmenu-header">
            <div class="navmenu-brand">
                <img class="logo center-block" src="resources/Engineering_statics_logo_numbas.svg" alt="Engineering Statics"/>
            </div>
            <h1 class="exam-name navmenu-brand" data-bind="text: exam.settings.name, typeset: exam.settings.name"></h1>
            <button type="button" class="navbar-toggle btn btn-default" data-toggle="navMenu">
                <span aria-hidden="true">×</span>
                <span class="sr-only" data-localise="control.toggle navigation menu"></span>
            </button>
        </div>

        <ul id="learning-objective-list" class="nav navemnu-nav">
            <!-- ko foreach: diagnostic_progress -->
            <li class="learning-objective">
                <span class="name" data-bind="latex: name"></span>
                <span data-bind="text: Math.floor(100*progress)+'%'"></span>
            </li>
            <!-- /ko -->
        </ul>
        <ul class="nav navmenu-nav">

                <!-- stopwatch and timing controls -->
                <li id="stopWatch" class="fake-nav-link" data-bind="visible: displayTime">
                    <a class="clearfix">
                        <span class="pull-left" data-localise="timing.time remaining"></span>
                        <span class="pull-right" data-bind="text: displayTime"></span>
                    </a>
                </li>

                <div class="menuButtons">
                    <li><button class="btn btn-primary navbar-btn center-block" id="hideNavMenuBtn" data-bind="click: hideNavMenu" data-localise="control.return to question"></button>

                    <li><button class="btn btn-primary navbar-btn center-block" id="pauseBtn" data-localise="control.pause" data-bind="click: Numbas.controls.pauseExam, visible: allowPause && mode()=='normal'"></button></li>
                    <li><button class="btn btn-danger navbar-btn center-block" id="endBtn" data-localise="control.end exam" data-bind="click: Numbas.controls.endExam, visible: mode()=='normal'"></button></li>
                    <li><button class="btn btn-primary navbar-btn center-block" data-localise="control.back to results" data-bind="click: Numbas.controls.backToResults, visible: mode()=='review'"></button></li>
                </div>
        </ul>

    </div>

</nav>

<!-- top menu shown on narrow screens -->
<div id="topNav" class="hamburger navbar navbar-default question-nav">
    <ul class="nav">
        <li>	
            <div class="titleBits" data-bind="with: currentQuestion">
                <span class="review-header" data-bind="visible: $root.exam().mode()=='review'" data-localise="exam.review header"></span>
                <span id="questionNameDisplay" data-bind="text: displayName"></span>
            </div>
        </li>

        <li class="stopWatch" data-bind="visible: displayTime">
            <span class="" data-localise="timing.time remaining"></span>
            <span class="time" data-bind="text: displayTime"></span>
        </li>
    </ul>

    <button type="button" class="navbar-toggle btn btn-default" data-toggle="navMenu">
        <span class="hamburger-bar"></span>
        <span class="hamburger-bar"></span>
        <span class="hamburger-bar"></span>
        <span class="sr-only" data-localise="control.toggle navigation menu"></span>
    </button>
</div>
<!-- /ko -->

                <!-- main content area - info pages or questions go in here -->
                <main class="mainDisplay" role="main" data-bind="attr: {'aria-labelledby': main_labelledby}">
                    <div id="infoDisplay" class="container" data-bind="visible: infoPage">
    <div id="frontpage" class="row" data-bind="visible: infoPage()=='frontpage', if: infoPage()=='frontpage'">
        <h1 class="break-words" id="infopage-frontpage-header" data-bind="html: exam.settings.name"></h1>
<table class="col-sm-6 col-sm-offset-3" class="summary">
    <tbody>
    <!-- ko if: exam.settings.navigateMode != 'diagnostic' -->
    <tr>
        <th data-localise="exam.number of questions"></th>
        <td class="rtd" data-bind="html: numAssessedQuestions"></td>
    </tr>
    <tr data-bind="visible: exam.settings.showTotalMark">
        <th data-localise="exam.marks available"></th>
        <td class="rtd" data-bind="niceNumber: marks"></td>
    </tr>
    <!-- /ko -->
    <tr data-bind="visible: exam.settings.percentPass>0">
        <th data-localise="exam.pass percentage"></th>
        <td class="rtd" data-bind="text: percentPass"></td>
    </tr>
    <tr data-bind="visible: duration()>0">
        <th data-localise="exam.time allowed"></th>
        <td class="rtd"><time data-bind="html: displayDuration"></time></td>
    </tr>
    <tr data-bind="visible: exam.settings.showStudentName && exam.student_name && !needsStudentName">
        <th data-localise="exam.student name"></th>
        <td><span data-bind="text: exam.student_name"></span><span data-bind="visible: exam.student_id"> (<span data-bind="text: exam.student_id"></span>)</span></td>
    </tr>
    </tbody>
</table>

<div id="intro" class="alert col-sm-6 col-sm-offset-3" data-bind="visible: exam.hasIntro, latex: exam.introMessage" localise-data-jme-context-description="exam.introduction"></div>

<div class="alert alert-danger col-sm-6 col-sm-offset-3" data-bind="visible: showAttemptDownloadSecurityWarning">
    <p data-localise="exam.attempt download security warning"></p>
</div>
<div id="standalone-warning" class="alert alert-info col-sm-6 col-sm-offset-3" data-bind="visible: !Numbas.storage.lmsConnected && !allowAttemptDownload" data-localise="frontpage.scorm.lms not connected"></div>

<form data-bind="submit: beginExam" class="info-buttons col-sm-6 col-sm-offset-3">
    <button class="btn btn-default navbar-btn center-block thin-button" type="button" data-bind="click: Numbas.display.showStyleModal" data-localise="control.style options"></button>
    <div class="student-name" data-bind="visible: needsStudentName">
        <label for="begin-exam-student-name" data-localise="exam.enter your name"></label>
        <input id="begin-exam-student-name" name="begin-exam-student-name" type="text" class="form-control" data-bind="textInput: student_name, autosize: student_name"/>
    </div>
    <div class="password" data-bind="visible: needsPassword, css: {'has-error': passwordHandler.value().length && !passwordHandler.valid(), 'has-success': passwordHandler.valid()}">
        <label for="begin-exam-password" data-localise="exam.enter password"></label>
        <input id="begin-exam-password" autocomplete="off" name="begin-exam-password" type="text" class="form-control" data-bind="textInput: passwordHandler.value, autosize: passwordHandler.value"/>
        <span class="password-feedback feedback-icon" data-bind="css: passwordHandler.feedback().iconClass, attr: {title: passwordHandler.feedback().title}"></span>
    </div>
    <button class="btn" id="startBtn" type="submit" data-bind="disable: !canBegin(), css: passwordHandler.feedback().buttonClass" data-localise="frontpage.start"></button>
</form>
    </div>
    <div id="menu" class="row" data-bind="visible: infoPage()=='menu', if: infoPage()=='menu'">
        <h1 id="infopage-menu-header" class="break-words" data-bind="html: exam.settings.name"></h1>

<div class="intro" class="alert col-sm-6 col-sm-offset-3" data-bind="visible: exam.hasIntro, latex: exam.introMessage" localise-data-jme-context-description="exam.introduction"></div>

<nav id="question-chooser">
    <table class="table table-hover questionSelector">
        <colgroup>
            <col class="question">
            <col class="score">
            <col class="icon">
        </colgroup>
        <tbody>
        <!-- ko foreach: question_groups -->
            <!-- ko if: $parent.showQuestionGroupNames -->
            <tr>
                <th data-bind="visible: $parent.question_groups.length>1">
                    <span data-bind="latex: name"></span>
                </th>
                <th class="messages">
                    <span class="score" data-bind="html: feedback.plainMessage"></span>
                </th>
                <th class="icon">
                    <span class="feedback-icon" data-bind="css: feedback.iconClass, attr: feedback.iconAttr" aria-hidden="true"></span>
                </th>
            </tr>
            <!-- /ko -->
            <!-- ko foreach: questions -->
            <tr class="" role="button" data-bind="click: Numbas.controls.makeQuestionJumper(question.number), attr: {'aria-labelledby': question.path+'-menu-name'}">
                <td class="info">
                    <button class="btn btn-link" type="button" class="name" data-bind="latex: displayName, attr: {id: question.path+'-menu-name'}"></button>
                </td>
                <td class="messages">
                    <span class="sr-only" data-bind="text: scoreFeedback.iconAttr().title"></span>
                    <span class="score" data-bind="html: scoreFeedback.plainMessage"></span>
                    <div class="answered-state" data-bind="">
                        <span data-bind="text: scoreFeedback.attemptedString"></span>
                    </div>
                    <div data-bind="visible: isDirty" class="dirty-message">
                        <span class="warning-icon icon-exclamation-sign"></span>
                        <span data-localise="question.selector.unsubmitted changes"></span>
                    </div>
                </td>
                <td class="icon">
                    <span class="feedback-icon" data-bind="css: scoreFeedback.iconClass, attr: scoreFeedback.iconAttr" aria-hidden="true"></span>
                </td>
            </tr>
            <!-- /ko -->
        <!-- /ko -->
        </tbody>
    </table>
</nav>

<p class="center-block text-center"><button class="btn btn-danger navbar-btn" id="endBtn" data-localise="control.end exam" data-bind="click: Numbas.controls.endExam"></button></p>

<p class="center-block text-center"><button class="btn btn-default navbar-btn thin-button" type="button" data-bind="click: Numbas.display.showStyleModal" data-localise="control.style options"></button></p>
    </div>
    <div id="introduction" data-bind="visible: infoPage()=='introduction', if: infoPage()=='introduction'">
        <h1 id="infopage-introduction-header" data-localise="exam.introduction"></h1>
<div class="alert" data-bind="latex: exam.introMessage" localise-data-jme-context-description="exam.introduction"></div>
    </div>
    <div id="suspend" data-bind="visible: infoPage()=='paused' || infoPage()=='resumed', if: infoPage()=='paused' || infoPage()=='resumed'">
        <h1 id="infopage-suspend-header">
    <span data-bind="visible: infoPage()=='paused'" data-localise="suspend.paused header" ></span>
    <span data-bind="visible: infoPage()=='resumed'" data-localise="suspend.resumed header" ></span>
</h1>
<p data-localise="suspend.exam suspended"></p>
<p data-localise="suspend.you can resume"></p>
<button class="btn btn-primary" id="resumeBtn" data-bind="click: Numbas.controls.resumeExam" data-localise="suspend.resume"></button>
    </div>
    <div id="end-name" class="container-fluid" data-bind="visible: infoPage()=='result'">
        <h1 id="infopage-result-header" class="text-center break-words" data-bind="latex: exam.settings.name"></h1>
    </div>
    <div id="results" class="container-fluid" data-bind="visible: infoPage()=='result', if: infoPage()=='result'">
        <!-- ko if: exam.settings.navigateMode=='diagnostic' -->
    <div class="row">
    <table id="diagnostic-breakdown" class="col-sm-6 col-sm-offset-3">
        <colgroup>
            <col>
            <col>
        </colgroup>
        <thead>
            <th data-localise="result.learning objective"></th>
            <!-- ko if: showActualMark -->
            <th data-localise="result.question score"></th>
            <!-- /ko -->
        </thead>
        <tbody>
            <!-- ko foreach: diagnostic_progress -->
                <tr data-bind="css: {total: $index()==$parent.diagnostic_progress().length-1}">
                    <td class="name" data-bind="latex: name"></td>
                    <!-- ko if: $parent.showActualMark -->
                    <td class="score" data-bind="text: Math.floor(100*credit)+'%'"></td>
                    <!-- /ko -->
                </tr>
            <!-- /ko -->
        </tbody>
    </table>
</div>

<!-- /ko -->

<!-- ko if: exam.settings.navigateMode=='sequence' || exam.settings.navigateMode=='menu' -->
<p class="col-sm-6 col-sm-offset-3" data-localise="result.click a question to review"></p>
<div class="row">
    <table id="question-breakdown" class="col-sm-6 col-sm-offset-3">
        <colgroup>
            <col>
            <col span="3" class="score">
            <col>
        </colgroup>
        <thead>
            <tr>
            <!-- ko if: exam.settings.navigateMode=='sequence' -->
                <th data-localise="result.question number"></th>
            <!-- /ko -->
            <!-- ko if: exam.settings.navigateMode=='menu' -->
                <th data-localise="question"></th>
            <!-- /ko -->
            <th data-bind="text: resultsScoreColumnHeader"></th>
            <th data-localise="result.question review"></th>
            </tr>
        </thead>
        <tbody>
            <!-- ko foreach: question_groups -->
                <!-- ko if: $root.exam().showQuestionGroupNames -->
                <tr class="question-group-header" data-bind="visible: show_name">
                    <th data-bind="text: name, typeset: name"></th>
                    <th colspan="4"></th>
                </tr>
                <!-- /ko -->
                <!-- ko foreach: questions -->
                <tr class="question" data-bind="click: review, attr: {title: R('result.question review title')}">
                    <td data-bind="latex: displayName"></td>
                    <td class="score-cell" data-bind="html: scoreFeedback.plainMessage"></td>
                    <td><button type="button" class="btn btn-link review" data-localise="result.question review"></button></td>
                </tr>
                <!-- /ko -->
            <!-- /ko -->
            <!-- ko if: scoreFeedback.showActualMark() || scoreFeedback.showTotalMark() -->
            <tr class="total">
                <th scope="row" data-localise="Total"></th>
                <td class="score-cell">
                    <span class="score" data-bind="html: scoreFeedback.plainMessage"></span>
                </td>
                <td>
                    <!-- ko if: scoreFeedback.showActualMark() && scoreFeedback.showTotalMark() -->(<span data-bind="text: percentScore"></span>%)<!-- /ko -->
                </td>
            </tr>
            <!-- /ko -->
        </tbody>
    </table>
</div>

<!-- /ko -->

<div id="end-message" class="alert col-sm-6 col-sm-offset-3" data-bind="visible: exam.has_end_message, latex: exam.end_message" localise-data-jme-context-description="exam.end_message"></div>

<!-- ko if: scoreFeedback.showActualMark -->
<div class="row">
    <div id="feedback" class="alert results-feedback col-sm-6 col-sm-offset-3" data-bind="visible: feedbackMessage()!==null, latex: feedbackMessage" localise-data-jme-context-description="exam.feedback"></div>
</div>
<!-- /ko -->

<div class="row" id="performance-summary">
    <div class="col-md-6 col-md-offset-3">
        <h2 data-localise="result.performance summary"></h2>
        <table class="summary">
            <tr>
                <th data-localise="exam.exam name"></th>
                <td class="break-words" data-bind="html: exam.settings.name"></td>
            </tr>
            <tr>
                <th data-localise="exam.random seed"></th>
                <td class="break-words" data-bind="html: exam.seed"></td>
            </tr>
            <tr data-bind="visible: exam.settings.showStudentName && exam.student_name">
                <th data-localise="exam.student name"></th>
                <td class="break-words"><span data-bind="text: exam.student_name"></span><span data-bind="visible: exam.student_id"> (<span data-bind="text: exam.student_id"></span>)</span></td>
            </tr>
            <tr>
                <th data-localise="result.exam start"></th>
                <td class="break-words"><time data-bind="text: startTime, attr: {datetime: startTimeISO}"></time></td>
            </tr>
            <tr>
                <th data-localise="result.exam stop"></th>
                <td class="break-words"><time data-bind="text: endTime, attr: {datetime: endTimeISO}"></time></td>
            </tr>
            <tr>
                <th data-localise="result.time spent"></th>
                <td class="break-words"><time data-bind="text: timeSpent"></time></td>
            </tr>
        </table>
    </div>
</div>



<div class="info-buttons">
    <button class="btn btn-info" data-bind="click: function(){ window.print(); }, text: printLabel"></button>
    <button class="btn btn-info" data-bind="visible: allowAttemptDownload, click: download_attempt_data" data-localise="result.download exam object"></button>
</div>

<p id="finished-text" class="text-center" data-bind="end.exam has finished"></p>
    </div>

    <footer>
    <div class="copyright-footer">
        Created using <a target="_blank" href="https://www.numbas.org.uk">Numbas</a> v9.0, developed by <a target="_blank" href="https://www.newcastle.ac.uk">Newcastle University</a>.
    </div>
</footer>
</div>

                    <div id="questionContainer" class="container-fluid print-visible" data-bind="visible: currentQuestion, css: {review: mode()=='review'}">
    <div class="contentArea ">
        <div id="diagnostic-feedback" class="diagnostic-feedback" data-bind="visible: diagnostic_feedback, latex: diagnostic_feedback"></div>

        <div id="questionDisplay" data-bind="foreach: questions">
            <div id="question-wrapper" class="print-visible" data-bind="promise: html_promise, visible: isCurrentQuestion">
            </div>
        </div>

        <footer>
    <div class="copyright-footer">
        Created using <a target="_blank" href="https://www.numbas.org.uk">Numbas</a> v9.0, developed by <a target="_blank" href="https://www.newcastle.ac.uk">Newcastle University</a>.
    </div>
</footer>
    </div>

</div>
                </main>
            </div>
            
            <numbas-exam storage="scorm">
                <script type="application/numbas-exam">// Numbas version: finer_feedback_settings
{"name": "Chapter 4 Exercises", "metadata": {"description": "<p>End of chapter exercises for <a href=\"http://engineeringstatics.org\"><em>Engineering Statics: Open and Interactive</em></a>&nbsp;</p>", "licence": "Creative Commons Attribution-NonCommercial 4.0 International"}, "duration": 0, "percentPass": 0, "showQuestionGroupNames": true, "shuffleQuestionGroups": false, "showstudentname": true, "question_groups": [{"name": "Moments", "pickingStrategy": "all-ordered", "pickQuestions": 1, "questionNames": ["Definition of a moment", "Verignon's Theorem", "", "Semicircle", "", ""], "variable_overrides": [[], [], [], [], [], []], "questions": [{"name": "Moment of a Force: using the definition of a moment", "extensions": ["geogebra", "quantities"], "custom_part_types": [{"source": {"pk": 24, "author": {"name": "William Haynes", "pk": 2530}, "edit_page": "/part_type/24/edit"}, "name": "Angle quantity", "short_name": "angle-quantity-from-reference", "description": "<p>Angle&nbsp;as a quantity in degrees.</p>", "help_url": "", "input_widget": "string", "input_options": {"correctAnswer": "plain_string(settings['correct_quantity'])", "hint": {"static": true, "value": ""}, "allowEmpty": {"static": true, "value": false}}, "can_be_gap": true, "can_be_step": true, "marking_script": "mark:\nswitch( \nright and good_units and right_sign and angle_in_range, add_credit(1.0,'Correct.'),\nright and good_units and not right_sign, add_credit(settings['C2'],'Wrong sign.'),\nright and right_sign and not good_units, add_credit(settings['C2'],'Correct angle, but missing degree symbol.'),\nright and good_units and right_sign and not angle_in_range,add_credit(settings['C1'],'Angle is out of range.'),\nclose and good_units, add_credit(settings['C1'],'Close.'),\nclose and not good_units, add_credit(settings['C3'],'Answer is close, but missing degree symbol.'),\nincorrect('Wrong answer.')\n)\n\ninterpreted_answer:\nqty(student_scalar, student_units)\n\ncorrect_scalar:\nscalar(correct_quantity)\n  \n\ncorrect_quantity:\nsettings['correct_quantity']\n\ncorrect_units:\nunits(correct_quantity)\n\nallowed_notation_styles:\n[\"plain\",\"en\"]\n\nmatch_student_number:\nmatchnumber(studentAnswer,allowed_notation_styles)\n\nstudent_scalar:\nmatch_student_number[1]\n\nstudent_units:\njoin(\nsplit(studentAnswer[len(match_student_number[0])..len(studentAnswer)]\n,\"\u00b0\"),\" deg\")\n\n\n\ngood_units:\ntry(\nkind(quantity(1, student_units))= kind(correct_quantity),\nmsg,\nfeedback(msg);false)\n\nstudent_quantity:\nswitch(not good_units, \nstudent_scalar * correct_units, \nnot right_sign,\n-quantity(student_scalar, student_units),\nquantity(student_scalar,student_units)\n)\n\nright_sign:\nsign(student_scalar) = sign(correct_quantity)\n\nangle_in_range:\nif(settings['restrict_angle'], abs(student_scalar) <= 90, true)\n\nright:\nwithinTolerance(abs(student_scalar), abs(correct_scalar), settings['right'])\n\nclose:\nwithinTolerance(student_scalar, correct_scalar, settings['close'])", "marking_notes": [{"name": "mark", "description": "This is the main marking note. It should award credit and provide feedback based on the student's answer.", "definition": "switch( \nright and good_units and right_sign and angle_in_range, add_credit(1.0,'Correct.'),\nright and good_units and not right_sign, add_credit(settings['C2'],'Wrong sign.'),\nright and right_sign and not good_units, add_credit(settings['C2'],'Correct angle, but missing degree symbol.'),\nright and good_units and right_sign and not angle_in_range,add_credit(settings['C1'],'Angle is out of range.'),\nclose and good_units, add_credit(settings['C1'],'Close.'),\nclose and not good_units, add_credit(settings['C3'],'Answer is close, but missing degree symbol.'),\nincorrect('Wrong answer.')\n)"}, {"name": "interpreted_answer", "description": "A value representing the student's answer to this part.", "definition": "qty(student_scalar, student_units)"}, {"name": "correct_scalar", "description": "", "definition": "scalar(correct_quantity)\n  "}, {"name": "correct_quantity", "description": "", "definition": "settings['correct_quantity']"}, {"name": "correct_units", "description": "", "definition": "units(correct_quantity)"}, {"name": "allowed_notation_styles", "description": "", "definition": "[\"plain\",\"en\"]"}, {"name": "match_student_number", "description": "", "definition": "matchnumber(studentAnswer,allowed_notation_styles)"}, {"name": "student_scalar", "description": "", "definition": "match_student_number[1]"}, {"name": "student_units", "description": "", "definition": "join(\nsplit(studentAnswer[len(match_student_number[0])..len(studentAnswer)]\n,\"\u00b0\"),\" deg\")\n\n"}, {"name": "good_units", "description": "", "definition": "try(\nkind(quantity(1, student_units))= kind(correct_quantity),\nmsg,\nfeedback(msg);false)"}, {"name": "student_quantity", "description": "", "definition": "switch(not good_units, \nstudent_scalar * correct_units, \nnot right_sign,\n-quantity(student_scalar, student_units),\nquantity(student_scalar,student_units)\n)"}, {"name": "right_sign", "description": "", "definition": "sign(student_scalar) = sign(correct_quantity)"}, {"name": "angle_in_range", "description": "", "definition": "if(settings['restrict_angle'], abs(student_scalar) <= 90, true)"}, {"name": "right", "description": "<p>Will check for correct sign elswhere.</p>", "definition": "withinTolerance(abs(student_scalar), abs(correct_scalar), settings['right'])"}, {"name": "close", "description": "<p>Must have correct sign to be close.</p>", "definition": "withinTolerance(student_scalar, correct_scalar, settings['close'])\n"}], "settings": [{"name": "correct_quantity", "label": "Correct Angle as quantity ", "help_url": "", "hint": "", "input_type": "code", "default_value": "qty(45,'deg')", "evaluate": true}, {"name": "right", "label": "Accuracy for right.", "help_url": "", "hint": "Question will be considered correct if the scalar part of the student's answer is within &plusmn; this amount from the correct value.", "input_type": "code", "default_value": "0.1", "evaluate": true}, {"name": "restrict_angle", "label": "Less than 90\u00b0", "help_url": "", "hint": "When checked, angle must be between -90&deg; and +90&deg;.", "input_type": "checkbox", "default_value": true}, {"name": "C1", "label": "Close with units.", "help_url": "", "hint": "Partial Credit for close value with appropriate units.", "input_type": "percent", "default_value": "75"}, {"name": "close", "label": " Accuracy for close.", "help_url": "", "hint": "Question will be considered close if the scalar part of the student's answer is within &plusmn; this amount from the correct value.", "input_type": "code", "default_value": "0.5", "evaluate": true}, {"name": "C2", "label": "No units or wrong sign", "help_url": "", "hint": "Partial credit for forgetting units or using wrong sign.", "input_type": "percent", "default_value": "50"}, {"name": "C3", "label": "Close, no units.", "help_url": "", "hint": "Partial Credit for close value without units.", "input_type": "percent", "default_value": "25"}], "public_availability": "restricted", "published": false, "extensions": ["quantities"]}, {"source": {"pk": 19, "author": {"name": "William Haynes", "pk": 2530}, "edit_page": "/part_type/19/edit"}, "name": "Engineering Accuracy with units", "short_name": "engineering-answer", "description": "<p>A value with units marked right if within an adjustable % error of the correct value. &nbsp;Marked close if within a wider margin of error.</p>", "help_url": "", "input_widget": "string", "input_options": {"correctAnswer": "siground(settings['correctAnswer'],4)", "hint": {"static": true, "value": ""}, "allowEmpty": {"static": true, "value": true}}, "can_be_gap": true, "can_be_step": true, "marking_script": "mark:\nswitch( \n  right and good_units and right_sign, add_credit(1.0,'Correct.'),\n  right and good_units and not right_sign, add_credit(settings['C2'],'Wrong sign.'),\n  right and right_sign and not good_units, add_credit(settings['C2'],'Correct value, but wrong or missing units.'),\n  close and good_units, add_credit(settings['C1'],'Close.'),\n  close and not good_units, add_credit(settings['C3'],'Answer is close, but wrong or missing units.'),\n  incorrect('Wrong answer.')\n)\n\n\ninterpreted_answer:\nqty(student_scalar, student_units)\n\n\n\ncorrect_quantity:\nsettings[\"correctAnswer\"]\n\n\n\ncorrect_units:\nunits(correct_quantity)\n\n\nallowed_notation_styles:\n[\"plain\",\"en\"]\n\nmatch_student_number:\nmatchnumber(studentAnswer,allowed_notation_styles)\n\nstudent_scalar:\nmatch_student_number[1]\n\nstudent_units:\nreplace_regex('ohms','ohm',\n  replace_regex('\u00b0', ' deg',\n    replace_regex('-', ' ' ,\n      studentAnswer[len(match_student_number[0])..len(studentAnswer)])),\"i\")\n\ngood_units:\ntry(\ncompatible(quantity(1, student_units),correct_units),\nmsg,\nfeedback(msg);false)\n\n\nstudent_quantity:\nswitch(not good_units, \n       student_scalar * correct_units, \n       not right_sign,\n       -quantity(student_scalar, student_units),\n       quantity(student_scalar,student_units)\n)\n  \n\n\npercent_error:\ntry(\nscalar(abs((correct_quantity - student_quantity)/correct_quantity))*100  \n,msg,\nif(student_quantity=correct_quantity,0,100))\n   \n\nright:\npercent_error <= settings['right']\n\n\nclose:\nright_sign and percent_error <= settings['close']\n\nright_sign:\nsign(student_scalar) = sign(correct_quantity)", "marking_notes": [{"name": "mark", "description": "This is the main marking note. It should award credit and provide feedback based on the student's answer.", "definition": "switch( \n  right and good_units and right_sign, add_credit(1.0,'Correct.'),\n  right and good_units and not right_sign, add_credit(settings['C2'],'Wrong sign.'),\n  right and right_sign and not good_units, add_credit(settings['C2'],'Correct value, but wrong or missing units.'),\n  close and good_units, add_credit(settings['C1'],'Close.'),\n  close and not good_units, add_credit(settings['C3'],'Answer is close, but wrong or missing units.'),\n  incorrect('Wrong answer.')\n)\n"}, {"name": "interpreted_answer", "description": "A value representing the student's answer to this part.", "definition": "qty(student_scalar, student_units)\n\n"}, {"name": "correct_quantity", "description": "", "definition": "settings[\"correctAnswer\"]\n\n"}, {"name": "correct_units", "description": "", "definition": "units(correct_quantity)\n"}, {"name": "allowed_notation_styles", "description": "", "definition": "[\"plain\",\"en\"]"}, {"name": "match_student_number", "description": "", "definition": "matchnumber(studentAnswer,allowed_notation_styles)"}, {"name": "student_scalar", "description": "", "definition": "match_student_number[1]"}, {"name": "student_units", "description": "<p>Modify&nbsp;the&nbsp;unit portion of&nbsp;the student's answer by</p>\n<p>1. replacing \"ohms\" with \"ohm\" &nbsp;case insensitive</p>\n<p>2.&nbsp;replacing '-'&nbsp;with ' '&nbsp;</p>\n<p>3. replacing '&deg;' with ' deg'&nbsp;</p>\n<p>to allow answers like 10 ft-lb and 30&deg;</p>", "definition": "replace_regex('ohms','ohm',\n  replace_regex('\u00b0', ' deg',\n    replace_regex('-', ' ' ,\n      studentAnswer[len(match_student_number[0])..len(studentAnswer)])),\"i\")"}, {"name": "good_units", "description": "", "definition": "try(\ncompatible(quantity(1, student_units),correct_units),\nmsg,\nfeedback(msg);false)\n"}, {"name": "student_quantity", "description": "<p>This fixes the student answer for two common errors. &nbsp;</p>\n<p>If student_units are wrong&nbsp;&nbsp;- replace with correct units</p>\n<p>If student_scalar has the wrong sign - replace with right sign</p>\n<p>If student makes both errors, only one gets fixed.</p>", "definition": "switch(not good_units, \n       student_scalar * correct_units, \n       not right_sign,\n       -quantity(student_scalar, student_units),\n       quantity(student_scalar,student_units)\n)\n  \n"}, {"name": "percent_error", "description": "", "definition": "try(\nscalar(abs((correct_quantity - student_quantity)/correct_quantity))*100  \n,msg,\nif(student_quantity=correct_quantity,0,100))\n   "}, {"name": "right", "description": "", "definition": "percent_error <= settings['right']\n"}, {"name": "close", "description": "<p>Only marked close if the student actually has the right sign.</p>", "definition": "right_sign and percent_error <= settings['close']"}, {"name": "right_sign", "description": "", "definition": "sign(student_scalar) = sign(correct_quantity) "}], "settings": [{"name": "correctAnswer", "label": "Correct Quantity.", "help_url": "", "hint": "The correct answer given as a JME quantity.", "input_type": "code", "default_value": "", "evaluate": true}, {"name": "right", "label": "% Accuracy for right.", "help_url": "", "hint": "Question will be considered correct if the scalar part of the student's answer is within this % of correct value.", "input_type": "code", "default_value": "0.2", "evaluate": true}, {"name": "close", "label": "% Accuracy for close.", "help_url": "", "hint": "Question will be considered close if the scalar part of the student's answer is within this % of correct value.", "input_type": "code", "default_value": "1.0", "evaluate": true}, {"name": "C1", "label": "Close with units.", "help_url": "", "hint": "Partial Credit for close value with appropriate units. &nbsp;if correct answer is 100 N and close is &plusmn;1%,<br />99 &nbsp;N is accepted.", "input_type": "percent", "default_value": "75"}, {"name": "C2", "label": "No units or wrong sign", "help_url": "", "hint": "Partial credit for forgetting units or using wrong sign.<br />If the correct answer is 100 N, both 100 and -100 N are accepted.", "input_type": "percent", "default_value": "50"}, {"name": "C3", "label": "Close, no units.", "help_url": "", "hint": "Partial Credit for close value but forgotten units.<br />This value would be close&nbsp;if the expected units were provided. &nbsp;If the correct answer is 100 N, and close is &plusmn;1%,<br />99 is accepted.", "input_type": "percent", "default_value": "25"}], "public_availability": "always", "published": true, "extensions": ["quantities"]}], "resources": [], "navigation": {"allowregen": true, "showfrontpage": false, "preventleave": false, "typeendtoleave": false}, "contributors": [{"name": "William Haynes", "profile_url": "https://numbas.mathcentre.ac.uk/accounts/profile/2530/"}], "tags": [], "metadata": {"description": "<p>Calculate the moment of a force about three points using the definition of a Moment. &nbsp;All forces and points are in the same plane.</p>", "licence": "Creative Commons Attribution-NonCommercial 4.0 International"}, "statement": "<p>Force $\\mathbf{F}$, which has a magnitude of {F}, acts along a line passing through points $D$ and $D'$. &nbsp; The grid units are in [{units[0]}] and counter-clockwise moments are positive. &nbsp;</p>\n<p>Determine the moment of the force about points $A$, &nbsp;and $B$ using the definition of the moment: $$M = F \\cdot d_\\perp$$.</p>\n<p style=\"text-align: left;\">{applet}</p>", "advice": "<p>Step a) walks you through the procedure to find a moment using the definition of the moment.</p>\n<p><strong>An alternate approach is to use&nbsp;Verignon's Theorem</strong></p>\n<p>Verigon's theorem says that the moment of a force is the sum of the moments of its components.</p>\n<p>$ M = \\pm F_x d_y \\pm F_y d_x$</p>\n<p>Procedure:</p>\n<ol>\n<li>Decompose force <strong>F</strong> into its <em>x</em>- and <em>y</em>-components.</li>\n<li>Determine the horizontal and vertical distances from the moment center&nbsp;to a point on the line of action of <strong>F</strong>. &nbsp;In this problem:\n<ol>\n<li>$d_x$ is the horizontal distance from <em>D</em>&nbsp;(or <em>D'</em>) to <em>A</em>, <em>B</em>, or <em>C</em>.</li>\n<li>$d_y$ is the vertical&nbsp;distance from <em>D</em> (or <em>D'</em>) to <em>A</em>, <em>B</em>, or <em>C</em>.</li>\n</ol>\n</li>\n<li>The moments of the components are $F_x d_y$ and $F_y d_x$.</li>\n<li>The signs of these moments are determined by inspection: &nbsp;positive if counter-clockwise, negative if clockwise.</li>\n<li>The total moment is the sum of the component moments.</li>\n</ol>", "rulesets": {}, "builtin_constants": {"e": true, "pi,\u03c0": true, "i": true, "j": false}, "constants": [], "variables": {"dir_c": {"name": "dir_c", "group": "Ungrouped variables", "definition": "if(sign(MC)>=0,1,-1)", "description": "", "templateType": "anything", "can_override": false}, "Mc": {"name": "Mc", "group": "Ungrouped variables", "definition": "qty(cross(rc,force)[2], units[0] + ' ' + units[1])", "description": "", "templateType": "anything", "can_override": false}, "dperp_b": {"name": "dperp_b", "group": "Ungrouped variables", "definition": "abs(MB/F)", "description": "", "templateType": "anything", "can_override": false}, "Ma": {"name": "Ma", "group": "Ungrouped variables", "definition": "qty(cross(ra,force)[2], units[0] + ' ' + units[1])\n", "description": "", "templateType": "anything", "can_override": false}, "My": {"name": "My", "group": "Ungrouped variables", "definition": "qty(\n  siground(cross(ra,vector(0,force[1],0))[2],4),\n  units[0] + ' ' + units[1])\n\n", "description": "", "templateType": "anything", "can_override": false}, "MA'": {"name": "MA'", "group": "definition method", "definition": "qty(abs(force),units[1]) * dperp", "description": "", "templateType": "anything", "can_override": false}, "D'": {"name": "D'", "group": "Inputs", "definition": "vector(random(-8..8),random(-8..8))", "description": "<p>Point D' on loa</p>", "templateType": "anything", "can_override": false}, "C": {"name": "C", "group": "Inputs", "definition": "vector(random(-8..8),random(-8..8))", "description": "<p>point C</p>", "templateType": "anything", "can_override": false}, "sum": {"name": "sum", "group": "Ungrouped variables", "definition": "Mx-My", "description": "", "templateType": "anything", "can_override": false}, "Mx": {"name": "Mx", "group": "Ungrouped variables", "definition": "qty(\n  siground(cross(ra,vector(force[0],0,0))[2],4),\n  units[0] + ' ' + units[1])\n\n", "description": "<p>Moment of F_x about point A</p>", "templateType": "anything", "can_override": false}, "dperp_c": {"name": "dperp_c", "group": "Ungrouped variables", "definition": "abs(MC/F)", "description": "", "templateType": "anything", "can_override": false}, "Fy": {"name": "Fy", "group": "Ungrouped variables", "definition": "qty(force[1],units[1])", "description": "", "templateType": "anything", "can_override": false}, "rc": {"name": "rc", "group": "Ungrouped variables", "definition": "D-C+vector(0,0,0)\n", "description": "<p>position vector</p>", "templateType": "anything", "can_override": false}, "rb": {"name": "rb", "group": "Ungrouped variables", "definition": "D-B+vector(0,0,0)\n", "description": "<p>position vector</p>", "templateType": "anything", "can_override": false}, "ra": {"name": "ra", "group": "Ungrouped variables", "definition": "D-A+vector(0,0,0)", "description": "<p>position vector</p>", "templateType": "anything", "can_override": false}, "units": {"name": "units", "group": "Inputs", "definition": "random(['in','lb'],['ft','lb'],['m','N'],['m','kN'])", "description": "", "templateType": "anything", "can_override": false}, "dperp_a": {"name": "dperp_a", "group": "Ungrouped variables", "definition": "abs(MA/F)", "description": "", "templateType": "anything", "can_override": false}, "dir_b": {"name": "dir_b", "group": "Ungrouped variables", "definition": "if(sign(MB)>=0,1,-1)", "description": "", "templateType": "anything", "can_override": false}, "Mb": {"name": "Mb", "group": "Ungrouped variables", "definition": "qty(cross(rb,force)[2], units[0] + ' ' + units[1])", "description": "", "templateType": "anything", "can_override": false}, "theta_A": {"name": "theta_A", "group": "definition method", "definition": "let( ang,degrees(arccos((dot(ra,force)/abs(ra)/abs(force)))),if(ang<90,ang,180-ang))", "description": "", "templateType": "anything", "can_override": false}, "force": {"name": "force", "group": "Ungrouped variables", "definition": "scalar(F)(D'-D)/abs(D'-D) + vector(0,0,0)\n", "description": "<p></p>\n<p>Vector Force &nbsp;= F &lambda;</p>\n<p>&lambda; =&nbsp;(D'-D)/abs(D'-D)</p>", "templateType": "anything", "can_override": false}, "Fx": {"name": "Fx", "group": "Ungrouped variables", "definition": "qty(force[0],units[1])", "description": "", "templateType": "anything", "can_override": false}, "test": {"name": "test", "group": "definition method", "definition": "siground(dperp,4)", "description": "", "templateType": "anything", "can_override": false}, "A": {"name": "A", "group": "Inputs", "definition": "vector(random(-8..8),random(-8..8))", "description": "<p>point A</p>", "templateType": "anything", "can_override": false}, "D": {"name": "D", "group": "Inputs", "definition": "vector(random(-8..8),random(-8..8))", "description": "<p>Point D</p>", "templateType": "anything", "can_override": false}, "debug": {"name": "debug", "group": "Inputs", "definition": "false", "description": "", "templateType": "anything", "can_override": false}, "dir_a": {"name": "dir_a", "group": "Ungrouped variables", "definition": "if(sign(MA)>=0,1,-1)", "description": "<p>replacement variable for direction of moment.</p>", "templateType": "anything", "can_override": false}, "B": {"name": "B", "group": "Inputs", "definition": "vector(random(-8..8),random(-8..8))", "description": "<p>point B</p>", "templateType": "anything", "can_override": false}, "AD": {"name": "AD", "group": "definition method", "definition": "qty(abs(A-D),units[0])", "description": "", "templateType": "anything", "can_override": false}, "F": {"name": "F", "group": "Inputs", "definition": "qty(random(1..5)random(1,2,5,10,20),units[1])", "description": "<p>Magnitude of force F</p>", "templateType": "anything", "can_override": false}, "dperp": {"name": "dperp", "group": "definition method", "definition": "AD sin(radians(theta_a))", "description": "", "templateType": "anything", "can_override": false}, "applet": {"name": "applet", "group": "Ungrouped variables", "definition": "geogebra_applet('n8thnjk7',params)\n", "description": "", "templateType": "anything", "can_override": false}, "params": {"name": "params", "group": "Ungrouped variables", "definition": "[A: A, B: B, C: C, D: D, D': D', F: scalar(F)]\n\n", "description": "", "templateType": "anything", "can_override": false}}, "variablesTest": {"condition": "// makes sure that no point aligns vertically or horizontally with another\nnot some(map(p[0]=q[0] or p[1]=q[1],[p,q],combinations([A,B,C,D,D'],2)))\nand sign(Ma)<>sign(Mc)\nand theta_A >  15\nand all(map(scalar(d)>=1,d,[dperp_a,dperp_b,dperp_c]))", "maxRuns": 100}, "ungrouped_variables": ["ra", "rb", "rc", "force", "Mx", "My", "Ma", "Mb", "Mc", "sum", "Fx", "Fy", "dir_a", "dir_b", "dir_c", "dperp_a", "dperp_b", "dperp_c", "applet", "params"], "variable_groups": [{"name": "Inputs", "variables": ["A", "B", "C", "D", "D'", "F", "units", "debug"]}, {"name": "definition method", "variables": ["theta_A", "AD", "dperp", "MA'", "test"]}, {"name": "Unnamed group", "variables": []}], "functions": {}, "preamble": {"js": "", "css": ""}, "parts": [{"type": "gapfill", "useCustomName": true, "customName": "Geometry", "marks": 0, "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": true, "showFeedbackIcon": true, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "prompt": "<p>Find the length of the line segment from $A$ to $D$. &nbsp; (Or any other point on the line of action of <strong>F</strong>.)</p>\n<p>$d$ =&nbsp;[[0]] &nbsp;<span data-jme-visible=\"debug\">{qty(siground(abs(A-D),4),units[0])&nbsp;}</span></p>\n<p>Find the angle (&lt;= 90&deg;) between segment $\\overline{AD}$ and the line of action of <strong>F</strong>.</p>\n<p>$\\theta_A =$&nbsp;[[1]] &nbsp;<span data-jme-visible=\"debug\">{qty(siground(theta_A,4),'deg') }</span></p>\n<p>Find the perpendicular distance between point $A$ and the line of action of force <strong>F</strong>.</p>\n<p>$d_\\perp =$&nbsp;[[2]]&nbsp; &nbsp;<span data-jme-visible=\"debug\">{siground(dperp,4)}</span></p>", "gaps": [{"type": "engineering-answer", "useCustomName": true, "customName": "AD", "marks": "4", "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": true, "showFeedbackIcon": true, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "settings": {"correctAnswer": "AD", "right": "0.2", "close": "1.0", "C1": "75", "C2": "50", "C3": "25"}}, {"type": "angle-quantity-from-reference", "useCustomName": true, "customName": "$\u03b8_A$", "marks": "4", "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": true, "showFeedbackIcon": true, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "settings": {"correct_quantity": "siground(qty(theta_A,'deg'),4)", "right": "0.2", "restrict_angle": true, "C1": "75", "close": "1.0", "C2": "50", "C3": "25"}}, {"type": "engineering-answer", "useCustomName": true, "customName": "$d_\u27c2$", "marks": "4", "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": true, "showFeedbackIcon": true, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "settings": {"correctAnswer": "dperp", "right": "0.2", "close": "1.0", "C1": "75", "C2": "50", "C3": "25"}}], "sortAnswers": false}, {"type": "gapfill", "useCustomName": true, "customName": "$M_A$", "marks": 0, "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": true, "showFeedbackIcon": true, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "prompt": "<p>Use the definition of the moment $M_A = F \\cdot d_\\perp$&nbsp;to find the moment of <strong>F</strong> about <em>A</em>.</p>\n<p>$\\textbf{M}_A$ is a&nbsp;[[0]]&nbsp;moment with a magnitude of&nbsp;[[1]].</p>\n<p><span data-jme-visible=\"debug\">$M_A$= {siground(Ma,4)}&nbsp;</span>&nbsp;</p>", "gaps": [{"type": "1_n_2", "useCustomName": true, "customName": "direction", "marks": 0, "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": false, "showFeedbackIcon": false, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "minMarks": 0, "maxMarks": 0, "shuffleChoices": false, "displayType": "dropdownlist", "displayColumns": 0, "showBlankOption": true, "showCellAnswerState": true, "choices": ["Counterclockwise", "Clockwise"], "matrix": ["if(dir_a=1,2,0)", "if(dir_a=-1,2,0)"], "distractors": ["You chose Counterclockwise", "You chose Clockwise."]}, {"type": "engineering-answer", "useCustomName": true, "customName": "$M_A$", "marks": "4", "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": true, "showFeedbackIcon": true, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "settings": {"correctAnswer": "abs(Ma)", "right": "0.2", "close": "1.0", "C1": "75", "C2": "50", "C3": "25"}}], "sortAnswers": false}, {"type": "gapfill", "useCustomName": true, "customName": "$M_B$", "marks": 0, "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": true, "showFeedbackIcon": true, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "prompt": "<p>In the same way, determine the moment of force <strong>F</strong> about point <em>B</em>. &nbsp;&nbsp;&nbsp;</p>\n<p>$\\textbf{M}_B$ is a&nbsp;[[0]]&nbsp;moment with a magnitude of&nbsp;[[1]].</p>\n<p><span data-jme-visible=\"debug\">$M_b$= {siground(Mb,4)}&nbsp;</span>&nbsp;</p>", "gaps": [{"type": "1_n_2", "useCustomName": true, "customName": "direction", "marks": 0, "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": false, "showFeedbackIcon": false, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "minMarks": 0, "maxMarks": 0, "shuffleChoices": false, "displayType": "dropdownlist", "displayColumns": 0, "showBlankOption": true, "showCellAnswerState": true, "choices": ["Counterclockwise", "Clockwise"], "matrix": ["if(dir_b=1,2,0)", "if(dir_b=-1,2,0)"], "distractors": ["You chose Counterclockwise", "You chose Clockwise."]}, {"type": "engineering-answer", "useCustomName": true, "customName": "$M_B$", "marks": "10", "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": true, "showFeedbackIcon": true, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "settings": {"correctAnswer": "abs(Mb)", "right": "0.2", "close": "1.0", "C1": "75", "C2": "50", "C3": "25"}}], "sortAnswers": false}], "partsMode": "all", "maxMarks": 0, "objectives": [], "penalties": [], "objectiveVisibility": "always", "penaltyVisibility": "always"}, {"name": "Moment of a Force: using Verignon's Theorem", "extensions": ["geogebra", "quantities"], "custom_part_types": [{"source": {"pk": 19, "author": {"name": "William Haynes", "pk": 2530}, "edit_page": "/part_type/19/edit"}, "name": "Engineering Accuracy with units", "short_name": "engineering-answer", "description": "<p>A value with units marked right if within an adjustable % error of the correct value. &nbsp;Marked close if within a wider margin of error.</p>", "help_url": "", "input_widget": "string", "input_options": {"correctAnswer": "siground(settings['correctAnswer'],4)", "hint": {"static": true, "value": ""}, "allowEmpty": {"static": true, "value": true}}, "can_be_gap": true, "can_be_step": true, "marking_script": "mark:\nswitch( \n  right and good_units and right_sign, add_credit(1.0,'Correct.'),\n  right and good_units and not right_sign, add_credit(settings['C2'],'Wrong sign.'),\n  right and right_sign and not good_units, add_credit(settings['C2'],'Correct value, but wrong or missing units.'),\n  close and good_units, add_credit(settings['C1'],'Close.'),\n  close and not good_units, add_credit(settings['C3'],'Answer is close, but wrong or missing units.'),\n  incorrect('Wrong answer.')\n)\n\n\ninterpreted_answer:\nqty(student_scalar, student_units)\n\n\n\ncorrect_quantity:\nsettings[\"correctAnswer\"]\n\n\n\ncorrect_units:\nunits(correct_quantity)\n\n\nallowed_notation_styles:\n[\"plain\",\"en\"]\n\nmatch_student_number:\nmatchnumber(studentAnswer,allowed_notation_styles)\n\nstudent_scalar:\nmatch_student_number[1]\n\nstudent_units:\nreplace_regex('ohms','ohm',\n  replace_regex('\u00b0', ' deg',\n    replace_regex('-', ' ' ,\n      studentAnswer[len(match_student_number[0])..len(studentAnswer)])),\"i\")\n\ngood_units:\ntry(\ncompatible(quantity(1, student_units),correct_units),\nmsg,\nfeedback(msg);false)\n\n\nstudent_quantity:\nswitch(not good_units, \n       student_scalar * correct_units, \n       not right_sign,\n       -quantity(student_scalar, student_units),\n       quantity(student_scalar,student_units)\n)\n  \n\n\npercent_error:\ntry(\nscalar(abs((correct_quantity - student_quantity)/correct_quantity))*100  \n,msg,\nif(student_quantity=correct_quantity,0,100))\n   \n\nright:\npercent_error <= settings['right']\n\n\nclose:\nright_sign and percent_error <= settings['close']\n\nright_sign:\nsign(student_scalar) = sign(correct_quantity)", "marking_notes": [{"name": "mark", "description": "This is the main marking note. It should award credit and provide feedback based on the student's answer.", "definition": "switch( \n  right and good_units and right_sign, add_credit(1.0,'Correct.'),\n  right and good_units and not right_sign, add_credit(settings['C2'],'Wrong sign.'),\n  right and right_sign and not good_units, add_credit(settings['C2'],'Correct value, but wrong or missing units.'),\n  close and good_units, add_credit(settings['C1'],'Close.'),\n  close and not good_units, add_credit(settings['C3'],'Answer is close, but wrong or missing units.'),\n  incorrect('Wrong answer.')\n)\n"}, {"name": "interpreted_answer", "description": "A value representing the student's answer to this part.", "definition": "qty(student_scalar, student_units)\n\n"}, {"name": "correct_quantity", "description": "", "definition": "settings[\"correctAnswer\"]\n\n"}, {"name": "correct_units", "description": "", "definition": "units(correct_quantity)\n"}, {"name": "allowed_notation_styles", "description": "", "definition": "[\"plain\",\"en\"]"}, {"name": "match_student_number", "description": "", "definition": "matchnumber(studentAnswer,allowed_notation_styles)"}, {"name": "student_scalar", "description": "", "definition": "match_student_number[1]"}, {"name": "student_units", "description": "<p>Modify&nbsp;the&nbsp;unit portion of&nbsp;the student's answer by</p>\n<p>1. replacing \"ohms\" with \"ohm\" &nbsp;case insensitive</p>\n<p>2.&nbsp;replacing '-'&nbsp;with ' '&nbsp;</p>\n<p>3. replacing '&deg;' with ' deg'&nbsp;</p>\n<p>to allow answers like 10 ft-lb and 30&deg;</p>", "definition": "replace_regex('ohms','ohm',\n  replace_regex('\u00b0', ' deg',\n    replace_regex('-', ' ' ,\n      studentAnswer[len(match_student_number[0])..len(studentAnswer)])),\"i\")"}, {"name": "good_units", "description": "", "definition": "try(\ncompatible(quantity(1, student_units),correct_units),\nmsg,\nfeedback(msg);false)\n"}, {"name": "student_quantity", "description": "<p>This fixes the student answer for two common errors. &nbsp;</p>\n<p>If student_units are wrong&nbsp;&nbsp;- replace with correct units</p>\n<p>If student_scalar has the wrong sign - replace with right sign</p>\n<p>If student makes both errors, only one gets fixed.</p>", "definition": "switch(not good_units, \n       student_scalar * correct_units, \n       not right_sign,\n       -quantity(student_scalar, student_units),\n       quantity(student_scalar,student_units)\n)\n  \n"}, {"name": "percent_error", "description": "", "definition": "try(\nscalar(abs((correct_quantity - student_quantity)/correct_quantity))*100  \n,msg,\nif(student_quantity=correct_quantity,0,100))\n   "}, {"name": "right", "description": "", "definition": "percent_error <= settings['right']\n"}, {"name": "close", "description": "<p>Only marked close if the student actually has the right sign.</p>", "definition": "right_sign and percent_error <= settings['close']"}, {"name": "right_sign", "description": "", "definition": "sign(student_scalar) = sign(correct_quantity) "}], "settings": [{"name": "correctAnswer", "label": "Correct Quantity.", "help_url": "", "hint": "The correct answer given as a JME quantity.", "input_type": "code", "default_value": "", "evaluate": true}, {"name": "right", "label": "% Accuracy for right.", "help_url": "", "hint": "Question will be considered correct if the scalar part of the student's answer is within this % of correct value.", "input_type": "code", "default_value": "0.2", "evaluate": true}, {"name": "close", "label": "% Accuracy for close.", "help_url": "", "hint": "Question will be considered close if the scalar part of the student's answer is within this % of correct value.", "input_type": "code", "default_value": "1.0", "evaluate": true}, {"name": "C1", "label": "Close with units.", "help_url": "", "hint": "Partial Credit for close value with appropriate units. &nbsp;if correct answer is 100 N and close is &plusmn;1%,<br />99 &nbsp;N is accepted.", "input_type": "percent", "default_value": "75"}, {"name": "C2", "label": "No units or wrong sign", "help_url": "", "hint": "Partial credit for forgetting units or using wrong sign.<br />If the correct answer is 100 N, both 100 and -100 N are accepted.", "input_type": "percent", "default_value": "50"}, {"name": "C3", "label": "Close, no units.", "help_url": "", "hint": "Partial Credit for close value but forgotten units.<br />This value would be close&nbsp;if the expected units were provided. &nbsp;If the correct answer is 100 N, and close is &plusmn;1%,<br />99 is accepted.", "input_type": "percent", "default_value": "25"}], "public_availability": "always", "published": true, "extensions": ["quantities"]}], "resources": [], "navigation": {"allowregen": true, "showfrontpage": false, "preventleave": false, "typeendtoleave": false}, "contributors": [{"name": "William Haynes", "profile_url": "https://numbas.mathcentre.ac.uk/accounts/profile/2530/"}], "tags": ["Mechanics, statics, moments, verignon's theorem"], "metadata": {"description": "<p>Calculate the moment of a force about three points using Verignon' theorem. &nbsp;All forces and points are in the same plane.</p>", "licence": "Creative Commons Attribution-NonCommercial 4.0 International"}, "statement": "<p>{applet}</p>\n<p>Force $\\mathbf{F}$, which has a magnitude of {F}, acts along a line passing through points $D$ and $D'$. &nbsp; The grid units are in [<em>{units[0]}</em>]&nbsp;and counter-clockwise moments are positive. &nbsp;Determine the moment of the force about points $A$&nbsp;and&nbsp;$B$ using Verignon's Theorem</p>\n<p></p>\n<p></p>", "advice": "<p>Verignon's Theorem: &nbsp;$M = \\pm F_x\\ d_y \\pm F_y\\ d_x$</p>\n<p>Verigon's theorem says that the moment of a force is the sum of the moments of its components.</p>\n<p>Procedure:</p>\n<ol>\n<li>Decompose force $\\mathbf{F}$ into its $x$- and <i>$y$</i>-components.</li>\n<li>Determine the horizontal and vertical distances from the moment center to a point on the line of action of $\\mathbf{F}$. &nbsp;In this problem:\n<ol>\n<li>$d_x$ is the horizontal distance from $D$ or $D'$ to point $A$ or&nbsp;$B$.</li>\n<li>$d_y$ is the vertical distance from $D$ or $D'$&nbsp;to $A$ or &nbsp;$B$.</li>\n</ol>\n</li>\n<li>The moments of the components are $F_x\\ d_y$ and $F_y\\ d_x$.</li>\n<li>The signs of these moments are determined by inspection: &nbsp;positive if counter-clockwise, negative if clockwise.</li>\n<li>The total moment is the sum of the component moments.</li>\n</ol>", "rulesets": {}, "builtin_constants": {"e": true, "pi,\u03c0": true, "i": true}, "constants": [], "variables": {"Fy": {"name": "Fy", "group": "Ungrouped variables", "definition": "qty(force[1],units[1])", "description": "", "templateType": "anything", "can_override": false}, "test2": {"name": "test2", "group": "Inputs", "definition": "some(map(p[0]=q[0] or p[1]=q[1],[p,q],combinations([A,B,C,D,D'],2)))", "description": "<p>map(sqrt(x^2+y^2),[x,y],[ [3,4], [5,12] ])</p>", "templateType": "anything", "can_override": false}, "dir_b": {"name": "dir_b", "group": "Ungrouped variables", "definition": "if(sign(MB)>=0,1,-1)", "description": "", "templateType": "anything", "can_override": false}, "dir_c": {"name": "dir_c", "group": "Ungrouped variables", "definition": "if(sign(MC)>=0,1,-1)", "description": "", "templateType": "anything", "can_override": false}, "Fx": {"name": "Fx", "group": "Ungrouped variables", "definition": "qty(force[0],units[1])", "description": "", "templateType": "anything", "can_override": false}, "Ma": {"name": "Ma", "group": "Ungrouped variables", "definition": "qty(cross(ra,force)[2], units[0] + ' ' + units[1])\n", "description": "", "templateType": "anything", "can_override": false}, "Mc": {"name": "Mc", "group": "Ungrouped variables", "definition": "qty(cross(rc,force)[2], units[0] + ' ' + units[1])", "description": "", "templateType": "anything", "can_override": false}, "ra": {"name": "ra", "group": "Ungrouped variables", "definition": "D-A+vector(0,0,0)", "description": "<p>position vector</p>", "templateType": "anything", "can_override": false}, "units": {"name": "units", "group": "Inputs", "definition": "random(['in','lb'],['ft','lb'],['m','N'],['m','kN'])", "description": "", "templateType": "anything", "can_override": false}, "D": {"name": "D", "group": "Inputs", "definition": "vector(random(-8..8),random(-8..8))", "description": "<p>Point D</p>", "templateType": "anything", "can_override": false}, "B": {"name": "B", "group": "Inputs", "definition": "vector(random(-8..8),random(-8..8))", "description": "<p>point B</p>", "templateType": "anything", "can_override": false}, "Mb": {"name": "Mb", "group": "Ungrouped variables", "definition": "qty(cross(rb,force)[2], units[0] + ' ' + units[1])", "description": "", "templateType": "anything", "can_override": false}, "force": {"name": "force", "group": "Ungrouped variables", "definition": "scalar(F)(D'-D)/abs(D'-D) + vector(0,0,0)\n", "description": "<p></p>\n<p>Vector Force &nbsp;= F &lambda;</p>\n<p>&lambda; =&nbsp;(D'-D)/abs(D'-D)</p>", "templateType": "anything", "can_override": false}, "A": {"name": "A", "group": "Inputs", "definition": "vector(random(-8..8),random(-8..8))", "description": "<p>point A</p>", "templateType": "anything", "can_override": false}, "dir_a": {"name": "dir_a", "group": "Ungrouped variables", "definition": "if(sign(MA)>=0,1,-1)", "description": "<p>replacement variable for direction of moment.</p>", "templateType": "anything", "can_override": false}, "rc": {"name": "rc", "group": "Ungrouped variables", "definition": "D-C+vector(0,0,0)\n", "description": "<p>position vector</p>", "templateType": "anything", "can_override": false}, "sum": {"name": "sum", "group": "Ungrouped variables", "definition": "Mx-My", "description": "", "templateType": "anything", "can_override": false}, "rb": {"name": "rb", "group": "Ungrouped variables", "definition": "D-B+vector(0,0,0)\n", "description": "<p>position vector</p>", "templateType": "anything", "can_override": false}, "F": {"name": "F", "group": "Inputs", "definition": "qty(random(1..5)random(1,2,5,10,20),units[1])", "description": "<p>Magnitude of force F</p>", "templateType": "anything", "can_override": false}, "debug": {"name": "debug", "group": "Inputs", "definition": "false", "description": "", "templateType": "anything", "can_override": false}, "test": {"name": "test", "group": "Inputs", "definition": "align(A,B)", "description": "", "templateType": "anything", "can_override": false}, "D'": {"name": "D'", "group": "Inputs", "definition": "vector(random(-8..8),random(-8..8))", "description": "<p>Point D' on loa</p>", "templateType": "anything", "can_override": false}, "C": {"name": "C", "group": "Inputs", "definition": "vector(random(-8..8),random(-8..8))", "description": "<p>point C</p>", "templateType": "anything", "can_override": false}, "My": {"name": "My", "group": "Ungrouped variables", "definition": "qty(\n  siground(cross(ra,vector(0,force[1],0))[2],4),\n  units[0] + ' ' + units[1])\n\n", "description": "", "templateType": "anything", "can_override": false}, "Mx": {"name": "Mx", "group": "Ungrouped variables", "definition": "qty(\n  siground(cross(ra,vector(force[0],0,0))[2],4),\n  units[0] + ' ' + units[1])\n\n", "description": "<p>Moment of F_x about point A</p>", "templateType": "anything", "can_override": false}, "applet": {"name": "applet", "group": "Ungrouped variables", "definition": "geogebra_applet('n8thnjk7', params)\n\n", "description": "", "templateType": "anything", "can_override": false}, "params": {"name": "params", "group": "Ungrouped variables", "definition": "[A: A, B: B, C: C, D: D ,D': D', F: scalar(F)]", "description": "", "templateType": "anything", "can_override": false}}, "variablesTest": {"condition": "// makes sure that no point aligns vertically or horizontally with another\nnot some(map(p[0]=q[0] or p[1]=q[1],[p,q],combinations([A,B,C,D,D'],2)))\nand sign(ma)<>sign(mb)\n", "maxRuns": 100}, "ungrouped_variables": ["ra", "rb", "rc", "force", "Mx", "My", "Ma", "Mb", "Mc", "sum", "Fx", "Fy", "dir_a", "dir_b", "dir_c", "applet", "params"], "variable_groups": [{"name": "Inputs", "variables": ["A", "B", "C", "D", "D'", "F", "units", "debug", "test", "test2"]}], "functions": {"Align": {"parameters": [["V1", "vector"], ["V2", "vector"]], "type": "boolean", "language": "jme", "definition": "(V1[0]=V2[0]) or (V1[1]=V2[1])"}}, "preamble": {"js": "", "css": ""}, "parts": [{"type": "gapfill", "useCustomName": true, "customName": "Rectangular components", "marks": 0, "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": true, "showFeedbackIcon": true, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "prompt": "<p>Determine the magnitudes of the rectangular&nbsp;components of $\\mathbf{F}$.</p>\n<p>$F_x$ =&nbsp;[[0]] &nbsp;$F_y$ =&nbsp;[[1]]&nbsp; &nbsp;<span data-jme-visible=\"debug\">$F_x$ = {siground(Fx,4)} $F_y$ = {siground(Fy,4)}</span></p>\n<p>Determine the horizontal and vertical distances from $D$ to $A$.</p>\n<p>$d_x$ =&nbsp;[[2]] &nbsp;$d_y$ =&nbsp;[[3]]&nbsp; <span data-jme-visible=\"debug\">Delta = {D-A}</span></p>\n<p></p>\n<p></p>\n<p></p>\n<p></p>", "gaps": [{"type": "engineering-answer", "useCustomName": true, "customName": "fx", "marks": "5", "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": true, "showFeedbackIcon": true, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "settings": {"correctAnswer": "abs(Fx)", "right": "0.2", "close": "1.0", "C1": "75", "C2": "50", "C3": "25"}}, {"type": "engineering-answer", "useCustomName": true, "customName": "fy", "marks": "5", "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": true, "showFeedbackIcon": true, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "settings": {"correctAnswer": "abs(Fy)", "right": "0.2", "close": "1.0", "C1": "75", "C2": "50", "C3": "25"}}, {"type": "engineering-answer", "useCustomName": true, "customName": "dx", "marks": "5", "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": true, "showFeedbackIcon": true, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "settings": {"correctAnswer": "abs(qty((D-A)[0],units[0]))", "right": "0.2", "close": "1.0", "C1": "75", "C2": "50", "C3": "25"}}, {"type": "engineering-answer", "useCustomName": true, "customName": "dy", "marks": "5", "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": true, "showFeedbackIcon": true, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "settings": {"correctAnswer": "abs(qty((D-A)[1],units[0]))", "right": "0.2", "close": "1.0", "C1": "75", "C2": "50", "C3": "25"}}], "sortAnswers": false}, {"type": "gapfill", "useCustomName": true, "customName": " Scalar Components of $M_A$", "marks": 0, "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": true, "showFeedbackIcon": true, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "prompt": "<p>Determine the moments of the components. &nbsp;Counterclockwise moment are positive.</p>\n<p>The moment of $F_x$ about point $A$ is [[0]]&nbsp;<span data-jme-visible=\"debug\">= {siground(mx,4)}</span></p>\n<p>The moment of&nbsp;$F_y$ is about point $A$ is&nbsp;[[1]]&nbsp;&nbsp;<span data-jme-visible=\"debug\">= {siground(my,4)}</span></p>\n<p>&nbsp;</p>\n<p></p>\n<p></p>\n<p></p>", "gaps": [{"type": "engineering-answer", "useCustomName": true, "customName": "M1", "marks": "5", "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": true, "showFeedbackIcon": true, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "settings": {"correctAnswer": "Mx", "right": "0.2", "close": "1.0", "C1": "75", "C2": "50", "C3": "25"}}, {"type": "engineering-answer", "useCustomName": true, "customName": "M2", "marks": "5", "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": true, "showFeedbackIcon": true, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "settings": {"correctAnswer": "My", "right": "0.2", "close": "1.0", "C1": "75", "C2": "50", "C3": "25"}}], "sortAnswers": false}, {"type": "gapfill", "useCustomName": true, "customName": "$M_A$", "marks": 0, "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": true, "showFeedbackIcon": true, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "prompt": "<p>Add the moments of the components to determine the moment&nbsp;of force $\\mathbf{F}$ about point $A$ . &nbsp;&nbsp;</p>\n<p>$\\mathbf{M}_A$ is a&nbsp;[[0]]&nbsp;moment with a magnitude of&nbsp;[[1]]</p>", "gaps": [{"type": "1_n_2", "useCustomName": true, "customName": "direction", "marks": 0, "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": false, "showFeedbackIcon": false, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "minMarks": 0, "maxMarks": 0, "shuffleChoices": false, "displayType": "dropdownlist", "displayColumns": 0, "showCellAnswerState": true, "choices": ["Counterclockwise", "Clockwise"], "matrix": ["if(dir_a=1,5,0)", "if(dir_a=-1,5,0)"], "distractors": ["You chose Counterclockwise", "You chose Clockwise."]}, {"type": "engineering-answer", "useCustomName": true, "customName": "Mag", "marks": "5", "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": true, "showFeedbackIcon": true, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "settings": {"correctAnswer": "abs(Ma)", "right": "0.2", "close": "1.0", "C1": "75", "C2": "50", "C3": "25"}}], "sortAnswers": false}, {"type": "gapfill", "useCustomName": true, "customName": "$M_B$", "marks": 0, "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": true, "showFeedbackIcon": true, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "prompt": "<p>In the same way, determine the moment of force $\\mathbf{F}$ about point $B$ . &nbsp;&nbsp;&nbsp;</p>\n<p>$\\mathbf{M}_B$ is a&nbsp;[[0]]&nbsp;moment with a magnitude of&nbsp;[[1]]</p>\n<p><span data-jme-visible=\"debug\">$M_b$= {siground(Mb,4)}</span>.</p>", "gaps": [{"type": "1_n_2", "useCustomName": true, "customName": "Direction", "marks": 0, "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": false, "showFeedbackIcon": false, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "minMarks": 0, "maxMarks": 0, "shuffleChoices": false, "displayType": "dropdownlist", "displayColumns": 0, "showCellAnswerState": true, "choices": ["Counterclockwise", "Clockwise"], "matrix": ["if(dir_b=1,5,0)", "if(dir_b=-1,5,0)"], "distractors": ["You chose Counterclockwise", "You chose Clockwise."]}, {"type": "engineering-answer", "useCustomName": true, "customName": "Mag", "marks": "5", "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": true, "showFeedbackIcon": true, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "settings": {"correctAnswer": "abs(Mb)", "right": "0.2", "close": "1.0", "C1": "75", "C2": "50", "C3": "25"}}], "sortAnswers": false}], "partsMode": "all", "maxMarks": 0, "objectives": [], "penalties": [], "objectiveVisibility": "always", "penaltyVisibility": "always", "type": "question"}, {"name": "Moment of a force about a point", "extensions": ["geogebra", "quantities"], "custom_part_types": [{"source": {"pk": 19, "author": {"name": "William Haynes", "pk": 2530}, "edit_page": "/part_type/19/edit"}, "name": "Engineering Accuracy with units", "short_name": "engineering-answer", "description": "<p>A value with units marked right if within an adjustable % error of the correct value. &nbsp;Marked close if within a wider margin of error.</p>", "help_url": "", "input_widget": "string", "input_options": {"correctAnswer": "siground(settings['correctAnswer'],4)", "hint": {"static": true, "value": ""}, "allowEmpty": {"static": true, "value": true}}, "can_be_gap": true, "can_be_step": true, "marking_script": "mark:\nswitch( \n  right and good_units and right_sign, add_credit(1.0,'Correct.'),\n  right and good_units and not right_sign, add_credit(settings['C2'],'Wrong sign.'),\n  right and right_sign and not good_units, add_credit(settings['C2'],'Correct value, but wrong or missing units.'),\n  close and good_units, add_credit(settings['C1'],'Close.'),\n  close and not good_units, add_credit(settings['C3'],'Answer is close, but wrong or missing units.'),\n  incorrect('Wrong answer.')\n)\n\n\ninterpreted_answer:\nqty(student_scalar, student_units)\n\n\n\ncorrect_quantity:\nsettings[\"correctAnswer\"]\n\n\n\ncorrect_units:\nunits(correct_quantity)\n\n\nallowed_notation_styles:\n[\"plain\",\"en\"]\n\nmatch_student_number:\nmatchnumber(studentAnswer,allowed_notation_styles)\n\nstudent_scalar:\nmatch_student_number[1]\n\nstudent_units:\nreplace_regex('ohms','ohm',\n  replace_regex('\u00b0', ' deg',\n    replace_regex('-', ' ' ,\n      studentAnswer[len(match_student_number[0])..len(studentAnswer)])),\"i\")\n\ngood_units:\ntry(\ncompatible(quantity(1, student_units),correct_units),\nmsg,\nfeedback(msg);false)\n\n\nstudent_quantity:\nswitch(not good_units, \n       student_scalar * correct_units, \n       not right_sign,\n       -quantity(student_scalar, student_units),\n       quantity(student_scalar,student_units)\n)\n  \n\n\npercent_error:\ntry(\nscalar(abs((correct_quantity - student_quantity)/correct_quantity))*100  \n,msg,\nif(student_quantity=correct_quantity,0,100))\n   \n\nright:\npercent_error <= settings['right']\n\n\nclose:\nright_sign and percent_error <= settings['close']\n\nright_sign:\nsign(student_scalar) = sign(correct_quantity)", "marking_notes": [{"name": "mark", "description": "This is the main marking note. It should award credit and provide feedback based on the student's answer.", "definition": "switch( \n  right and good_units and right_sign, add_credit(1.0,'Correct.'),\n  right and good_units and not right_sign, add_credit(settings['C2'],'Wrong sign.'),\n  right and right_sign and not good_units, add_credit(settings['C2'],'Correct value, but wrong or missing units.'),\n  close and good_units, add_credit(settings['C1'],'Close.'),\n  close and not good_units, add_credit(settings['C3'],'Answer is close, but wrong or missing units.'),\n  incorrect('Wrong answer.')\n)\n"}, {"name": "interpreted_answer", "description": "A value representing the student's answer to this part.", "definition": "qty(student_scalar, student_units)\n\n"}, {"name": "correct_quantity", "description": "", "definition": "settings[\"correctAnswer\"]\n\n"}, {"name": "correct_units", "description": "", "definition": "units(correct_quantity)\n"}, {"name": "allowed_notation_styles", "description": "", "definition": "[\"plain\",\"en\"]"}, {"name": "match_student_number", "description": "", "definition": "matchnumber(studentAnswer,allowed_notation_styles)"}, {"name": "student_scalar", "description": "", "definition": "match_student_number[1]"}, {"name": "student_units", "description": "<p>Modify&nbsp;the&nbsp;unit portion of&nbsp;the student's answer by</p>\n<p>1. replacing \"ohms\" with \"ohm\" &nbsp;case insensitive</p>\n<p>2.&nbsp;replacing '-'&nbsp;with ' '&nbsp;</p>\n<p>3. replacing '&deg;' with ' deg'&nbsp;</p>\n<p>to allow answers like 10 ft-lb and 30&deg;</p>", "definition": "replace_regex('ohms','ohm',\n  replace_regex('\u00b0', ' deg',\n    replace_regex('-', ' ' ,\n      studentAnswer[len(match_student_number[0])..len(studentAnswer)])),\"i\")"}, {"name": "good_units", "description": "", "definition": "try(\ncompatible(quantity(1, student_units),correct_units),\nmsg,\nfeedback(msg);false)\n"}, {"name": "student_quantity", "description": "<p>This fixes the student answer for two common errors. &nbsp;</p>\n<p>If student_units are wrong&nbsp;&nbsp;- replace with correct units</p>\n<p>If student_scalar has the wrong sign - replace with right sign</p>\n<p>If student makes both errors, only one gets fixed.</p>", "definition": "switch(not good_units, \n       student_scalar * correct_units, \n       not right_sign,\n       -quantity(student_scalar, student_units),\n       quantity(student_scalar,student_units)\n)\n  \n"}, {"name": "percent_error", "description": "", "definition": "try(\nscalar(abs((correct_quantity - student_quantity)/correct_quantity))*100  \n,msg,\nif(student_quantity=correct_quantity,0,100))\n   "}, {"name": "right", "description": "", "definition": "percent_error <= settings['right']\n"}, {"name": "close", "description": "<p>Only marked close if the student actually has the right sign.</p>", "definition": "right_sign and percent_error <= settings['close']"}, {"name": "right_sign", "description": "", "definition": "sign(student_scalar) = sign(correct_quantity) "}], "settings": [{"name": "correctAnswer", "label": "Correct Quantity.", "help_url": "", "hint": "The correct answer given as a JME quantity.", "input_type": "code", "default_value": "", "evaluate": true}, {"name": "right", "label": "% Accuracy for right.", "help_url": "", "hint": "Question will be considered correct if the scalar part of the student's answer is within this % of correct value.", "input_type": "code", "default_value": "0.2", "evaluate": true}, {"name": "close", "label": "% Accuracy for close.", "help_url": "", "hint": "Question will be considered close if the scalar part of the student's answer is within this % of correct value.", "input_type": "code", "default_value": "1.0", "evaluate": true}, {"name": "C1", "label": "Close with units.", "help_url": "", "hint": "Partial Credit for close value with appropriate units. &nbsp;if correct answer is 100 N and close is &plusmn;1%,<br />99 &nbsp;N is accepted.", "input_type": "percent", "default_value": "75"}, {"name": "C2", "label": "No units or wrong sign", "help_url": "", "hint": "Partial credit for forgetting units or using wrong sign.<br />If the correct answer is 100 N, both 100 and -100 N are accepted.", "input_type": "percent", "default_value": "50"}, {"name": "C3", "label": "Close, no units.", "help_url": "", "hint": "Partial Credit for close value but forgotten units.<br />This value would be close&nbsp;if the expected units were provided. &nbsp;If the correct answer is 100 N, and close is &plusmn;1%,<br />99 is accepted.", "input_type": "percent", "default_value": "25"}], "public_availability": "always", "published": true, "extensions": ["quantities"]}], "resources": [], "navigation": {"allowregen": true, "showfrontpage": false, "preventleave": false, "typeendtoleave": false}, "contributors": [{"name": "William Haynes", "profile_url": "https://numbas.mathcentre.ac.uk/accounts/profile/2530/"}], "tags": ["2-D", "2-d", "Mechanics", "mechanics", "Moment", "moment", "Perpendicular distance", "perpendicular distance", "Statics", "statics"], "metadata": {"description": "<p>Determine the moment of a force about a point by using $M= F d_\\perp$ or $M = F_\\perp d$.</p>", "licence": "Creative Commons Attribution-NonCommercial 4.0 International"}, "statement": "<p>{applet}</p>\n<p><span data-jme-visible=\"version=0\">A $\\var{scalar(f)}$ lb force $\\mathbf{F}$ is applied to the control rod $AB$ as shown. Knowing that the length of the rod is $\\var{d}$ and that $\\alpha$ is {alpha}&deg;, determine the component&nbsp;of $\\mathbf{F}$&nbsp;perpendicular to rod $AB$<em>&nbsp;</em>and the magnitude of the moment produced.</span></p>\n<p></p>\n<p><span data-jme-visible=\"version=1\">A $\\var{scalar(f)}$ lb force $\\mathbf{F}$&nbsp;is applied to the control rod&nbsp;$AB$&nbsp;as shown. Knowing that the length of the rod is $\\var{d}$ and that $\\alpha$ is {alpha}&deg;, determine the perpendicular distance from the line of action of force $\\mathbf{F}$&nbsp;to point $B$<em>,&nbsp;</em>and&nbsp;the magnitude of the moment produced.</span></p>\n<p></p>\n<p><span data-jme-visible=\"version=2\">Force $\\mathbf{F}$&nbsp;is applied to the $\\var{d}$ long control rod&nbsp;$AB$&nbsp;at angle $\\alpha$ =&nbsp;{alpha}&deg; as shown. &nbsp;Knowing that it&nbsp;creates a {siground(scalar(M),4)} in lb {direction} moment about point <em>B</em>, determine the perpendicular distance from the line of action of force $\\mathbf{F}$&nbsp;to point $B$, and the magnitude of force $\\mathbf{F}$.</span></p>\n<p></p>\n<p><span data-jme-visible=\"version=3\">A {scalar(f)} lb force $\\mathbf{F}$ is applied to control rod&nbsp;$AB$&nbsp;at angle $\\alpha$ = {alpha}&deg; as shown. Knowing that it creates a {siground(scalar(M),4)} in lb {direction} moment about point&nbsp;$B$&nbsp;, determine the length of the control rod, and the component of $\\mathbf{F}$&nbsp;in a direction perpendicular to&nbsp;$AB$&nbsp;.</span></p>\n<p></p>\n<p><span data-jme-visible=\"version=4\">A {scalar(f)} lb force $\\mathbf{F}$&nbsp;is applied to the {scalar(d)}&nbsp;inch long control rod&nbsp;$AB$&nbsp;as shown. Knowing that it creates a {siground(scalar(M),4)} in lb {direction} moment about point&nbsp;$B$&nbsp;, determine angle $\\alpha$ and the perpendicular distance between the line of action of force $\\mathbf{F}$&nbsp;and point&nbsp;$B$&nbsp;.</span></p>\n<div data-jme-visible=\"debug\">\n<p>F: {F} D:{D} $\\alpha$: {alpha} $F_\\perp$: {fperp} $d_\\perp$: {dperp} M: {M}</p>\n</div>\n<p></p>\n<p></p>\n<p><strong></strong></p>", "advice": "<p>{advice}</p>\n<p><strong>Method 1</strong></p>\n<ol>\n<li>Draw the line of action of the force.</li>\n<li>Make a triangle including the perpendicular distance $d_\\perp.$</li>\n<li>Use geometry to find an angle in the triangle.</li>\n<li>Use trig to find the value of the perpendicular distance.</li>\n<li>Apply equation $M=F d_\\perp = F(d sin \\alpha) $ &nbsp;to solve for the unknown quantity.</li>\n</ol>\n<p><strong>Method 2</strong></p>\n<ol>\n<li>Use geometry to find the angle between the force and the control rod.</li>\n<li>Identify and solve for the component of force $F$&nbsp;perpendicular to the control rod, $F_\\perp$ &nbsp;.</li>\n<li>Apply equation $M = F_\\perp d = (F sin \\alpha) d $ to solve for the unknown quantity. &nbsp;</li>\n</ol>", "rulesets": {}, "builtin_constants": {"e": true, "pi,\u03c0": true, "i": true}, "constants": [], "variables": {"alpha'": {"name": "alpha'", "group": "Inputs", "definition": "random(-150..150#5 except [0,5,10,90,-5,-10,-90])", "description": "<p>angle of force with respect to the bar.</p>", "templateType": "anything", "can_override": false}, "Fperp": {"name": "Fperp", "group": "results", "definition": "M/D", "description": "<p>The perpendicular component of the force.</p>", "templateType": "anything", "can_override": false}, "version": {"name": "version", "group": "display", "definition": "random(0..4)", "description": "<p>which question version?</p>", "templateType": "anything", "can_override": false}, "direction": {"name": "direction", "group": "results", "definition": "if(alpha'<180,'clockwise','counterclockwise')", "description": "", "templateType": "anything", "can_override": false}, "Dperp": {"name": "Dperp", "group": "results", "definition": "M/F", "description": "<p>The perpendicular distance.</p>", "templateType": "anything", "can_override": false}, "F": {"name": "F", "group": "Inputs", "definition": "siground(qty(random(10..150)*random(0.1,0.5,1),'lb'),4)", "description": "<p>Magnitude of the force.</p>", "templateType": "anything", "can_override": false}, "debug": {"name": "debug", "group": "display", "definition": "false", "description": "", "templateType": "anything", "can_override": false}, "beta": {"name": "beta", "group": "display", "definition": "if(beta'>90,180-beta',beta')", "description": "", "templateType": "anything", "can_override": false}, "alpha": {"name": "alpha", "group": "display", "definition": "if(abs(alpha')>90,(180-abs(alpha')),abs(alpha'))", "description": "<p>Angle alpha as shown on the diagram, always less than 90&deg;.</p>", "templateType": "anything", "can_override": false}, "answers": {"name": "answers", "group": "display", "definition": "[['$F_\\\\perp$', Fperp ,  '$M$', M],\n\n['$d_\\\\perp$',  Dperp, '$M$', M ],\n\n['$d_\\\\perp$',Dperp, '$F$', F],\n\n['$\\\\ell$', D, '$F_\\\\perp$', Fperp],\n\n['$\\\\alpha$',qty(alpha,'deg'), '$d_\\\\perp$',Dperp]]\n", "description": "<p>labels, gap answer, and units</p>", "templateType": "anything", "can_override": false}, "beta'": {"name": "beta'", "group": "Inputs", "definition": "random(20..160#10 except 90)", "description": "<p>angle of bar from positive x axis</p>", "templateType": "anything", "can_override": false}, "M": {"name": "M", "group": "results", "definition": "siground(sin(radians(alpha)),5) * ( F * D )", "description": "<p>The magnitude of the moment</p>", "templateType": "anything", "can_override": false}, "D": {"name": "D", "group": "Inputs", "definition": "qty(random(6..30#2),'in')", "description": "<p>Length of the bar AB.</p>", "templateType": "anything", "can_override": false}, "applet": {"name": "applet", "group": "ggb", "definition": "geogebra_applet('tvby7hmg', params)", "description": "", "templateType": "anything", "can_override": false}, "params": {"name": "params", "group": "ggb", "definition": "['\u03b1\\'': radians(alpha'), '\u03b2\\'': radians(beta'), \nshow1: [visible: false], show2: [visible: false]]", "description": "", "templateType": "anything", "can_override": false}, "advice": {"name": "advice", "group": "ggb", "definition": "showAdvice(geogebra_applet('tvby7hmg', params))", "description": "", "templateType": "anything", "can_override": false}}, "variablesTest": {"condition": "", "maxRuns": 100}, "ungrouped_variables": [], "variable_groups": [{"name": "Inputs", "variables": ["beta'", "alpha'", "D", "F"]}, {"name": "results", "variables": ["M", "Fperp", "Dperp", "direction"]}, {"name": "display", "variables": ["alpha", "beta", "version", "answers", "debug"]}, {"name": "ggb", "variables": ["applet", "params", "advice"]}], "functions": {"showAdvice": {"parameters": [["app", "ggbapplet"]], "type": "anything", "language": "javascript", "definition": "// see https://wiki.geogebra.org/en/Reference:GeoGebra_Apps_API for other commands\n\napp.promise.then(function(d) {\n   d.app.setVisible('show1', true);\n   d.app.setVisible('show2', true);\n   d.app.setValue('show1', true);\n   d.app.setCaption('\u03b1', '$%v$');\n});\nreturn new Numbas.jme.types.ggbapplet(app);\n"}}, "preamble": {"js": "//question.signals.on('adviceDisplayed',function() {\n\n//try{\n//   var app = question.scope.variables.applet.app; \n//   app.setVisible('show1', true);\n//   app.setVisible('show2', true);\n//   app.setValue('show1', true);\n//   app.setCaption('\u03b1', '$%v$');\n//  }\n//  catch(err){}  \n//})\n\n\n", "css": ""}, "parts": [{"type": "gapfill", "useCustomName": true, "customName": "Answers", "marks": 0, "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": true, "showFeedbackIcon": true, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "prompt": "<p>{answers[version][0]} =&nbsp;[[0]] &nbsp;$\\qquad$&nbsp;{answers[version][2]} =&nbsp;[[1]]</p>\n<p></p>\n<p></p>\n<p><span data-jme-visible=\"debug\">{answers[version][1]}</span></p>\n<p><span data-jme-visible=\"debug\">{answers[version][3]}</span></p>", "gaps": [{"type": "engineering-answer", "useCustomName": false, "customName": "", "marks": "10", "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": true, "showFeedbackIcon": true, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "settings": {"correctAnswer": "answers[version][1]", "right": "0.2", "close": "1.0", "C1": "75", "C2": "50", "C3": "25"}}, {"type": "engineering-answer", "useCustomName": false, "customName": "", "marks": "10", "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": true, "showFeedbackIcon": true, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "settings": {"correctAnswer": "answers[version][3]", "right": "0.2", "close": "1.0", "C1": "75", "C2": "50", "C3": "25"}}], "sortAnswers": false}], "partsMode": "all", "maxMarks": 0, "objectives": [], "penalties": [], "objectiveVisibility": "always", "penaltyVisibility": "always", "type": "question"}, {"name": "Moment: Semicircle", "extensions": ["geogebra", "quantities"], "custom_part_types": [{"source": {"pk": 19, "author": {"name": "William Haynes", "pk": 2530}, "edit_page": "/part_type/19/edit"}, "name": "Engineering Accuracy with units", "short_name": "engineering-answer", "description": "<p>A value with units marked right if within an adjustable % error of the correct value. &nbsp;Marked close if within a wider margin of error.</p>", "help_url": "", "input_widget": "string", "input_options": {"correctAnswer": "siground(settings['correctAnswer'],4)", "hint": {"static": true, "value": ""}, "allowEmpty": {"static": true, "value": true}}, "can_be_gap": true, "can_be_step": true, "marking_script": "mark:\nswitch( \n  right and good_units and right_sign, add_credit(1.0,'Correct.'),\n  right and good_units and not right_sign, add_credit(settings['C2'],'Wrong sign.'),\n  right and right_sign and not good_units, add_credit(settings['C2'],'Correct value, but wrong or missing units.'),\n  close and good_units, add_credit(settings['C1'],'Close.'),\n  close and not good_units, add_credit(settings['C3'],'Answer is close, but wrong or missing units.'),\n  incorrect('Wrong answer.')\n)\n\n\ninterpreted_answer:\nqty(student_scalar, student_units)\n\n\n\ncorrect_quantity:\nsettings[\"correctAnswer\"]\n\n\n\ncorrect_units:\nunits(correct_quantity)\n\n\nallowed_notation_styles:\n[\"plain\",\"en\"]\n\nmatch_student_number:\nmatchnumber(studentAnswer,allowed_notation_styles)\n\nstudent_scalar:\nmatch_student_number[1]\n\nstudent_units:\nreplace_regex('ohms','ohm',\n  replace_regex('\u00b0', ' deg',\n    replace_regex('-', ' ' ,\n      studentAnswer[len(match_student_number[0])..len(studentAnswer)])),\"i\")\n\ngood_units:\ntry(\ncompatible(quantity(1, student_units),correct_units),\nmsg,\nfeedback(msg);false)\n\n\nstudent_quantity:\nswitch(not good_units, \n       student_scalar * correct_units, \n       not right_sign,\n       -quantity(student_scalar, student_units),\n       quantity(student_scalar,student_units)\n)\n  \n\n\npercent_error:\ntry(\nscalar(abs((correct_quantity - student_quantity)/correct_quantity))*100  \n,msg,\nif(student_quantity=correct_quantity,0,100))\n   \n\nright:\npercent_error <= settings['right']\n\n\nclose:\nright_sign and percent_error <= settings['close']\n\nright_sign:\nsign(student_scalar) = sign(correct_quantity)", "marking_notes": [{"name": "mark", "description": "This is the main marking note. It should award credit and provide feedback based on the student's answer.", "definition": "switch( \n  right and good_units and right_sign, add_credit(1.0,'Correct.'),\n  right and good_units and not right_sign, add_credit(settings['C2'],'Wrong sign.'),\n  right and right_sign and not good_units, add_credit(settings['C2'],'Correct value, but wrong or missing units.'),\n  close and good_units, add_credit(settings['C1'],'Close.'),\n  close and not good_units, add_credit(settings['C3'],'Answer is close, but wrong or missing units.'),\n  incorrect('Wrong answer.')\n)\n"}, {"name": "interpreted_answer", "description": "A value representing the student's answer to this part.", "definition": "qty(student_scalar, student_units)\n\n"}, {"name": "correct_quantity", "description": "", "definition": "settings[\"correctAnswer\"]\n\n"}, {"name": "correct_units", "description": "", "definition": "units(correct_quantity)\n"}, {"name": "allowed_notation_styles", "description": "", "definition": "[\"plain\",\"en\"]"}, {"name": "match_student_number", "description": "", "definition": "matchnumber(studentAnswer,allowed_notation_styles)"}, {"name": "student_scalar", "description": "", "definition": "match_student_number[1]"}, {"name": "student_units", "description": "<p>Modify&nbsp;the&nbsp;unit portion of&nbsp;the student's answer by</p>\n<p>1. replacing \"ohms\" with \"ohm\" &nbsp;case insensitive</p>\n<p>2.&nbsp;replacing '-'&nbsp;with ' '&nbsp;</p>\n<p>3. replacing '&deg;' with ' deg'&nbsp;</p>\n<p>to allow answers like 10 ft-lb and 30&deg;</p>", "definition": "replace_regex('ohms','ohm',\n  replace_regex('\u00b0', ' deg',\n    replace_regex('-', ' ' ,\n      studentAnswer[len(match_student_number[0])..len(studentAnswer)])),\"i\")"}, {"name": "good_units", "description": "", "definition": "try(\ncompatible(quantity(1, student_units),correct_units),\nmsg,\nfeedback(msg);false)\n"}, {"name": "student_quantity", "description": "<p>This fixes the student answer for two common errors. &nbsp;</p>\n<p>If student_units are wrong&nbsp;&nbsp;- replace with correct units</p>\n<p>If student_scalar has the wrong sign - replace with right sign</p>\n<p>If student makes both errors, only one gets fixed.</p>", "definition": "switch(not good_units, \n       student_scalar * correct_units, \n       not right_sign,\n       -quantity(student_scalar, student_units),\n       quantity(student_scalar,student_units)\n)\n  \n"}, {"name": "percent_error", "description": "", "definition": "try(\nscalar(abs((correct_quantity - student_quantity)/correct_quantity))*100  \n,msg,\nif(student_quantity=correct_quantity,0,100))\n   "}, {"name": "right", "description": "", "definition": "percent_error <= settings['right']\n"}, {"name": "close", "description": "<p>Only marked close if the student actually has the right sign.</p>", "definition": "right_sign and percent_error <= settings['close']"}, {"name": "right_sign", "description": "", "definition": "sign(student_scalar) = sign(correct_quantity) "}], "settings": [{"name": "correctAnswer", "label": "Correct Quantity.", "help_url": "", "hint": "The correct answer given as a JME quantity.", "input_type": "code", "default_value": "", "evaluate": true}, {"name": "right", "label": "% Accuracy for right.", "help_url": "", "hint": "Question will be considered correct if the scalar part of the student's answer is within this % of correct value.", "input_type": "code", "default_value": "0.2", "evaluate": true}, {"name": "close", "label": "% Accuracy for close.", "help_url": "", "hint": "Question will be considered close if the scalar part of the student's answer is within this % of correct value.", "input_type": "code", "default_value": "1.0", "evaluate": true}, {"name": "C1", "label": "Close with units.", "help_url": "", "hint": "Partial Credit for close value with appropriate units. &nbsp;if correct answer is 100 N and close is &plusmn;1%,<br />99 &nbsp;N is accepted.", "input_type": "percent", "default_value": "75"}, {"name": "C2", "label": "No units or wrong sign", "help_url": "", "hint": "Partial credit for forgetting units or using wrong sign.<br />If the correct answer is 100 N, both 100 and -100 N are accepted.", "input_type": "percent", "default_value": "50"}, {"name": "C3", "label": "Close, no units.", "help_url": "", "hint": "Partial Credit for close value but forgotten units.<br />This value would be close&nbsp;if the expected units were provided. &nbsp;If the correct answer is 100 N, and close is &plusmn;1%,<br />99 is accepted.", "input_type": "percent", "default_value": "25"}], "public_availability": "always", "published": true, "extensions": ["quantities"]}], "resources": [], "navigation": {"allowregen": true, "showfrontpage": false, "preventleave": false, "typeendtoleave": false}, "contributors": [{"name": "William Haynes", "profile_url": "https://numbas.mathcentre.ac.uk/accounts/profile/2530/"}], "tags": ["mechanics", "Mechanics", "moment", "Moment", "Statics", "statics"], "metadata": {"description": "<p>Calculate the&nbsp;moment of a force. &nbsp;Must calculate perpendicular distance based on simple geometry, and recognize direction.</p>", "licence": "Creative Commons Attribution-ShareAlike 4.0 International"}, "statement": "<p>{applet}</p>\n<p>A {qty(F,units[0])} force is applied semi circular object with a {qty(r, units[1])} radius, as shown.</p>\n<p></p>", "advice": "<p>Given: &nbsp;$r = \\var{qty(r,units[1])}, F = \\var{qty(F,units[0])}$</p>\n<p>$d_\\perp = r &nbsp;\\var{latex(if(alpha &lt; 0,\"-\",\"+\"))} r \\sin ( \\var{abs(alpha)}&deg;) = \\var{qty(siground(dperp,4),units[1])}$</p>\n<p>$M = F d_\\perp &nbsp;= (\\var{qty(F,units[0])})(\\var{qty(siground(dperp,4),units[1])}) = \\var{M}$</p>", "rulesets": {}, "builtin_constants": {"e": true, "pi,\u03c0": true, "i": true}, "constants": [], "variables": {"phi": {"name": "phi", "group": "Ungrouped variables", "definition": "random([0,180])", "description": "<p>angle force makes with horizontal</p>", "templateType": "anything", "can_override": false}, "alpha": {"name": "alpha", "group": "Ungrouped variables", "definition": "random(-40..40#10 except 0)", "description": "<p>angle diameter makes with horizontal</p>", "templateType": "anything", "can_override": false}, "units": {"name": "units", "group": "Ungrouped variables", "definition": "random(['N','cm', 'N*cm'],['lb','in','in*lb'], ['N','mm', 'N*mm'])", "description": "", "templateType": "anything", "can_override": false}, "F": {"name": "F", "group": "Ungrouped variables", "definition": "random(10..100#5)", "description": "", "templateType": "anything", "can_override": false}, "r": {"name": "r", "group": "Ungrouped variables", "definition": "random(10..50#5)", "description": "", "templateType": "anything", "can_override": false}, "dperp": {"name": "dperp", "group": "solution", "definition": "r + r sin(radians(alpha))", "description": "", "templateType": "anything", "can_override": false}, "M": {"name": "M", "group": "solution", "definition": "siground(qty(F dperp ,units[2]),4)", "description": "", "templateType": "anything", "can_override": false}, "applet": {"name": "applet", "group": "ggb", "definition": "geogebra_applet('jwzzemtp',params)", "description": "", "templateType": "anything", "can_override": false}, "params": {"name": "params", "group": "ggb", "definition": "[\nphi: [definition: radians(phi),visible: false], \nalpha:[definition: radians(alpha), visible: false],\nshow: [definition: 'false', visible: 0]\n]", "description": "", "templateType": "anything", "can_override": false}}, "variablesTest": {"condition": "", "maxRuns": 100}, "ungrouped_variables": ["phi", "alpha", "units", "F", "r"], "variable_groups": [{"name": "solution", "variables": ["dperp", "M"]}, {"name": "ggb", "variables": ["applet", "params"]}], "functions": {"evalCommand": {"parameters": [["app", "ggbapplet"], ["cmd", "string"]], "type": "anything", "language": "javascript", "definition": "// Take an applet, evaluate a ggb command\napp.promise.then(function(d) {\n  d.app.evalCommand(cmd);\n});\nreturn new Numbas.jme.types.ggbapplet(app);"}}, "preamble": {"js": "question.signals.on('adviceDisplayed',function() {\n  try{\n  var app =  question.scope.variables.applet.app;\n  \n  app.setValue(\"show\", true, false);\n  \n  }\n  catch(err){}  \n})\n\n", "css": ""}, "parts": [{"type": "gapfill", "useCustomName": false, "customName": "", "marks": 0, "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": true, "showFeedbackIcon": true, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "prompt": "<p>Determine the moment force&nbsp;$F$ makes about a point at the origin.</p>\n<p>$M =$&nbsp;[[0]]&nbsp;[[1]]</p>", "gaps": [{"type": "engineering-answer", "useCustomName": true, "customName": "Magnitude", "marks": "10", "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": true, "showFeedbackIcon": true, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "settings": {"correctAnswer": "M", "right": "0.2", "close": "1.0", "C1": "75", "C2": "50", "C3": "25"}}, {"type": "1_n_2", "useCustomName": true, "customName": "Direction", "marks": 0, "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": true, "showFeedbackIcon": true, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "minMarks": 0, "maxMarks": 0, "shuffleChoices": false, "displayType": "dropdownlist", "displayColumns": 0, "showCellAnswerState": true, "choices": ["CCW", "CW"], "matrix": ["if(phi=180,5,0)", "if(phi=0,5,0)"], "distractors": ["", ""]}], "sortAnswers": false}], "partsMode": "all", "maxMarks": 0, "objectives": [], "penalties": [], "objectiveVisibility": "always", "penaltyVisibility": "always", "type": "question"}, {"name": "Opposing moments using Verignon's theorem", "extensions": ["geogebra", "quantities"], "custom_part_types": [{"source": {"pk": 19, "author": {"name": "William Haynes", "pk": 2530}, "edit_page": "/part_type/19/edit"}, "name": "Engineering Accuracy with units", "short_name": "engineering-answer", "description": "<p>A value with units marked right if within an adjustable % error of the correct value. &nbsp;Marked close if within a wider margin of error.</p>", "help_url": "", "input_widget": "string", "input_options": {"correctAnswer": "siground(settings['correctAnswer'],4)", "hint": {"static": true, "value": ""}, "allowEmpty": {"static": true, "value": true}}, "can_be_gap": true, "can_be_step": true, "marking_script": "mark:\nswitch( \n  right and good_units and right_sign, add_credit(1.0,'Correct.'),\n  right and good_units and not right_sign, add_credit(settings['C2'],'Wrong sign.'),\n  right and right_sign and not good_units, add_credit(settings['C2'],'Correct value, but wrong or missing units.'),\n  close and good_units, add_credit(settings['C1'],'Close.'),\n  close and not good_units, add_credit(settings['C3'],'Answer is close, but wrong or missing units.'),\n  incorrect('Wrong answer.')\n)\n\n\ninterpreted_answer:\nqty(student_scalar, student_units)\n\n\n\ncorrect_quantity:\nsettings[\"correctAnswer\"]\n\n\n\ncorrect_units:\nunits(correct_quantity)\n\n\nallowed_notation_styles:\n[\"plain\",\"en\"]\n\nmatch_student_number:\nmatchnumber(studentAnswer,allowed_notation_styles)\n\nstudent_scalar:\nmatch_student_number[1]\n\nstudent_units:\nreplace_regex('ohms','ohm',\n  replace_regex('\u00b0', ' deg',\n    replace_regex('-', ' ' ,\n      studentAnswer[len(match_student_number[0])..len(studentAnswer)])),\"i\")\n\ngood_units:\ntry(\ncompatible(quantity(1, student_units),correct_units),\nmsg,\nfeedback(msg);false)\n\n\nstudent_quantity:\nswitch(not good_units, \n       student_scalar * correct_units, \n       not right_sign,\n       -quantity(student_scalar, student_units),\n       quantity(student_scalar,student_units)\n)\n  \n\n\npercent_error:\ntry(\nscalar(abs((correct_quantity - student_quantity)/correct_quantity))*100  \n,msg,\nif(student_quantity=correct_quantity,0,100))\n   \n\nright:\npercent_error <= settings['right']\n\n\nclose:\nright_sign and percent_error <= settings['close']\n\nright_sign:\nsign(student_scalar) = sign(correct_quantity)", "marking_notes": [{"name": "mark", "description": "This is the main marking note. It should award credit and provide feedback based on the student's answer.", "definition": "switch( \n  right and good_units and right_sign, add_credit(1.0,'Correct.'),\n  right and good_units and not right_sign, add_credit(settings['C2'],'Wrong sign.'),\n  right and right_sign and not good_units, add_credit(settings['C2'],'Correct value, but wrong or missing units.'),\n  close and good_units, add_credit(settings['C1'],'Close.'),\n  close and not good_units, add_credit(settings['C3'],'Answer is close, but wrong or missing units.'),\n  incorrect('Wrong answer.')\n)\n"}, {"name": "interpreted_answer", "description": "A value representing the student's answer to this part.", "definition": "qty(student_scalar, student_units)\n\n"}, {"name": "correct_quantity", "description": "", "definition": "settings[\"correctAnswer\"]\n\n"}, {"name": "correct_units", "description": "", "definition": "units(correct_quantity)\n"}, {"name": "allowed_notation_styles", "description": "", "definition": "[\"plain\",\"en\"]"}, {"name": "match_student_number", "description": "", "definition": "matchnumber(studentAnswer,allowed_notation_styles)"}, {"name": "student_scalar", "description": "", "definition": "match_student_number[1]"}, {"name": "student_units", "description": "<p>Modify&nbsp;the&nbsp;unit portion of&nbsp;the student's answer by</p>\n<p>1. replacing \"ohms\" with \"ohm\" &nbsp;case insensitive</p>\n<p>2.&nbsp;replacing '-'&nbsp;with ' '&nbsp;</p>\n<p>3. replacing '&deg;' with ' deg'&nbsp;</p>\n<p>to allow answers like 10 ft-lb and 30&deg;</p>", "definition": "replace_regex('ohms','ohm',\n  replace_regex('\u00b0', ' deg',\n    replace_regex('-', ' ' ,\n      studentAnswer[len(match_student_number[0])..len(studentAnswer)])),\"i\")"}, {"name": "good_units", "description": "", "definition": "try(\ncompatible(quantity(1, student_units),correct_units),\nmsg,\nfeedback(msg);false)\n"}, {"name": "student_quantity", "description": "<p>This fixes the student answer for two common errors. &nbsp;</p>\n<p>If student_units are wrong&nbsp;&nbsp;- replace with correct units</p>\n<p>If student_scalar has the wrong sign - replace with right sign</p>\n<p>If student makes both errors, only one gets fixed.</p>", "definition": "switch(not good_units, \n       student_scalar * correct_units, \n       not right_sign,\n       -quantity(student_scalar, student_units),\n       quantity(student_scalar,student_units)\n)\n  \n"}, {"name": "percent_error", "description": "", "definition": "try(\nscalar(abs((correct_quantity - student_quantity)/correct_quantity))*100  \n,msg,\nif(student_quantity=correct_quantity,0,100))\n   "}, {"name": "right", "description": "", "definition": "percent_error <= settings['right']\n"}, {"name": "close", "description": "<p>Only marked close if the student actually has the right sign.</p>", "definition": "right_sign and percent_error <= settings['close']"}, {"name": "right_sign", "description": "", "definition": "sign(student_scalar) = sign(correct_quantity) "}], "settings": [{"name": "correctAnswer", "label": "Correct Quantity.", "help_url": "", "hint": "The correct answer given as a JME quantity.", "input_type": "code", "default_value": "", "evaluate": true}, {"name": "right", "label": "% Accuracy for right.", "help_url": "", "hint": "Question will be considered correct if the scalar part of the student's answer is within this % of correct value.", "input_type": "code", "default_value": "0.2", "evaluate": true}, {"name": "close", "label": "% Accuracy for close.", "help_url": "", "hint": "Question will be considered close if the scalar part of the student's answer is within this % of correct value.", "input_type": "code", "default_value": "1.0", "evaluate": true}, {"name": "C1", "label": "Close with units.", "help_url": "", "hint": "Partial Credit for close value with appropriate units. &nbsp;if correct answer is 100 N and close is &plusmn;1%,<br />99 &nbsp;N is accepted.", "input_type": "percent", "default_value": "75"}, {"name": "C2", "label": "No units or wrong sign", "help_url": "", "hint": "Partial credit for forgetting units or using wrong sign.<br />If the correct answer is 100 N, both 100 and -100 N are accepted.", "input_type": "percent", "default_value": "50"}, {"name": "C3", "label": "Close, no units.", "help_url": "", "hint": "Partial Credit for close value but forgotten units.<br />This value would be close&nbsp;if the expected units were provided. &nbsp;If the correct answer is 100 N, and close is &plusmn;1%,<br />99 is accepted.", "input_type": "percent", "default_value": "25"}], "public_availability": "always", "published": true, "extensions": ["quantities"]}], "resources": [], "navigation": {"allowregen": true, "showfrontpage": false, "preventleave": false, "typeendtoleave": false}, "contributors": [{"name": "William Haynes", "profile_url": "https://numbas.mathcentre.ac.uk/accounts/profile/2530/"}], "tags": ["equilibrium", "Equilibrium", "mechanics", "Mechanics", "moments", "Moments", "statics", "Statics"], "metadata": {"description": "<p>Find the tension in a rope necessary to prevent a bracket from rotating&nbsp;by applying $\\Sigma M = 0$.</p>", "licence": "Creative Commons Attribution-NonCommercial 4.0 International"}, "statement": "<p><strong></strong>An&nbsp;<strong>L</strong> shaped bracket is supported by a frictionless pin&nbsp;at $A$ and a cable between&nbsp;points $B$ and $D$.&nbsp;</p>\n<p>{applet}</p>\n<p>Determine the tension in the cable required for equilibrium when a&nbsp;{F}&nbsp;force $\\mathbf{F}$ is applied to&nbsp;the bracket as shown.</p>", "advice": "<p>Since the object is in equilibrium $\\Sigma M_A = 0$ implies that the opposing moments must have equal magnitudes. &nbsp;This is the principle we use to solve the problem. At the start we know the magnitude of $\\mathbf{F}$ and the geometry of the system.</p>\n<p>1. Begin by drawing a sketch, defining your symbols and determining geometric values. &nbsp;</p>\n<p style=\"padding-left: 30px;\">Let $\\alpha$ be the angle force $\\mathbf{F}$ makes with the horizontal and $\\beta$ be the angle the cable makes with the horizontal.</p>\n<p style=\"padding-left: 60px;\">$\\alpha = \\var{abs(alpha)}&deg;$, &nbsp;&nbsp;$\\beta = \\var{siground(if(abs(beta)&gt;90, 180-abs(beta), abs(beta)),4)}&deg;$</p>\n<p style=\"padding-left: 30px;\">Let $d_x$ and $d_y$ represent the horizontal and vertical distances from $A$ to $B$.</p>\n<p style=\"padding-left: 60px;\">$d_x = \\var{d_x}$, &nbsp;&nbsp;$d_y = \\var{d_y}$ &nbsp;</p>\n<p>2. Develop expressions for the moments about point $A$ caused by the force $\\mathbf{F}$ and the cable. The moment caused by the force can be found completely, but the moment caused by the cable tension can only be expressed as a function of the unknown tension $T$.</p>\n<p></p>\n<p style=\"padding-left: 60px;\">$M_F =&nbsp;F_y \\cdot d_x =&nbsp;&nbsp;F \\sin \\alpha \\cdot d_x $</p>\n<p style=\"padding-left: 60px;\">$M_T = T_x \\cdot d_y \\pm T_y \\cdot d_x = &nbsp; (T \\cos \\beta) \\,&nbsp;d_y \\pm (T \\sin \\beta)&nbsp;\\, d_x = &nbsp;&nbsp;T (\\var{scalar(d_y)} \\cos \\beta &nbsp; \\pm \\var{scalar(d_x)} \\sin \\beta) $</p>\n<p style=\"padding-left: 30px;\">When calculating the moment due to the cable $M_T$, if the two component moments act in the same direction, add the terms. &nbsp;If they twist in opposite directions, take their difference. &nbsp;Either way, make the final result positive, because we're comparing magnitudes.</p>\n<p>3. After substituting the known values and simplifying, equate the moments to&nbsp;get:</p>\n<p style=\"padding-left: 30px;\">$M_T = M_F$</p>\n<p style=\"padding-left: 30px;\">$ T (\\var{format(d_perp_t)}) = \\var{format(M_F)} $</p>\n<p style=\"padding-left: 30px;\">$T = \\dfrac{\\var{format(M_F)}}{\\var{format(d_perp_t)}}= \\var{format(T)} $</p>\n<p style=\"padding-left: 30px;\"></p>", "rulesets": {}, "builtin_constants": {"e": true, "pi,\u03c0": true, "i": true}, "constants": [], "variables": {"d_x": {"name": "d_x", "group": "Outputs", "definition": "qty(abs(A[0]-B[0]),units[0])", "description": "", "templateType": "anything", "can_override": false}, "T_hat": {"name": "T_hat", "group": "Outputs", "definition": "vector(run,rise,0)/abs(vector(rise,run,0))", "description": "", "templateType": "anything", "can_override": false}, "B": {"name": "B", "group": "Inputs", "definition": "vector(random(1,-1) random(5..12),random(1,-1) random(4..10))", "description": "<p>Position of point B</p>", "templateType": "anything", "can_override": false}, "F_y": {"name": "F_y", "group": "Outputs", "definition": "F sin(radians(alpha))", "description": "", "templateType": "anything", "can_override": false}, "A": {"name": "A", "group": "Inputs", "definition": "vector(0,0)", "description": "<p>Position of point A</p>", "templateType": "anything", "can_override": false}, "d_perp_t": {"name": "d_perp_t", "group": "Outputs", "definition": "qty(abs(cross(T_hat,r_ad)[2]),units[0])", "description": "", "templateType": "anything", "can_override": false}, "T": {"name": "T", "group": "Ungrouped variables", "definition": "M_F/d_perp_t", "description": "", "templateType": "anything", "can_override": false}, "F": {"name": "F", "group": "Inputs", "definition": "qty(random(10..100#5),units[1])", "description": "<p>Magnitude of force A</p>", "templateType": "anything", "can_override": false}, "F_hat": {"name": "F_hat", "group": "Outputs", "definition": "( vector(cos(radians(alpha)),sin(radians(alpha)),0))", "description": "<p>force A&nbsp;as a vector</p>", "templateType": "anything", "can_override": false}, "units": {"name": "units", "group": "Inputs", "definition": "random(['ft','lb'],['in','lb'],['cm','N'])", "description": "", "templateType": "anything", "can_override": false}, "beta": {"name": "beta", "group": "Outputs", "definition": "siground(degrees(atan2(rise,run)),6)", "description": "", "templateType": "anything", "can_override": false}, "run": {"name": "run", "group": "Outputs", "definition": "d[0]-b[0]", "description": "", "templateType": "anything", "can_override": false}, "d_y": {"name": "d_y", "group": "Outputs", "definition": "qty(abs(A[1]-B[1]),units[0])", "description": "", "templateType": "anything", "can_override": false}, "M_F": {"name": "M_F", "group": "Outputs", "definition": "siground(abs(F_y) d_AB,5)", "description": "", "templateType": "anything", "can_override": false}, "d_AB": {"name": "d_AB", "group": "Outputs", "definition": "qty(abs(B[0]),units[0])", "description": "", "templateType": "anything", "can_override": false}, "alpha": {"name": "alpha", "group": "Inputs", "definition": "random(-80..80#10 except 0)", "description": "<p>direction of force A</p>", "templateType": "anything", "can_override": false}, "rise": {"name": "rise", "group": "Outputs", "definition": "d[1]-b[1]", "description": "", "templateType": "anything", "can_override": false}, "debug": {"name": "debug", "group": "Inputs", "definition": "false", "description": "", "templateType": "anything", "can_override": false}, "r_ad": {"name": "r_ad", "group": "Outputs", "definition": "D-A + vector(0,0,0)", "description": "", "templateType": "anything", "can_override": false}, "D": {"name": "D", "group": "Inputs", "definition": "B + vector(random(1,-1)random(2..5),random(1,-1)random(2..5))", "description": "<p>Position of point C</p>", "templateType": "anything", "can_override": false}, "applet": {"name": "applet", "group": "Ungrouped variables", "definition": "geogebra_applet('phznbxbe', params)", "description": "", "templateType": "anything", "can_override": false}, "params": {"name": "params", "group": "Ungrouped variables", "definition": "[A: A, B: B, D: D, \n'\u03b1': radians(alpha), \nunit: '\"{units[0]}\"'\n]", "description": "", "templateType": "anything", "can_override": false}}, "variablesTest": {"condition": "B[0]<>D[0] and B[1]<>D[1] and \nA[0]<>D[0] and A[1]<>D[1] and \nabs(rise) <> abs(run)", "maxRuns": 100}, "ungrouped_variables": ["T", "applet", "params"], "variable_groups": [{"name": "Inputs", "variables": ["A", "B", "D", "alpha", "F", "units", "debug"]}, {"name": "Outputs", "variables": ["F_hat", "F_y", "d_AB", "M_F", "beta", "rise", "run", "T_hat", "r_ad", "d_perp_t", "d_x", "d_y"]}], "functions": {"format": {"parameters": [["q", "quantity"]], "type": "quantity", "language": "jme", "definition": "string(siground(q,4))"}}, "preamble": {"js": "", "css": ""}, "parts": [{"type": "gapfill", "useCustomName": true, "customName": "Find Moment", "marks": 0, "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": true, "showFeedbackIcon": true, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "prompt": "<p>Determine the magnitude of the moment that&nbsp;the force $\\mathbf{F}$ produces about point $A$.</p>\n<p>$M_F =$&nbsp;[[0]] <span data-jme-visible=\"debug\">{M_F}</span></p>", "gaps": [{"type": "engineering-answer", "useCustomName": true, "customName": "M_F", "marks": "10", "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": true, "showFeedbackIcon": true, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "settings": {"correctAnswer": "M_F", "right": "0.2", "close": "1.0", "C1": "75", "C2": "50", "C3": "25"}}], "sortAnswers": false}, {"type": "gapfill", "useCustomName": true, "customName": "Find Tension", "marks": 0, "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": true, "showFeedbackIcon": true, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "prompt": "<p>Determine the tension required to hold the bracket in position.</p>\n<p>$T$ =&nbsp;[[0]] <span data-jme-visible=\"debug\">{format(T)}</span></p>", "gaps": [{"type": "engineering-answer", "useCustomName": true, "customName": "T", "marks": "10", "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": true, "showFeedbackIcon": true, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "settings": {"correctAnswer": "T", "right": "0.2", "close": "1.0", "C1": "75", "C2": "50", "C3": "25"}}], "sortAnswers": false}], "partsMode": "all", "maxMarks": 0, "objectives": [], "penalties": [], "objectiveVisibility": "always", "penaltyVisibility": "always", "type": "question"}, {"name": "Moment Balance", "extensions": ["geogebra", "quantities"], "custom_part_types": [{"source": {"pk": 12, "author": {"name": "William Haynes", "pk": 2530}, "edit_page": "/part_type/12/edit"}, "name": "Angle quantity 2020", "short_name": "angle", "description": "<p>Adjusts all angles to 0 &lt; $\\theta$ &lt; 360.</p>\n<p>Accepts '&deg;' and 'deg' as units.</p>\n<p>Penalizes if not close enough or no units.</p>\n<p>90&deg; = -270&deg; = 450&deg;</p>", "help_url": "", "input_widget": "string", "input_options": {"correctAnswer": "plain_string(settings['expected_answer']) ", "hint": {"static": true, "value": ""}, "allowEmpty": {"static": true, "value": false}}, "can_be_gap": true, "can_be_step": true, "marking_script": "original_student_scalar:\nmatchnumber(studentAnswer,['plain','en'])[1]\n\nstudent_scalar:\nmod(original_student_scalar,360)\n\n\nstudent_unit:\nstudentAnswer[len(matchnumber(studentAnswer,['plain','en'])[0])..len(studentAnswer)]\n\ninterpreted_unit:\nif(trim(student_unit)='\u00b0','deg',student_unit)\n\ninterpreted_answer:\nqty(mod(student_scalar,360),'deg')\n\nclose:\nwithintolerance(student_scalar, correct_scalar,decimal(settings['close_tol']))\n\ncorrect_scalar:\nmod(scalar(settings['expected_answer']),360)\n\nright:\nwithintolerance(student_scalar, correct_scalar, decimal(settings['right_tol']))\n\ngood_unit:\nsame(qty(1,interpreted_unit),qty(1,'deg'))\n\nmark:\nassert(close,incorrect('Incorrect.');end());\nif(right,correct('Correct angle.'), set_credit(1 - settings['close_penalty'],'Angle is close.'));\nassert(good_unit,sub_credit(settings['unit_penalty'], 'Missing or incorrect units.'))", "marking_notes": [{"name": "original_student_scalar", "description": "<p>Retuns the scalar part of students answer (which is a quantity) as a number.</p>", "definition": "matchnumber(studentAnswer,['plain','en'])[1]"}, {"name": "student_scalar", "description": "<p>Normalize angle with mod 360</p>", "definition": "mod(original_student_scalar,360)\n"}, {"name": "student_unit", "description": "<p>matchnumber(studentAnswer,['plain','en'])[0] is a string \"12.34\"</p>", "definition": "studentAnswer[len(matchnumber(studentAnswer,['plain','en'])[0])..len(studentAnswer)]"}, {"name": "interpreted_unit", "description": "<p>Allows student to use degree symbol or 'deg' for units.</p>", "definition": "if(trim(student_unit)='\u00b0','deg',student_unit)"}, {"name": "interpreted_answer", "description": "A value representing the student's answer to this part.", "definition": "qty(mod(student_scalar,360),'deg')"}, {"name": "close", "description": "", "definition": "withintolerance(student_scalar, correct_scalar,decimal(settings['close_tol']))"}, {"name": "correct_scalar", "description": "<p>Normalize expected_answer with mod 360</p>", "definition": "mod(scalar(settings['expected_answer']),360)"}, {"name": "right", "description": "", "definition": "withintolerance(student_scalar, correct_scalar, decimal(settings['right_tol']))"}, {"name": "good_unit", "description": "", "definition": "same(qty(1,interpreted_unit),qty(1,'deg'))"}, {"name": "mark", "description": "This is the main marking note. It should award credit and provide feedback based on the student's answer.", "definition": "assert(close,incorrect('Incorrect.');end());\nif(right,correct('Correct angle.'), set_credit(1 - settings['close_penalty'],'Angle is close.'));\nassert(good_unit,sub_credit(settings['unit_penalty'], 'Missing or incorrect units.'))"}], "settings": [{"name": "expected_answer", "label": "Expected Answer", "help_url": "", "hint": "Expected angle as a quantity.", "input_type": "code", "default_value": "qty(30,'deg')", "evaluate": true}, {"name": "unit_penalty", "label": "Unit penalty", "help_url": "", "hint": "Penalty for not including degree sign or 'deg'.", "input_type": "percent", "default_value": "20"}, {"name": "close_penalty", "label": "Close Penalty", "help_url": "", "hint": "Penalty for close answer.", "input_type": "percent", "default_value": "20"}, {"name": "close_tol", "label": "Close", "help_url": "", "hint": "Angle must be $\\pm$ this many degrees to be marked close. &nbsp;&nbsp;", "input_type": "code", "default_value": "0.5", "evaluate": false}, {"name": "right_tol", "label": "Right ", "help_url": "", "hint": "Angle must be $\\pm$ this many degrees to be marked correct. &nbsp;", "input_type": "code", "default_value": "0.1", "evaluate": false}], "public_availability": "restricted", "published": false, "extensions": ["quantities"]}], "resources": [], "navigation": {"allowregen": true, "showfrontpage": false, "preventleave": false, "typeendtoleave": false}, "contributors": [{"name": "William Haynes", "profile_url": "https://numbas.mathcentre.ac.uk/accounts/profile/2530/"}], "tags": ["eqilibrium", "Mechanics", "mechanics", "Moments", "moments", "Statics", "statics"], "metadata": {"description": "<p>Two known forces, and a third with known magnitude act on a rigid body. &nbsp;Apply $\\Sigma M = 0$ about a pin restraint to determine the direction of the third force. &nbsp;The problem has two valid answers.</p>", "licence": "Creative Commons Attribution-NonCommercial 4.0 International"}, "statement": "<p>{applet}</p>\n<p>Three forces, $A = \\var{A F_units}$, $C = \\var{C F_units}$ and $D = \\var{F F_units}$, act on the rigid, bent bar which can pivot freely on a pin at $B$.</p>\n<p>The segment lengths are: $AB = \\var{ab D_units}$, $BC = \\var{bc D_units}$, and $CD= \\var{cd D_units}$.</p>", "advice": "<p>From the geometry of triangle $BCD$:</p>\n<p style=\"padding-left: 40px;\">$\\phi = \\tan^{-1}\\left( \\dfrac{BC}{CD}\\right) =\\var{precround(phi,1)}&deg;$<br/><br/>$d = \\sqrt{BC^2 +CD^2} &nbsp;= \\var{siground(abs(r_d),4) D_units}$</p>\n<p>From a moment balance around point $B$, the clockwise moment equals the counterclockwise moments:</p>\n<p style=\"padding-left: 40px;\">$\\begin{align}<br/>M_D &amp;= M_A + M_C \\\\<br/>&nbsp;&amp;= (\\var{AB})\\ A_y + (\\var{BC})\\ C_x\\\\<br/>&amp;= \\simplify[!collectNumbers]{({siground(M_A[2],4)} +{siground(M_C[2],4)})}\\\\<br/>&amp;= \\var{siground(-M D_units F_units,4)} \\text{ clockwise}<br/>\\end{align}$</p>\n<p>With the required moment $M_D$ and the magnitude of force $D$ known, the perpendicular distance and the angle between segment $BD$ and force $D$ are:</p>\n<p style=\"padding-left: 40px;\">$d_\\perp = M_D / D &nbsp;= \\dfrac{ \\var{siground(-M D_units F_units,4)}}{\\var{F F_units}} = \\var{siground(dperp,4) D_units}$<br/><br/>$\\alpha =\\sin^{-1}\\left( \\dfrac{d_\\perp}{d}\\right)=\\var{precround(alpha1,1)}&deg;$</p>\n<p>Since $\\sin \\alpha = \\sin (180&deg;-\\alpha)$ another possible angle is:</p>\n<p style=\"padding-left: 40px;\">$\\alpha' = (180&deg; - \\var{precround(alpha1,1)}) = \\var{precround(alpha2,1)}&deg;$</p>\n<p>Finally the angle from the positive $x$ axis to force $D$ can be determined. &nbsp;There are two possible solutions:</p>\n<p style=\"padding-left: 40px;\">$\\theta =180&deg; - \\alpha - \\phi = \\var{precround(-theta1,1)}&deg; $ or <br/>$\\theta = 180 - \\alpha' - \\phi = \\var{precround(-theta2,1)}$</p>\n<p>Note:<em> You can use the red slider on the diagram to switch between the two possible solutions.</em></p>", "rulesets": {}, "builtin_constants": {"e": true, "pi,\u03c0": true, "i": true}, "constants": [], "variables": {"applet": {"name": "applet", "group": "inputs", "definition": "geogebra_applet('qavc8kmn',params)", "description": "", "templateType": "anything", "can_override": false}, "params": {"name": "params", "group": "inputs", "definition": "[ ab: ab, bc: bc, cd: cd, \n  theta_A: radians(theta_A), theta_C: radians(theta_C), theta: radians(-40),\n  fbd: [visible: false, definition: \"false\"],\n  soln: [visible: false]\n ]", "description": "<p>Paramiters for applet</p>", "templateType": "anything", "can_override": false}, "ab": {"name": "ab", "group": "inputs", "definition": "random(1..3#0.25)", "description": "<p>Length of segment AB</p>", "templateType": "anything", "can_override": false}, "bc": {"name": "bc", "group": "inputs", "definition": "random(1..2#0.25)", "description": "<p>Length of segment BC</p>", "templateType": "anything", "can_override": false}, "cd": {"name": "cd", "group": "inputs", "definition": "random(1..3#0.25)", "description": "<p>Length of segment CD</p>", "templateType": "anything", "can_override": false}, "D_units": {"name": "D_units", "group": "inputs", "definition": "qty('ft')", "description": "", "templateType": "anything", "can_override": false}, "theta_C": {"name": "theta_C", "group": "inputs", "definition": "random(110..250#10 except 180)", "description": "<p>Angle of force C, chosen to make a CCW moment</p>", "templateType": "anything", "can_override": false}, "theta_A": {"name": "theta_A", "group": "inputs", "definition": "random(195..345#15)", "description": "<p>Angle of force A, chosen to make a CCW moment</p>", "templateType": "anything", "can_override": false}, "A": {"name": "A", "group": "inputs", "definition": "random(25..250#25)", "description": "<p>Magnitude of force A</p>", "templateType": "anything", "can_override": false}, "C": {"name": "C", "group": "inputs", "definition": "random(25..200#25)", "description": "<p>magnitude of force C</p>", "templateType": "anything", "can_override": false}, "r_a": {"name": "r_a", "group": "solution", "definition": "vector(-ab,0,0)", "description": "<p>positon vector</p>", "templateType": "anything", "can_override": false}, "r_c": {"name": "r_c", "group": "solution", "definition": "vector(0,bc,0)", "description": "<p>position vector</p>", "templateType": "anything", "can_override": false}, "r_d": {"name": "r_d", "group": "solution", "definition": "vector(cd,bc,0)", "description": "<p>position vector</p>", "templateType": "anything", "can_override": false}, "f_a": {"name": "f_a", "group": "solution", "definition": "A vector(cos(radians(theta_a)),sin(radians(theta_a)),0)", "description": "<p>force vector</p>", "templateType": "anything", "can_override": false}, "f_c": {"name": "f_c", "group": "solution", "definition": "C vector(cos(radians(theta_C)),sin(radians(theta_c)),0)", "description": "<p>force vector</p>", "templateType": "anything", "can_override": false}, "M_A": {"name": "M_A", "group": "solution", "definition": "cross(r_a,f_a)", "description": "<p>Moment vector</p>", "templateType": "anything", "can_override": false}, "M_C": {"name": "M_C", "group": "solution", "definition": "cross(r_C, f_C)", "description": "<p>Moment vector</p>", "templateType": "anything", "can_override": false}, "M_D": {"name": "M_D", "group": "solution", "definition": "-(M_A+M_C)", "description": "<p>Moment vector needed for equilibrium</p>", "templateType": "anything", "can_override": false}, "F": {"name": "F", "group": "inputs", "definition": "random(25..200#20)", "description": "<p>Magnitude of force D</p>", "templateType": "anything", "can_override": false}, "F_min": {"name": "F_min", "group": "method 1", "definition": "cross(M_D,r_d)/(abs(r_d)^2)", "description": "<p>Solve for force F, which is the minimum force required, i.e. the force perpendicuar to the moment arm.</p>", "templateType": "anything", "can_override": false}, "f_perp": {"name": "f_perp", "group": "method 1", "definition": "abs(F_min)", "description": "<p>Minimum magnitude of F, also the perpendicular component of force D</p>", "templateType": "anything", "can_override": false}, "alpha1": {"name": "alpha1", "group": "method 1", "definition": " degrees(abs(arcsin(f_perp/F)))", "description": "", "templateType": "anything", "can_override": false}, "phi": {"name": "phi", "group": "method 1", "definition": "degrees(arctan(r_d[1]/r_d[0]))", "description": "", "templateType": "anything", "can_override": false}, "dperp": {"name": "dperp", "group": "method 1", "definition": "abs(M/F)", "description": "<p>perpendicular distance</p>", "templateType": "anything", "can_override": false}, "M": {"name": "M", "group": "solution", "definition": "M_D[2]", "description": "<p>scalar component of M_D</p>", "templateType": "anything", "can_override": false}, "theta1": {"name": "theta1", "group": "method 1", "definition": "-(180-phi-alpha1)", "description": "", "templateType": "anything", "can_override": false}, "f_units": {"name": "f_units", "group": "inputs", "definition": "qty(\"lb\")", "description": "", "templateType": "anything", "can_override": false}, "alpha2": {"name": "alpha2", "group": "method 1", "definition": "180-alpha1", "description": "", "templateType": "anything", "can_override": false}, "theta2": {"name": "theta2", "group": "method 1", "definition": "-(180-phi-alpha2)", "description": "", "templateType": "anything", "can_override": false}}, "variablesTest": {"condition": "0.3 < sin(radians(alpha1)) < 0.95 and alpha1 < 180 - phi -20//  for diagram to show alpha in the triangle\nand dperp < abs(r_d)", "maxRuns": 100}, "ungrouped_variables": [], "variable_groups": [{"name": "solution", "variables": ["r_a", "r_c", "r_d", "f_a", "f_c", "M_A", "M_C", "M_D", "M"]}, {"name": "method 1", "variables": ["F_min", "f_perp", "dperp", "alpha1", "alpha2", "phi", "theta1", "theta2"]}, {"name": "inputs", "variables": ["applet", "params", "ab", "bc", "cd", "theta_A", "theta_C", "f_units", "D_units", "A", "C", "F"]}], "functions": {"hide_items": {"parameters": [["app", "ggbapplet"]], "type": "anything", "language": "javascript", "definition": "// See https://wiki.geogebra.org/en/Scripting_Commands and\n// https://wiki.geogebra.org/en/Reference:GeoGebra_Apps_API\nreturn;\napp.promise.then(function(d) {\n  d.app.setVisible('LOA', false);\n  d.app.setVisible('ref', false);\n  d.app.setVisible('t1', false);\n  d.app.setVisible('alpha', false);\n  d.app.setVisible('phi', false);\n});\nreturn new Numbas.jme.types.ggbapplet(app);\n"}}, "preamble": {"js": "question.signals.on('adviceDisplayed',function() {\n  \n  try{\n    //var app = question.applet.app;\n    var app = Numbas.exam.currentQuestion.scope.variables.applet.app;\n    var theta = - Numbas.exam.currentQuestion.scope.variables.theta1.value;\n    console.log(theta);\n    app.setVisible(\"fbd\",true);\n    app.setValue(\"fbd\",true);\n    app.setVisible(\"soln\",true);\n    app.setValue(\"soln\",1);\n    app.setValue(\"theta\", -theta * 3.14 /180 );\n    app.setLabelVisible(\"A\",false);\n    app.setLabelVisible(\"B\",false);\n    app.setLabelVisible(\"C\",false);\n    app.setLabelVisible(\"D\",false);\n  }\n  catch(err){}  \n})\n", "css": ""}, "parts": [{"type": "gapfill", "useCustomName": false, "customName": "", "marks": 0, "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": true, "showFeedbackIcon": true, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "prompt": "<p>Find an angle $\\theta$ that will make the sum of the moments about point $B=0$.</p>\n<p>$\\theta = $ [[0]]&nbsp; (Measure $\\theta$ CW from the positive $x$ axis.)</p>", "gaps": [{"type": "angle", "useCustomName": true, "customName": "$\\theta$", "marks": "20", "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": true, "showFeedbackIcon": true, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "alternatives": [{"type": "angle", "useCustomName": true, "customName": "$\\theta'$", "marks": "20", "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "alternativeFeedbackMessage": "", "useAlternativeFeedback": false, "settings": {"expected_answer": "precround(qty(-theta2,'deg'),2)", "unit_penalty": "20", "close_penalty": "20", "close_tol": "0.5", "right_tol": "0.1"}}], "settings": {"expected_answer": "precround(qty(-theta1,'deg'),2)", "unit_penalty": "20", "close_penalty": "20", "close_tol": "0.5", "right_tol": "0.1"}}], "sortAnswers": false}], "partsMode": "all", "maxMarks": 0, "objectives": [], "penalties": [], "objectiveVisibility": "always", "penaltyVisibility": "always", "type": "question"}]}, {"name": "Couples", "pickingStrategy": "all-ordered", "pickQuestions": 1, "questionNames": ["", "Resultant couple", ""], "variable_overrides": [[], [], []], "questions": [{"name": "Moment of a couple", "extensions": ["geogebra", "quantities"], "custom_part_types": [{"source": {"pk": 19, "author": {"name": "William Haynes", "pk": 2530}, "edit_page": "/part_type/19/edit"}, "name": "Engineering Accuracy with units", "short_name": "engineering-answer", "description": "<p>A value with units marked right if within an adjustable % error of the correct value. &nbsp;Marked close if within a wider margin of error.</p>", "help_url": "", "input_widget": "string", "input_options": {"correctAnswer": "siground(settings['correctAnswer'],4)", "hint": {"static": true, "value": ""}, "allowEmpty": {"static": true, "value": true}}, "can_be_gap": true, "can_be_step": true, "marking_script": "mark:\nswitch( \n  right and good_units and right_sign, add_credit(1.0,'Correct.'),\n  right and good_units and not right_sign, add_credit(settings['C2'],'Wrong sign.'),\n  right and right_sign and not good_units, add_credit(settings['C2'],'Correct value, but wrong or missing units.'),\n  close and good_units, add_credit(settings['C1'],'Close.'),\n  close and not good_units, add_credit(settings['C3'],'Answer is close, but wrong or missing units.'),\n  incorrect('Wrong answer.')\n)\n\n\ninterpreted_answer:\nqty(student_scalar, student_units)\n\n\n\ncorrect_quantity:\nsettings[\"correctAnswer\"]\n\n\n\ncorrect_units:\nunits(correct_quantity)\n\n\nallowed_notation_styles:\n[\"plain\",\"en\"]\n\nmatch_student_number:\nmatchnumber(studentAnswer,allowed_notation_styles)\n\nstudent_scalar:\nmatch_student_number[1]\n\nstudent_units:\nreplace_regex('ohms','ohm',\n  replace_regex('\u00b0', ' deg',\n    replace_regex('-', ' ' ,\n      studentAnswer[len(match_student_number[0])..len(studentAnswer)])),\"i\")\n\ngood_units:\ntry(\ncompatible(quantity(1, student_units),correct_units),\nmsg,\nfeedback(msg);false)\n\n\nstudent_quantity:\nswitch(not good_units, \n       student_scalar * correct_units, \n       not right_sign,\n       -quantity(student_scalar, student_units),\n       quantity(student_scalar,student_units)\n)\n  \n\n\npercent_error:\ntry(\nscalar(abs((correct_quantity - student_quantity)/correct_quantity))*100  \n,msg,\nif(student_quantity=correct_quantity,0,100))\n   \n\nright:\npercent_error <= settings['right']\n\n\nclose:\nright_sign and percent_error <= settings['close']\n\nright_sign:\nsign(student_scalar) = sign(correct_quantity)", "marking_notes": [{"name": "mark", "description": "This is the main marking note. It should award credit and provide feedback based on the student's answer.", "definition": "switch( \n  right and good_units and right_sign, add_credit(1.0,'Correct.'),\n  right and good_units and not right_sign, add_credit(settings['C2'],'Wrong sign.'),\n  right and right_sign and not good_units, add_credit(settings['C2'],'Correct value, but wrong or missing units.'),\n  close and good_units, add_credit(settings['C1'],'Close.'),\n  close and not good_units, add_credit(settings['C3'],'Answer is close, but wrong or missing units.'),\n  incorrect('Wrong answer.')\n)\n"}, {"name": "interpreted_answer", "description": "A value representing the student's answer to this part.", "definition": "qty(student_scalar, student_units)\n\n"}, {"name": "correct_quantity", "description": "", "definition": "settings[\"correctAnswer\"]\n\n"}, {"name": "correct_units", "description": "", "definition": "units(correct_quantity)\n"}, {"name": "allowed_notation_styles", "description": "", "definition": "[\"plain\",\"en\"]"}, {"name": "match_student_number", "description": "", "definition": "matchnumber(studentAnswer,allowed_notation_styles)"}, {"name": "student_scalar", "description": "", "definition": "match_student_number[1]"}, {"name": "student_units", "description": "<p>Modify&nbsp;the&nbsp;unit portion of&nbsp;the student's answer by</p>\n<p>1. replacing \"ohms\" with \"ohm\" &nbsp;case insensitive</p>\n<p>2.&nbsp;replacing '-'&nbsp;with ' '&nbsp;</p>\n<p>3. replacing '&deg;' with ' deg'&nbsp;</p>\n<p>to allow answers like 10 ft-lb and 30&deg;</p>", "definition": "replace_regex('ohms','ohm',\n  replace_regex('\u00b0', ' deg',\n    replace_regex('-', ' ' ,\n      studentAnswer[len(match_student_number[0])..len(studentAnswer)])),\"i\")"}, {"name": "good_units", "description": "", "definition": "try(\ncompatible(quantity(1, student_units),correct_units),\nmsg,\nfeedback(msg);false)\n"}, {"name": "student_quantity", "description": "<p>This fixes the student answer for two common errors. &nbsp;</p>\n<p>If student_units are wrong&nbsp;&nbsp;- replace with correct units</p>\n<p>If student_scalar has the wrong sign - replace with right sign</p>\n<p>If student makes both errors, only one gets fixed.</p>", "definition": "switch(not good_units, \n       student_scalar * correct_units, \n       not right_sign,\n       -quantity(student_scalar, student_units),\n       quantity(student_scalar,student_units)\n)\n  \n"}, {"name": "percent_error", "description": "", "definition": "try(\nscalar(abs((correct_quantity - student_quantity)/correct_quantity))*100  \n,msg,\nif(student_quantity=correct_quantity,0,100))\n   "}, {"name": "right", "description": "", "definition": "percent_error <= settings['right']\n"}, {"name": "close", "description": "<p>Only marked close if the student actually has the right sign.</p>", "definition": "right_sign and percent_error <= settings['close']"}, {"name": "right_sign", "description": "", "definition": "sign(student_scalar) = sign(correct_quantity) "}], "settings": [{"name": "correctAnswer", "label": "Correct Quantity.", "help_url": "", "hint": "The correct answer given as a JME quantity.", "input_type": "code", "default_value": "", "evaluate": true}, {"name": "right", "label": "% Accuracy for right.", "help_url": "", "hint": "Question will be considered correct if the scalar part of the student's answer is within this % of correct value.", "input_type": "code", "default_value": "0.2", "evaluate": true}, {"name": "close", "label": "% Accuracy for close.", "help_url": "", "hint": "Question will be considered close if the scalar part of the student's answer is within this % of correct value.", "input_type": "code", "default_value": "1.0", "evaluate": true}, {"name": "C1", "label": "Close with units.", "help_url": "", "hint": "Partial Credit for close value with appropriate units. &nbsp;if correct answer is 100 N and close is &plusmn;1%,<br />99 &nbsp;N is accepted.", "input_type": "percent", "default_value": "75"}, {"name": "C2", "label": "No units or wrong sign", "help_url": "", "hint": "Partial credit for forgetting units or using wrong sign.<br />If the correct answer is 100 N, both 100 and -100 N are accepted.", "input_type": "percent", "default_value": "50"}, {"name": "C3", "label": "Close, no units.", "help_url": "", "hint": "Partial Credit for close value but forgotten units.<br />This value would be close&nbsp;if the expected units were provided. &nbsp;If the correct answer is 100 N, and close is &plusmn;1%,<br />99 is accepted.", "input_type": "percent", "default_value": "25"}], "public_availability": "always", "published": true, "extensions": ["quantities"]}], "resources": [], "navigation": {"allowregen": true, "showfrontpage": false, "preventleave": false, "typeendtoleave": false}, "contributors": [{"name": "William Haynes", "profile_url": "https://numbas.mathcentre.ac.uk/accounts/profile/2530/"}], "tags": ["Couple", "Mechanics", "mechanics", "Moments", "moments", "perpendicular distance", "Perpendicular distance", "Statics", "statics", "Verignon's Theorem"], "metadata": {"description": "<p>Find the moment of a couple formed by two equal and opposite forces.</p>", "licence": "Creative Commons Attribution-NonCommercial 4.0 International"}, "statement": "<p>{applet}</p>\n<p>{setAxisVisible(applet,false)}</p>\n<p>Determine the moment of the couple formed by the two&nbsp;{F} {units[1]} forces shown. &nbsp;Grid units are in [{units[0]}].</p>", "advice": "<p>The moment of a couple is found by multiplying the magnitude of force by the perpendicular distance between the lines of action of the two forces. The direction is determined by inspection. &nbsp;You will need to determine the perpendicular distance using the known locations of the two points, the direction of the force, geometry and trigonometry as we have done before.</p>\n<p>$ M = F \\cdot d_\\perp$</p>\n<p>$ M = (\\var{F}\\,&nbsp; \\var{units[1]} ) (\\var{abs(siground(moment/F,4))}\\,&nbsp; \\var{units[0]} ) = \\var{siground(abs(answer),4)}$&nbsp; {if(moment&nbsp;&gt;0,'Counterclockwise','Clockwise')}</p>\n<p>Alternately, you get the same result by finding the moment of one force about a point on the line of action of the other one. &nbsp;</p>\n<p>So, for example, take the moment of the force at $A$ about point $B$ using Verignon's Theorem. The signs in the equation below are determined by the direction of the component moments, using the sign convention that counterclockwise moments are positive. &nbsp;The sign of the resulting moment indicates its direction and it should agree with your expectations&nbsp;from&nbsp;inspection of the diagram.</p>\n<p>$ M = \\pm F_x d_y \\pm F_y d_x $</p>\n<p>$ M = \\pm\\, ( \\var{d(Force[0] )} \\, \\var{units[1]} ) ( \\var{d(r[1])} \\, \\var{units[0]} &nbsp;) \\pm\\, ( \\var{d(Force[1] )} \\, \\var{units[1]} ) ( \\var{d(r[0])} \\, \\var{units[0]} &nbsp;)$</p>\n<p>$M = \\var{siground(answer,4)}$</p>\n<p>$M = \\var{siground(abs(answer),4)} $&nbsp;{if(moment&nbsp;&gt;0,'Counterclockwise','Clockwise')}&nbsp;</p>", "rulesets": {}, "builtin_constants": {"e": true, "pi,\u03c0": true, "i": true}, "constants": [], "variables": {"F": {"name": "F", "group": "inputs", "definition": "random(10..400#10)", "description": "", "templateType": "anything", "can_override": false}, "A": {"name": "A", "group": "inputs", "definition": "vector(random(-8..8),random(-6..6))", "description": "", "templateType": "anything", "can_override": false}, "theta": {"name": "theta", "group": "inputs", "definition": "random(5..355#5 except [90,-90,180])", "description": "", "templateType": "anything", "can_override": false}, "r": {"name": "r", "group": "results", "definition": "A-B + vector(0,0,0)", "description": "<p>position vector</p>", "templateType": "anything", "can_override": false}, "B": {"name": "B", "group": "inputs", "definition": "vector(random(-8..8),random(-6..6))", "description": "", "templateType": "anything", "can_override": false}, "Force": {"name": "Force", "group": "results", "definition": "vector(f cos(radians(theta)),f sin(radians(theta)),0)", "description": "<p>Force vector</p>", "templateType": "anything", "can_override": false}, "answer": {"name": "answer", "group": "results", "definition": "d(moment) qty(units[1])qty(units[0])", "description": "<p>rounded value of moment as quantity</p>", "templateType": "anything", "can_override": false}, "moment": {"name": "moment", "group": "results", "definition": "cross(r,force)[2]", "description": "<p>Magnitude of moment</p>", "templateType": "anything", "can_override": false}, "units": {"name": "units", "group": "inputs", "definition": "random(['in','lb'],['m','kN'],['cm','N'])", "description": "", "templateType": "anything", "can_override": false}, "params": {"name": "params", "group": "Ungrouped variables", "definition": "[ A: A, B: B, '\u03b8': radians(theta), show: [definition: 'false', visible: false]]", "description": "", "templateType": "anything", "can_override": false}, "applet": {"name": "applet", "group": "Ungrouped variables", "definition": "geogebra_applet('whx4ybuq', params )", "description": "", "templateType": "anything", "can_override": false}, "dperp": {"name": "dperp", "group": "results", "definition": "abs(moment)/F", "description": "<p>perpendicular distance</p>", "templateType": "anything", "can_override": false}}, "variablesTest": {"condition": "abs(r) > 2 //  nice size\nand dperp/abs(r) < 0.96 // cos angle  makes angle > 15\u00b0\nand dperp/abs(r) > 0.18 // cos angle  makes angle < 80\u00b0\nand A[0] <> B[0] and A[1] <> B[1] // not on same vertical or horizontal axis", "maxRuns": 100}, "ungrouped_variables": ["params", "applet"], "variable_groups": [{"name": "inputs", "variables": ["A", "B", "theta", "units", "F"]}, {"name": "results", "variables": ["r", "Force", "moment", "answer", "dperp"]}], "functions": {"d": {"parameters": [["v", "number"]], "type": "number", "language": "jme", "definition": "siground(abs(v),4)"}, "setAxisVisible": {"parameters": [["app", "ggbapplet"], ["visible", "boolean"]], "type": "anything", "language": "javascript", "definition": "app.promise.then(function(d) {\n  d.app.setAxesVisible(visible,visible);});\nreturn new Numbas.jme.types.ggbapplet(app);\n\n"}}, "preamble": {"js": "question.signals.on('adviceDisplayed',function() {\n try{\n    var app = question.scope.variables.applet.app;  \n    app.setVisible(\"show\", true,false);\n    app.setValue(\"show\", 1);\n  }\n  catch(err){}  \n})", "css": ""}, "parts": [{"type": "gapfill", "useCustomName": false, "customName": "", "marks": 0, "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": true, "showFeedbackIcon": true, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "prompt": "<p>$M$ =&nbsp;[[0]]&nbsp;[[1]]</p>", "gaps": [{"type": "engineering-answer", "useCustomName": true, "customName": "mag", "marks": "10", "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": true, "showFeedbackIcon": true, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "settings": {"correctAnswer": "abs(answer)", "right": "0.2", "close": "1.0", "C1": "75", "C2": "50", "C3": "25"}}, {"type": "1_n_2", "useCustomName": true, "customName": "dir", "marks": 0, "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": true, "showFeedbackIcon": false, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "minMarks": 0, "maxMarks": 0, "shuffleChoices": true, "displayType": "dropdownlist", "displayColumns": 0, "showCellAnswerState": true, "choices": ["Clockwise", "Counterclockwise"], "matrix": "[if(moment<0,5,0),if(moment>0,5,0)]"}], "sortAnswers": false}], "partsMode": "all", "maxMarks": 0, "objectives": [], "penalties": [], "objectiveVisibility": "always", "penaltyVisibility": "always", "type": "question"}, {"name": "Moment of a couple: resultant couple", "extensions": ["geogebra", "quantities"], "custom_part_types": [{"source": {"pk": 19, "author": {"name": "William Haynes", "pk": 2530}, "edit_page": "/part_type/19/edit"}, "name": "Engineering Accuracy with units", "short_name": "engineering-answer", "description": "<p>A value with units marked right if within an adjustable % error of the correct value. &nbsp;Marked close if within a wider margin of error.</p>", "help_url": "", "input_widget": "string", "input_options": {"correctAnswer": "siground(settings['correctAnswer'],4)", "hint": {"static": true, "value": ""}, "allowEmpty": {"static": true, "value": true}}, "can_be_gap": true, "can_be_step": true, "marking_script": "mark:\nswitch( \n  right and good_units and right_sign, add_credit(1.0,'Correct.'),\n  right and good_units and not right_sign, add_credit(settings['C2'],'Wrong sign.'),\n  right and right_sign and not good_units, add_credit(settings['C2'],'Correct value, but wrong or missing units.'),\n  close and good_units, add_credit(settings['C1'],'Close.'),\n  close and not good_units, add_credit(settings['C3'],'Answer is close, but wrong or missing units.'),\n  incorrect('Wrong answer.')\n)\n\n\ninterpreted_answer:\nqty(student_scalar, student_units)\n\n\n\ncorrect_quantity:\nsettings[\"correctAnswer\"]\n\n\n\ncorrect_units:\nunits(correct_quantity)\n\n\nallowed_notation_styles:\n[\"plain\",\"en\"]\n\nmatch_student_number:\nmatchnumber(studentAnswer,allowed_notation_styles)\n\nstudent_scalar:\nmatch_student_number[1]\n\nstudent_units:\nreplace_regex('ohms','ohm',\n  replace_regex('\u00b0', ' deg',\n    replace_regex('-', ' ' ,\n      studentAnswer[len(match_student_number[0])..len(studentAnswer)])),\"i\")\n\ngood_units:\ntry(\ncompatible(quantity(1, student_units),correct_units),\nmsg,\nfeedback(msg);false)\n\n\nstudent_quantity:\nswitch(not good_units, \n       student_scalar * correct_units, \n       not right_sign,\n       -quantity(student_scalar, student_units),\n       quantity(student_scalar,student_units)\n)\n  \n\n\npercent_error:\ntry(\nscalar(abs((correct_quantity - student_quantity)/correct_quantity))*100  \n,msg,\nif(student_quantity=correct_quantity,0,100))\n   \n\nright:\npercent_error <= settings['right']\n\n\nclose:\nright_sign and percent_error <= settings['close']\n\nright_sign:\nsign(student_scalar) = sign(correct_quantity)", "marking_notes": [{"name": "mark", "description": "This is the main marking note. It should award credit and provide feedback based on the student's answer.", "definition": "switch( \n  right and good_units and right_sign, add_credit(1.0,'Correct.'),\n  right and good_units and not right_sign, add_credit(settings['C2'],'Wrong sign.'),\n  right and right_sign and not good_units, add_credit(settings['C2'],'Correct value, but wrong or missing units.'),\n  close and good_units, add_credit(settings['C1'],'Close.'),\n  close and not good_units, add_credit(settings['C3'],'Answer is close, but wrong or missing units.'),\n  incorrect('Wrong answer.')\n)\n"}, {"name": "interpreted_answer", "description": "A value representing the student's answer to this part.", "definition": "qty(student_scalar, student_units)\n\n"}, {"name": "correct_quantity", "description": "", "definition": "settings[\"correctAnswer\"]\n\n"}, {"name": "correct_units", "description": "", "definition": "units(correct_quantity)\n"}, {"name": "allowed_notation_styles", "description": "", "definition": "[\"plain\",\"en\"]"}, {"name": "match_student_number", "description": "", "definition": "matchnumber(studentAnswer,allowed_notation_styles)"}, {"name": "student_scalar", "description": "", "definition": "match_student_number[1]"}, {"name": "student_units", "description": "<p>Modify&nbsp;the&nbsp;unit portion of&nbsp;the student's answer by</p>\n<p>1. replacing \"ohms\" with \"ohm\" &nbsp;case insensitive</p>\n<p>2.&nbsp;replacing '-'&nbsp;with ' '&nbsp;</p>\n<p>3. replacing '&deg;' with ' deg'&nbsp;</p>\n<p>to allow answers like 10 ft-lb and 30&deg;</p>", "definition": "replace_regex('ohms','ohm',\n  replace_regex('\u00b0', ' deg',\n    replace_regex('-', ' ' ,\n      studentAnswer[len(match_student_number[0])..len(studentAnswer)])),\"i\")"}, {"name": "good_units", "description": "", "definition": "try(\ncompatible(quantity(1, student_units),correct_units),\nmsg,\nfeedback(msg);false)\n"}, {"name": "student_quantity", "description": "<p>This fixes the student answer for two common errors. &nbsp;</p>\n<p>If student_units are wrong&nbsp;&nbsp;- replace with correct units</p>\n<p>If student_scalar has the wrong sign - replace with right sign</p>\n<p>If student makes both errors, only one gets fixed.</p>", "definition": "switch(not good_units, \n       student_scalar * correct_units, \n       not right_sign,\n       -quantity(student_scalar, student_units),\n       quantity(student_scalar,student_units)\n)\n  \n"}, {"name": "percent_error", "description": "", "definition": "try(\nscalar(abs((correct_quantity - student_quantity)/correct_quantity))*100  \n,msg,\nif(student_quantity=correct_quantity,0,100))\n   "}, {"name": "right", "description": "", "definition": "percent_error <= settings['right']\n"}, {"name": "close", "description": "<p>Only marked close if the student actually has the right sign.</p>", "definition": "right_sign and percent_error <= settings['close']"}, {"name": "right_sign", "description": "", "definition": "sign(student_scalar) = sign(correct_quantity) "}], "settings": [{"name": "correctAnswer", "label": "Correct Quantity.", "help_url": "", "hint": "The correct answer given as a JME quantity.", "input_type": "code", "default_value": "", "evaluate": true}, {"name": "right", "label": "% Accuracy for right.", "help_url": "", "hint": "Question will be considered correct if the scalar part of the student's answer is within this % of correct value.", "input_type": "code", "default_value": "0.2", "evaluate": true}, {"name": "close", "label": "% Accuracy for close.", "help_url": "", "hint": "Question will be considered close if the scalar part of the student's answer is within this % of correct value.", "input_type": "code", "default_value": "1.0", "evaluate": true}, {"name": "C1", "label": "Close with units.", "help_url": "", "hint": "Partial Credit for close value with appropriate units. &nbsp;if correct answer is 100 N and close is &plusmn;1%,<br />99 &nbsp;N is accepted.", "input_type": "percent", "default_value": "75"}, {"name": "C2", "label": "No units or wrong sign", "help_url": "", "hint": "Partial credit for forgetting units or using wrong sign.<br />If the correct answer is 100 N, both 100 and -100 N are accepted.", "input_type": "percent", "default_value": "50"}, {"name": "C3", "label": "Close, no units.", "help_url": "", "hint": "Partial Credit for close value but forgotten units.<br />This value would be close&nbsp;if the expected units were provided. &nbsp;If the correct answer is 100 N, and close is &plusmn;1%,<br />99 is accepted.", "input_type": "percent", "default_value": "25"}], "public_availability": "always", "published": true, "extensions": ["quantities"]}], "resources": [], "navigation": {"allowregen": true, "showfrontpage": false, "preventleave": false, "typeendtoleave": false}, "contributors": [{"name": "William Haynes", "profile_url": "https://numbas.mathcentre.ac.uk/accounts/profile/2530/"}], "tags": ["couples", "Couples", "mechanics", "Mechanics", "resultant moment", "statics", "Statics"], "metadata": {"description": "<p>Find the sum of two couples in a plane.</p>", "licence": "Creative Commons Attribution-NonCommercial 4.0 International"}, "statement": "<p>{applet}</p>\n<p>Two couples act on a rectangle with a base of $\\var{B}$ and a height of $\\var{H}$. &nbsp;&nbsp;</p>\n<p>Determine the magnitude and direction of the resultant moment, knowing that $F = \\var{F}$ &nbsp;and $G = \\var{G}$.</p>", "advice": "<p></p>\n<p>Let <em>h</em> be the height of the rectangle and $d_\\perp$ be the perpendicular distance between the lines of action of<strong> F</strong> and <strong>F'</strong>.</p>\n<p>Use the geometry of the problem to determine $d_\\perp = \\var{display(abs(dperp))}$</p>\n<p>$M_F = F \\cdot d_\\perp = (\\var{f}) (\\var{display(abs(dperp))})&nbsp;= \\var{display(abs(M_f))}$ {if(sign(M_F)=1,'Counterclockwise','Clockwise')}</p>\n<p>$M_G = &nbsp;G \\cdot h =$ ({g}) ({h}) = {display(abs(M_g))} Clockwise</p>\n<p>$M_T = \\Sigma M = M_F&nbsp;+ M_G&nbsp;=&nbsp;(\\var{display(M_F)}) + (\\var{display(M_G)}) = \\var{display(M_t)}$</p>\n<p>$M_T =&nbsp;\\var{display(abs(M_T))}$&nbsp;{if(sign(M_T)=1,'Counterclockwise','Clockwise')}</p>", "rulesets": {}, "builtin_constants": {"e": true, "pi,\u03c0": true, "i": true}, "constants": [], "variables": {"height": {"name": "height", "group": "Ungrouped variables", "definition": "random(2..10)", "description": "", "templateType": "anything", "can_override": false}, "units": {"name": "units", "group": "Ungrouped variables", "definition": "random(['N','m'],['lb','ft'],['lb','in'])", "description": "", "templateType": "anything", "can_override": false}, "G": {"name": "G", "group": "Ungrouped variables", "definition": "qty(random(20..100#5),units[0])", "description": "", "templateType": "anything", "can_override": false}, "base": {"name": "base", "group": "Ungrouped variables", "definition": "random(2..10)", "description": "", "templateType": "anything", "can_override": false}, "M_t": {"name": "M_t", "group": "Ungrouped variables", "definition": "M_f + M_g", "description": "", "templateType": "anything", "can_override": false}, "b": {"name": "b", "group": "Ungrouped variables", "definition": "qty(base,units[1])\n", "description": "", "templateType": "anything", "can_override": false}, "alpha": {"name": "alpha", "group": "Ungrouped variables", "definition": "random(10..260#10 except[90,180])", "description": "", "templateType": "anything", "can_override": false}, "M_f": {"name": "M_f", "group": "Ungrouped variables", "definition": "f dperp", "description": "", "templateType": "anything", "can_override": false}, "F": {"name": "F", "group": "Ungrouped variables", "definition": "qty(random(20..100#5),units[0])", "description": "", "templateType": "anything", "can_override": false}, "M_g": {"name": "M_g", "group": "Ungrouped variables", "definition": "-g h", "description": "", "templateType": "anything", "can_override": false}, "dperp": {"name": "dperp", "group": "Ungrouped variables", "definition": "b sin(radians(alpha)) + h cos(radians(alpha))", "description": "", "templateType": "anything", "can_override": false}, "h": {"name": "h", "group": "Ungrouped variables", "definition": "qty(height,units[1])", "description": "", "templateType": "anything", "can_override": false}, "applet": {"name": "applet", "group": "Ungrouped variables", "definition": "geogebra_applet('qfszc468',params)", "description": "", "templateType": "anything", "can_override": false}, "params": {"name": "params", "group": "Ungrouped variables", "definition": "[B: vector(base,height), '\u03b1':  radians(alpha)]", "description": "", "templateType": "anything", "can_override": false}}, "variablesTest": {"condition": "", "maxRuns": 100}, "ungrouped_variables": ["base", "height", "alpha", "units", "G", "b", "h", "F", "dperp", "M_f", "M_g", "M_t", "applet", "params"], "variable_groups": [], "functions": {"display": {"parameters": [["q", "quantity"]], "type": "quantity", "language": "jme", "definition": "string(siground(q,4))"}}, "preamble": {"js": "", "css": ""}, "parts": [{"type": "gapfill", "useCustomName": false, "customName": "", "marks": 0, "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": true, "showFeedbackIcon": true, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "prompt": "<p>The resultant moment has a magnitude of&nbsp;[[0]] in the&nbsp;[[1]] direction. &nbsp;<span data-jme-visible=\"false\">{M_t}</span></p>", "gaps": [{"type": "engineering-answer", "useCustomName": true, "customName": "mag", "marks": "10", "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": true, "showFeedbackIcon": true, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "settings": {"correctAnswer": "abs(M_t)", "right": "0.2", "close": "1.0", "C1": "75", "C2": "50", "C3": "25"}}, {"type": "1_n_2", "useCustomName": true, "customName": "dir", "marks": 0, "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": true, "showFeedbackIcon": true, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "minMarks": 0, "maxMarks": 0, "shuffleChoices": false, "displayType": "dropdownlist", "displayColumns": 0, "showCellAnswerState": true, "choices": ["clockwise", "counterclockwise", "Neither"], "matrix": "[if(scalar(M_t)<0,5,0),if(scalar(M_t)>0,5,0),if(scalar(M_t)=0,5,0)]"}], "sortAnswers": false}], "partsMode": "all", "maxMarks": 0, "objectives": [], "penalties": [], "objectiveVisibility": "always", "penaltyVisibility": "always", "type": "question"}, {"name": "Couples in equilibrium", "extensions": ["geogebra", "quantities"], "custom_part_types": [{"source": {"pk": 24, "author": {"name": "William Haynes", "pk": 2530}, "edit_page": "/part_type/24/edit"}, "name": "Angle quantity", "short_name": "angle-quantity-from-reference", "description": "<p>Angle&nbsp;as a quantity in degrees.</p>", "help_url": "", "input_widget": "string", "input_options": {"correctAnswer": "plain_string(settings['correct_quantity'])", "hint": {"static": true, "value": ""}, "allowEmpty": {"static": true, "value": false}}, "can_be_gap": true, "can_be_step": true, "marking_script": "mark:\nswitch( \nright and good_units and right_sign and angle_in_range, add_credit(1.0,'Correct.'),\nright and good_units and not right_sign, add_credit(settings['C2'],'Wrong sign.'),\nright and right_sign and not good_units, add_credit(settings['C2'],'Correct angle, but missing degree symbol.'),\nright and good_units and right_sign and not angle_in_range,add_credit(settings['C1'],'Angle is out of range.'),\nclose and good_units, add_credit(settings['C1'],'Close.'),\nclose and not good_units, add_credit(settings['C3'],'Answer is close, but missing degree symbol.'),\nincorrect('Wrong answer.')\n)\n\ninterpreted_answer:\nqty(student_scalar, student_units)\n\ncorrect_scalar:\nscalar(correct_quantity)\n  \n\ncorrect_quantity:\nsettings['correct_quantity']\n\ncorrect_units:\nunits(correct_quantity)\n\nallowed_notation_styles:\n[\"plain\",\"en\"]\n\nmatch_student_number:\nmatchnumber(studentAnswer,allowed_notation_styles)\n\nstudent_scalar:\nmatch_student_number[1]\n\nstudent_units:\njoin(\nsplit(studentAnswer[len(match_student_number[0])..len(studentAnswer)]\n,\"\u00b0\"),\" deg\")\n\n\n\ngood_units:\ntry(\nkind(quantity(1, student_units))= kind(correct_quantity),\nmsg,\nfeedback(msg);false)\n\nstudent_quantity:\nswitch(not good_units, \nstudent_scalar * correct_units, \nnot right_sign,\n-quantity(student_scalar, student_units),\nquantity(student_scalar,student_units)\n)\n\nright_sign:\nsign(student_scalar) = sign(correct_quantity)\n\nangle_in_range:\nif(settings['restrict_angle'], abs(student_scalar) <= 90, true)\n\nright:\nwithinTolerance(abs(student_scalar), abs(correct_scalar), settings['right'])\n\nclose:\nwithinTolerance(student_scalar, correct_scalar, settings['close'])", "marking_notes": [{"name": "mark", "description": "This is the main marking note. It should award credit and provide feedback based on the student's answer.", "definition": "switch( \nright and good_units and right_sign and angle_in_range, add_credit(1.0,'Correct.'),\nright and good_units and not right_sign, add_credit(settings['C2'],'Wrong sign.'),\nright and right_sign and not good_units, add_credit(settings['C2'],'Correct angle, but missing degree symbol.'),\nright and good_units and right_sign and not angle_in_range,add_credit(settings['C1'],'Angle is out of range.'),\nclose and good_units, add_credit(settings['C1'],'Close.'),\nclose and not good_units, add_credit(settings['C3'],'Answer is close, but missing degree symbol.'),\nincorrect('Wrong answer.')\n)"}, {"name": "interpreted_answer", "description": "A value representing the student's answer to this part.", "definition": "qty(student_scalar, student_units)"}, {"name": "correct_scalar", "description": "", "definition": "scalar(correct_quantity)\n  "}, {"name": "correct_quantity", "description": "", "definition": "settings['correct_quantity']"}, {"name": "correct_units", "description": "", "definition": "units(correct_quantity)"}, {"name": "allowed_notation_styles", "description": "", "definition": "[\"plain\",\"en\"]"}, {"name": "match_student_number", "description": "", "definition": "matchnumber(studentAnswer,allowed_notation_styles)"}, {"name": "student_scalar", "description": "", "definition": "match_student_number[1]"}, {"name": "student_units", "description": "", "definition": "join(\nsplit(studentAnswer[len(match_student_number[0])..len(studentAnswer)]\n,\"\u00b0\"),\" deg\")\n\n"}, {"name": "good_units", "description": "", "definition": "try(\nkind(quantity(1, student_units))= kind(correct_quantity),\nmsg,\nfeedback(msg);false)"}, {"name": "student_quantity", "description": "", "definition": "switch(not good_units, \nstudent_scalar * correct_units, \nnot right_sign,\n-quantity(student_scalar, student_units),\nquantity(student_scalar,student_units)\n)"}, {"name": "right_sign", "description": "", "definition": "sign(student_scalar) = sign(correct_quantity)"}, {"name": "angle_in_range", "description": "", "definition": "if(settings['restrict_angle'], abs(student_scalar) <= 90, true)"}, {"name": "right", "description": "<p>Will check for correct sign elswhere.</p>", "definition": "withinTolerance(abs(student_scalar), abs(correct_scalar), settings['right'])"}, {"name": "close", "description": "<p>Must have correct sign to be close.</p>", "definition": "withinTolerance(student_scalar, correct_scalar, settings['close'])\n"}], "settings": [{"name": "correct_quantity", "label": "Correct Angle as quantity ", "help_url": "", "hint": "", "input_type": "code", "default_value": "qty(45,'deg')", "evaluate": true}, {"name": "right", "label": "Accuracy for right.", "help_url": "", "hint": "Question will be considered correct if the scalar part of the student's answer is within &plusmn; this amount from the correct value.", "input_type": "code", "default_value": "0.1", "evaluate": true}, {"name": "restrict_angle", "label": "Less than 90\u00b0", "help_url": "", "hint": "When checked, angle must be between -90&deg; and +90&deg;.", "input_type": "checkbox", "default_value": true}, {"name": "C1", "label": "Close with units.", "help_url": "", "hint": "Partial Credit for close value with appropriate units.", "input_type": "percent", "default_value": "75"}, {"name": "close", "label": " Accuracy for close.", "help_url": "", "hint": "Question will be considered close if the scalar part of the student's answer is within &plusmn; this amount from the correct value.", "input_type": "code", "default_value": "0.5", "evaluate": true}, {"name": "C2", "label": "No units or wrong sign", "help_url": "", "hint": "Partial credit for forgetting units or using wrong sign.", "input_type": "percent", "default_value": "50"}, {"name": "C3", "label": "Close, no units.", "help_url": "", "hint": "Partial Credit for close value without units.", "input_type": "percent", "default_value": "25"}], "public_availability": "restricted", "published": false, "extensions": ["quantities"]}], "resources": [], "navigation": {"allowregen": true, "showfrontpage": false, "preventleave": false, "typeendtoleave": false}, "contributors": [{"name": "William Haynes", "profile_url": "https://numbas.mathcentre.ac.uk/accounts/profile/2530/"}], "tags": ["Couples", "couples", "Equilibrium", "equilibrium", "Mechanics", "mechanics", "Statics", "statics", "weierstrass"], "metadata": {"description": "<p>Solve for an angle which will result in equilibrium for a triangle subjected to three couples. &nbsp; A trial and error solution is recommended.</p>", "licence": "Creative Commons Attribution-NonCommercial 4.0 International"}, "statement": "<p>{applet}</p>\n<p>Determine angle $\\alpha$ knowing that the triangular plate is in equilbrium when subjected to the three couples shown.</p>\n<p></p>", "advice": "<p>The triangular plate is in equlibrium, so the three couple moments add to zero. &nbsp;Note that the length of side $d$&nbsp;the triangle is not significant, only the angle $\\alpha$.</p>\n<p>\\[\\begin{align} &nbsp;\\Sigma M &amp;=0\\\\M_1 + M_2 + M_3 &amp;= 0\\\\ \\require{cancel} (\\var{F_1} \\cancel{d} \\cos \\alpha) + (\\var {F_2} &nbsp;\\cancel{d} \\sin \\alpha) + (\\var{show(F_3)}\\cancel{d} )&amp;= 0\\\\ \\simplify[all,!collectNumbers]{{F_1} cos(alpha)+ {F_2} sin(alpha)} &amp;= \\simplify{ - {show(F_3)}}&nbsp;\\\\ \\alpha &amp;= \\var{alpha}&deg;\\end{align}\\]</p>\n<p>This equation&nbsp;has only one&nbsp;unknown, and it can be solved algebraically for $\\alpha$, although it is not simple. &nbsp;For the method, see <a href=\"https://weh.maritime.edu/mechanics/images/2_32.pdf\" title=\"this example\">this example</a>. &nbsp;</p>\n<p>An easier way is simply to plot &nbsp;the equation:&nbsp;$y = \\simplify[all,!collectNumbers]{{F_1} cos(alpha)+ {F_2} sin(alpha) + &nbsp;{show(F_3)}} $; the first positive root is the answer. &nbsp;A guess-and-check solution may also be used.</p>\n<p>{advice}</p>", "rulesets": {}, "builtin_constants": {"e": true, "pi,\u03c0": true, "i": true}, "constants": [], "variables": {"F_1": {"name": "F_1", "group": "Inputs", "definition": "random(-500..500#50 except 0)", "description": "", "templateType": "anything", "can_override": false}, "F_3": {"name": "F_3", "group": "results", "definition": "-(F_1 cos(radians(alpha)) + F_2 sin(radians(alpha)))", "description": "", "templateType": "anything", "can_override": false}, "alpha": {"name": "alpha", "group": "Inputs", "definition": "random(25..75)", "description": "", "templateType": "anything", "can_override": false}, "F_2": {"name": "F_2", "group": "Inputs", "definition": "random(-500..500#50 except 0)", "description": "", "templateType": "anything", "can_override": false}, "x_max": {"name": "x_max", "group": "results", "definition": "degrees(arctan(F_2/F_1))", "description": "<p style=\"text-align: left;\">this is the angle of the maximum point on the sine wave</p>", "templateType": "anything", "can_override": false}, "roots": {"name": "roots", "group": "results", "definition": "[x_max+abs(x_max - alpha),x_max - abs(x_max - alpha)]", "description": "<p>roots are symmetrically to the left and right of the maximum. &nbsp;Variable testing eliminates cases where there are two roots &lt; 90&deg;</p>", "templateType": "anything", "can_override": false}, "applet": {"name": "applet", "group": "ggb", "definition": "geogebra_applet('vyuvgyf7',params)", "description": "<p>{geogebra_applet('vyuvgyf7', [['&alpha;' , radians(alpha)],&nbsp;&nbsp;['F_1', F_1], ['F_2', F_2] ] )}&nbsp;</p>", "templateType": "anything", "can_override": false}, "params": {"name": "params", "group": "ggb", "definition": "['\u03b1':radians(alpha),\nF_1: F_1,\nF_2: F_2 ]", "description": "", "templateType": "anything", "can_override": false}, "advice": {"name": "advice", "group": "ggb", "definition": "geogebra_applet('y3s8cnxe',advice_params)", "description": "<p>{geogebra_applet('y3s8cnxe',[&nbsp;['F_1', F_1], ['F_2', F_2],['F_3', F_3] ])}</p>", "templateType": "anything", "can_override": false}, "advice_params": {"name": "advice_params", "group": "ggb", "definition": "[F_1: F_1, F_2: F_2, F_3: F_3]", "description": "", "templateType": "anything", "can_override": false}}, "variablesTest": {"condition": "not (abs(roots[0]) < 90 and abs(roots[1]) < 90)", "maxRuns": 100}, "ungrouped_variables": [], "variable_groups": [{"name": "Inputs", "variables": ["alpha", "F_1", "F_2"]}, {"name": "results", "variables": ["F_3", "x_max", "roots"]}, {"name": "ggb", "variables": ["applet", "params", "advice", "advice_params"]}], "functions": {"show": {"parameters": [["f", "number"]], "type": "number", "language": "jme", "definition": "siground(f,4)"}}, "preamble": {"js": "", "css": ""}, "parts": [{"type": "gapfill", "useCustomName": false, "customName": "", "marks": 0, "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": true, "showFeedbackIcon": true, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "prompt": "<p>$\\alpha $ =&nbsp;[[0]]&nbsp;</p>\n<p><em></em></p>\n<p><em>Note: the angle is an integer between 0&deg; and 90&deg;.</em></p>", "gaps": [{"type": "angle-quantity-from-reference", "useCustomName": true, "customName": "alpha", "marks": "10", "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": true, "showFeedbackIcon": true, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "settings": {"correct_quantity": "qty(alpha,'deg')", "right": "0.2", "restrict_angle": true, "C1": "75", "close": "1.0", "C2": "50", "C3": "25"}}], "sortAnswers": false}], "partsMode": "all", "maxMarks": 0, "objectives": [], "penalties": [], "objectiveVisibility": "always", "penaltyVisibility": "always", "type": "question"}]}, {"name": "Equivalent Systems", "pickingStrategy": "all-ordered", "pickQuestions": 1, "questionNames": ["Two parallel forces", "Equivalent force-couple system: Circle", "Equivalent Force-couple system: Bracket", ""], "variable_overrides": [[], [], [], []], "questions": [{"name": "Equivalent System: two parallel forces", "extensions": ["geogebra", "quantities"], "custom_part_types": [{"source": {"pk": 19, "author": {"name": "William Haynes", "pk": 2530}, "edit_page": "/part_type/19/edit"}, "name": "Engineering Accuracy with units", "short_name": "engineering-answer", "description": "<p>A value with units marked right if within an adjustable % error of the correct value. &nbsp;Marked close if within a wider margin of error.</p>", "help_url": "", "input_widget": "string", "input_options": {"correctAnswer": "siground(settings['correctAnswer'],4)", "hint": {"static": true, "value": ""}, "allowEmpty": {"static": true, "value": true}}, "can_be_gap": true, "can_be_step": true, "marking_script": "mark:\nswitch( \n  right and good_units and right_sign, add_credit(1.0,'Correct.'),\n  right and good_units and not right_sign, add_credit(settings['C2'],'Wrong sign.'),\n  right and right_sign and not good_units, add_credit(settings['C2'],'Correct value, but wrong or missing units.'),\n  close and good_units, add_credit(settings['C1'],'Close.'),\n  close and not good_units, add_credit(settings['C3'],'Answer is close, but wrong or missing units.'),\n  incorrect('Wrong answer.')\n)\n\n\ninterpreted_answer:\nqty(student_scalar, student_units)\n\n\n\ncorrect_quantity:\nsettings[\"correctAnswer\"]\n\n\n\ncorrect_units:\nunits(correct_quantity)\n\n\nallowed_notation_styles:\n[\"plain\",\"en\"]\n\nmatch_student_number:\nmatchnumber(studentAnswer,allowed_notation_styles)\n\nstudent_scalar:\nmatch_student_number[1]\n\nstudent_units:\nreplace_regex('ohms','ohm',\n  replace_regex('\u00b0', ' deg',\n    replace_regex('-', ' ' ,\n      studentAnswer[len(match_student_number[0])..len(studentAnswer)])),\"i\")\n\ngood_units:\ntry(\ncompatible(quantity(1, student_units),correct_units),\nmsg,\nfeedback(msg);false)\n\n\nstudent_quantity:\nswitch(not good_units, \n       student_scalar * correct_units, \n       not right_sign,\n       -quantity(student_scalar, student_units),\n       quantity(student_scalar,student_units)\n)\n  \n\n\npercent_error:\ntry(\nscalar(abs((correct_quantity - student_quantity)/correct_quantity))*100  \n,msg,\nif(student_quantity=correct_quantity,0,100))\n   \n\nright:\npercent_error <= settings['right']\n\n\nclose:\nright_sign and percent_error <= settings['close']\n\nright_sign:\nsign(student_scalar) = sign(correct_quantity)", "marking_notes": [{"name": "mark", "description": "This is the main marking note. It should award credit and provide feedback based on the student's answer.", "definition": "switch( \n  right and good_units and right_sign, add_credit(1.0,'Correct.'),\n  right and good_units and not right_sign, add_credit(settings['C2'],'Wrong sign.'),\n  right and right_sign and not good_units, add_credit(settings['C2'],'Correct value, but wrong or missing units.'),\n  close and good_units, add_credit(settings['C1'],'Close.'),\n  close and not good_units, add_credit(settings['C3'],'Answer is close, but wrong or missing units.'),\n  incorrect('Wrong answer.')\n)\n"}, {"name": "interpreted_answer", "description": "A value representing the student's answer to this part.", "definition": "qty(student_scalar, student_units)\n\n"}, {"name": "correct_quantity", "description": "", "definition": "settings[\"correctAnswer\"]\n\n"}, {"name": "correct_units", "description": "", "definition": "units(correct_quantity)\n"}, {"name": "allowed_notation_styles", "description": "", "definition": "[\"plain\",\"en\"]"}, {"name": "match_student_number", "description": "", "definition": "matchnumber(studentAnswer,allowed_notation_styles)"}, {"name": "student_scalar", "description": "", "definition": "match_student_number[1]"}, {"name": "student_units", "description": "<p>Modify&nbsp;the&nbsp;unit portion of&nbsp;the student's answer by</p>\n<p>1. replacing \"ohms\" with \"ohm\" &nbsp;case insensitive</p>\n<p>2.&nbsp;replacing '-'&nbsp;with ' '&nbsp;</p>\n<p>3. replacing '&deg;' with ' deg'&nbsp;</p>\n<p>to allow answers like 10 ft-lb and 30&deg;</p>", "definition": "replace_regex('ohms','ohm',\n  replace_regex('\u00b0', ' deg',\n    replace_regex('-', ' ' ,\n      studentAnswer[len(match_student_number[0])..len(studentAnswer)])),\"i\")"}, {"name": "good_units", "description": "", "definition": "try(\ncompatible(quantity(1, student_units),correct_units),\nmsg,\nfeedback(msg);false)\n"}, {"name": "student_quantity", "description": "<p>This fixes the student answer for two common errors. &nbsp;</p>\n<p>If student_units are wrong&nbsp;&nbsp;- replace with correct units</p>\n<p>If student_scalar has the wrong sign - replace with right sign</p>\n<p>If student makes both errors, only one gets fixed.</p>", "definition": "switch(not good_units, \n       student_scalar * correct_units, \n       not right_sign,\n       -quantity(student_scalar, student_units),\n       quantity(student_scalar,student_units)\n)\n  \n"}, {"name": "percent_error", "description": "", "definition": "try(\nscalar(abs((correct_quantity - student_quantity)/correct_quantity))*100  \n,msg,\nif(student_quantity=correct_quantity,0,100))\n   "}, {"name": "right", "description": "", "definition": "percent_error <= settings['right']\n"}, {"name": "close", "description": "<p>Only marked close if the student actually has the right sign.</p>", "definition": "right_sign and percent_error <= settings['close']"}, {"name": "right_sign", "description": "", "definition": "sign(student_scalar) = sign(correct_quantity) "}], "settings": [{"name": "correctAnswer", "label": "Correct Quantity.", "help_url": "", "hint": "The correct answer given as a JME quantity.", "input_type": "code", "default_value": "", "evaluate": true}, {"name": "right", "label": "% Accuracy for right.", "help_url": "", "hint": "Question will be considered correct if the scalar part of the student's answer is within this % of correct value.", "input_type": "code", "default_value": "0.2", "evaluate": true}, {"name": "close", "label": "% Accuracy for close.", "help_url": "", "hint": "Question will be considered close if the scalar part of the student's answer is within this % of correct value.", "input_type": "code", "default_value": "1.0", "evaluate": true}, {"name": "C1", "label": "Close with units.", "help_url": "", "hint": "Partial Credit for close value with appropriate units. &nbsp;if correct answer is 100 N and close is &plusmn;1%,<br />99 &nbsp;N is accepted.", "input_type": "percent", "default_value": "75"}, {"name": "C2", "label": "No units or wrong sign", "help_url": "", "hint": "Partial credit for forgetting units or using wrong sign.<br />If the correct answer is 100 N, both 100 and -100 N are accepted.", "input_type": "percent", "default_value": "50"}, {"name": "C3", "label": "Close, no units.", "help_url": "", "hint": "Partial Credit for close value but forgotten units.<br />This value would be close&nbsp;if the expected units were provided. &nbsp;If the correct answer is 100 N, and close is &plusmn;1%,<br />99 is accepted.", "input_type": "percent", "default_value": "25"}], "public_availability": "always", "published": true, "extensions": ["quantities"]}], "resources": [], "navigation": {"allowregen": true, "showfrontpage": false, "preventleave": false, "typeendtoleave": false}, "contributors": [{"name": "William Haynes", "profile_url": "https://numbas.mathcentre.ac.uk/accounts/profile/2530/"}], "tags": ["equivalent system", "Mechanics", "mechanics", "moment", "Moment", "Statics", "statics"], "metadata": {"description": "<p>Replace two parallel forces with an equivalent single force</p>", "licence": "Creative Commons Attribution-NonCommercial 4.0 International"}, "statement": "<p>{applet}</p>\n<p>A {L} {units[0]} long cantilever beam is loaded with vertical forces $A = \\var{force(A)}$ and&nbsp;$B = \\var{force(B)},$&nbsp;separated by a distance $d$ = {d L} {units[0]},&nbsp;as shown.</p>\n<p>Replace&nbsp;the two forces with a&nbsp;single equivalent force $R$ and determine the distance $\\bar{x}$ from the left end of the beam to the line of action of<em>&nbsp;</em>$R$.</p>\n<p></p>", "advice": "<p>Known:</p>\n<p>$A = \\var{force(A)}, B = \\var{force(B)}, \\ell = \\var{dist(L)}, d = \\var{dist(d L)} $</p>\n<p>Since both forces are vertical, the resultant force with also be vertical, with a magnitude</p>\n<p>$\\begin{align} R &amp;= A + B \\\\&amp;= \\var{A} + \\var{B}\\\\ &amp;= \\var{force(R)}\\end{align}$</p>\n<p>The equivalent force&nbsp;$R$ must produce the same moment about any point as the orignal system of forces did. &nbsp;Chosing the left end of the beam as the moment center, and equating moments, gives:</p>\n<p>$\\begin{align} M_2 &amp;= M_1\\\\ R\\, \\bar{x} &amp;= A \\,(\\ell - d) + B\\ell\\\\ \\bar{x} &amp; = \\dfrac{\\var{force(A)}\\cdot \\var{dist(L- d L)} +\\var{force(B)}\\,\\cdot \\var{dist(L)}} {\\var{force(R)}} \\\\ &amp;= \\var{dist(xbar)} \\end{align}$</p>", "rulesets": {}, "builtin_constants": {"e": true, "pi,\u03c0": true, "i": true}, "constants": [], "variables": {"xbar": {"name": "xbar", "group": "Unnamed group", "definition": "(A *(L - d L) + B L)/R", "description": "", "templateType": "anything", "can_override": false}, "A": {"name": "A", "group": "Ungrouped variables", "definition": "random(10..100#5)", "description": "", "templateType": "anything", "can_override": false}, "ratio": {"name": "ratio", "group": "Ungrouped variables", "definition": "random(0.5..2#0.1)\n", "description": "<p>ratio of magnitude of force B to magnitude of &nbsp;force A</p>", "templateType": "anything", "can_override": false}, "units": {"name": "units", "group": "Ungrouped variables", "definition": "['m', 'kN']", "description": "", "templateType": "anything", "can_override": false}, "d": {"name": "d", "group": "Ungrouped variables", "definition": "random(0.3..0.8#0.05)", "description": "<p>ratio of distance between A and B to length.</p>", "templateType": "anything", "can_override": false}, "R": {"name": "R", "group": "Unnamed group", "definition": "A + B", "description": "", "templateType": "anything", "can_override": false}, "L": {"name": "L", "group": "Ungrouped variables", "definition": "random(8,10,12)", "description": "", "templateType": "anything", "can_override": false}, "B": {"name": "B", "group": "Ungrouped variables", "definition": "ratio A\n", "description": "", "templateType": "anything", "can_override": false}, "params": {"name": "params", "group": "Unnamed group", "definition": "[d: d, ratio: ratio, \nshow: [visible: true, label_visible: false] ]", "description": "", "templateType": "anything", "can_override": false}, "applet": {"name": "applet", "group": "Unnamed group", "definition": "geogebra_applet('drbgytkc',params)", "description": "", "templateType": "anything", "can_override": false}}, "variablesTest": {"condition": "", "maxRuns": 100}, "ungrouped_variables": ["L", "d", "ratio", "A", "B", "units"], "variable_groups": [{"name": "Unnamed group", "variables": ["R", "xbar", "params", "applet"]}], "functions": {"dist": {"parameters": [["d", "number"]], "type": "quantity", "language": "jme", "definition": "siground(qty(d,units[0]),4)"}, "force": {"parameters": [["F", "number"]], "type": "quantity", "language": "jme", "definition": "siground(qty(f,units[1]),4)"}}, "preamble": {"js": "", "css": ""}, "parts": [{"type": "gapfill", "useCustomName": false, "customName": "", "marks": 0, "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": true, "showFeedbackIcon": true, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "prompt": "<p>$R$ =&nbsp;[[0]]&nbsp; $\\qquad \\bar{x} = $ [[1]]&nbsp;</p>", "gaps": [{"type": "engineering-answer", "useCustomName": true, "customName": "R", "marks": "10", "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": true, "showFeedbackIcon": true, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "settings": {"correctAnswer": "Force(R)", "right": "0.2", "close": "1.0", "C1": "75", "C2": "50", "C3": "25"}}, {"type": "engineering-answer", "useCustomName": true, "customName": "bar", "marks": "10", "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": true, "showFeedbackIcon": true, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "settings": {"correctAnswer": "dist(xbar)", "right": "0.2", "close": "1.0", "C1": "75", "C2": "50", "C3": "25"}}], "sortAnswers": false}], "partsMode": "all", "maxMarks": 0, "objectives": [], "penalties": [], "objectiveVisibility": "always", "penaltyVisibility": "always", "type": "question"}, {"name": "Equivalent force-couple system: Circle", "extensions": ["geogebra", "quantities"], "custom_part_types": [{"source": {"pk": 12, "author": {"name": "William Haynes", "pk": 2530}, "edit_page": "/part_type/12/edit"}, "name": "Angle quantity 2020", "short_name": "angle", "description": "<p>Adjusts all angles to 0 &lt; $\\theta$ &lt; 360.</p>\n<p>Accepts '&deg;' and 'deg' as units.</p>\n<p>Penalizes if not close enough or no units.</p>\n<p>90&deg; = -270&deg; = 450&deg;</p>", "help_url": "", "input_widget": "string", "input_options": {"correctAnswer": "plain_string(settings['expected_answer']) ", "hint": {"static": true, "value": ""}, "allowEmpty": {"static": true, "value": false}}, "can_be_gap": true, "can_be_step": true, "marking_script": "original_student_scalar:\nmatchnumber(studentAnswer,['plain','en'])[1]\n\nstudent_scalar:\nmod(original_student_scalar,360)\n\n\nstudent_unit:\nstudentAnswer[len(matchnumber(studentAnswer,['plain','en'])[0])..len(studentAnswer)]\n\ninterpreted_unit:\nif(trim(student_unit)='\u00b0','deg',student_unit)\n\ninterpreted_answer:\nqty(mod(student_scalar,360),'deg')\n\nclose:\nwithintolerance(student_scalar, correct_scalar,decimal(settings['close_tol']))\n\ncorrect_scalar:\nmod(scalar(settings['expected_answer']),360)\n\nright:\nwithintolerance(student_scalar, correct_scalar, decimal(settings['right_tol']))\n\ngood_unit:\nsame(qty(1,interpreted_unit),qty(1,'deg'))\n\nmark:\nassert(close,incorrect('Incorrect.');end());\nif(right,correct('Correct angle.'), set_credit(1 - settings['close_penalty'],'Angle is close.'));\nassert(good_unit,sub_credit(settings['unit_penalty'], 'Missing or incorrect units.'))", "marking_notes": [{"name": "original_student_scalar", "description": "<p>Retuns the scalar part of students answer (which is a quantity) as a number.</p>", "definition": "matchnumber(studentAnswer,['plain','en'])[1]"}, {"name": "student_scalar", "description": "<p>Normalize angle with mod 360</p>", "definition": "mod(original_student_scalar,360)\n"}, {"name": "student_unit", "description": "<p>matchnumber(studentAnswer,['plain','en'])[0] is a string \"12.34\"</p>", "definition": "studentAnswer[len(matchnumber(studentAnswer,['plain','en'])[0])..len(studentAnswer)]"}, {"name": "interpreted_unit", "description": "<p>Allows student to use degree symbol or 'deg' for units.</p>", "definition": "if(trim(student_unit)='\u00b0','deg',student_unit)"}, {"name": "interpreted_answer", "description": "A value representing the student's answer to this part.", "definition": "qty(mod(student_scalar,360),'deg')"}, {"name": "close", "description": "", "definition": "withintolerance(student_scalar, correct_scalar,decimal(settings['close_tol']))"}, {"name": "correct_scalar", "description": "<p>Normalize expected_answer with mod 360</p>", "definition": "mod(scalar(settings['expected_answer']),360)"}, {"name": "right", "description": "", "definition": "withintolerance(student_scalar, correct_scalar, decimal(settings['right_tol']))"}, {"name": "good_unit", "description": "", "definition": "same(qty(1,interpreted_unit),qty(1,'deg'))"}, {"name": "mark", "description": "This is the main marking note. It should award credit and provide feedback based on the student's answer.", "definition": "assert(close,incorrect('Incorrect.');end());\nif(right,correct('Correct angle.'), set_credit(1 - settings['close_penalty'],'Angle is close.'));\nassert(good_unit,sub_credit(settings['unit_penalty'], 'Missing or incorrect units.'))"}], "settings": [{"name": "expected_answer", "label": "Expected Answer", "help_url": "", "hint": "Expected angle as a quantity.", "input_type": "code", "default_value": "qty(30,'deg')", "evaluate": true}, {"name": "unit_penalty", "label": "Unit penalty", "help_url": "", "hint": "Penalty for not including degree sign or 'deg'.", "input_type": "percent", "default_value": "20"}, {"name": "close_penalty", "label": "Close Penalty", "help_url": "", "hint": "Penalty for close answer.", "input_type": "percent", "default_value": "20"}, {"name": "close_tol", "label": "Close", "help_url": "", "hint": "Angle must be $\\pm$ this many degrees to be marked close. &nbsp;&nbsp;", "input_type": "code", "default_value": "0.5", "evaluate": false}, {"name": "right_tol", "label": "Right ", "help_url": "", "hint": "Angle must be $\\pm$ this many degrees to be marked correct. &nbsp;", "input_type": "code", "default_value": "0.1", "evaluate": false}], "public_availability": "restricted", "published": false, "extensions": ["quantities"]}, {"source": {"pk": 19, "author": {"name": "William Haynes", "pk": 2530}, "edit_page": "/part_type/19/edit"}, "name": "Engineering Accuracy with units", "short_name": "engineering-answer", "description": "<p>A value with units marked right if within an adjustable % error of the correct value. &nbsp;Marked close if within a wider margin of error.</p>", "help_url": "", "input_widget": "string", "input_options": {"correctAnswer": "siground(settings['correctAnswer'],4)", "hint": {"static": true, "value": ""}, "allowEmpty": {"static": true, "value": true}}, "can_be_gap": true, "can_be_step": true, "marking_script": "mark:\nswitch( \n  right and good_units and right_sign, add_credit(1.0,'Correct.'),\n  right and good_units and not right_sign, add_credit(settings['C2'],'Wrong sign.'),\n  right and right_sign and not good_units, add_credit(settings['C2'],'Correct value, but wrong or missing units.'),\n  close and good_units, add_credit(settings['C1'],'Close.'),\n  close and not good_units, add_credit(settings['C3'],'Answer is close, but wrong or missing units.'),\n  incorrect('Wrong answer.')\n)\n\n\ninterpreted_answer:\nqty(student_scalar, student_units)\n\n\n\ncorrect_quantity:\nsettings[\"correctAnswer\"]\n\n\n\ncorrect_units:\nunits(correct_quantity)\n\n\nallowed_notation_styles:\n[\"plain\",\"en\"]\n\nmatch_student_number:\nmatchnumber(studentAnswer,allowed_notation_styles)\n\nstudent_scalar:\nmatch_student_number[1]\n\nstudent_units:\nreplace_regex('ohms','ohm',\n  replace_regex('\u00b0', ' deg',\n    replace_regex('-', ' ' ,\n      studentAnswer[len(match_student_number[0])..len(studentAnswer)])),\"i\")\n\ngood_units:\ntry(\ncompatible(quantity(1, student_units),correct_units),\nmsg,\nfeedback(msg);false)\n\n\nstudent_quantity:\nswitch(not good_units, \n       student_scalar * correct_units, \n       not right_sign,\n       -quantity(student_scalar, student_units),\n       quantity(student_scalar,student_units)\n)\n  \n\n\npercent_error:\ntry(\nscalar(abs((correct_quantity - student_quantity)/correct_quantity))*100  \n,msg,\nif(student_quantity=correct_quantity,0,100))\n   \n\nright:\npercent_error <= settings['right']\n\n\nclose:\nright_sign and percent_error <= settings['close']\n\nright_sign:\nsign(student_scalar) = sign(correct_quantity)", "marking_notes": [{"name": "mark", "description": "This is the main marking note. It should award credit and provide feedback based on the student's answer.", "definition": "switch( \n  right and good_units and right_sign, add_credit(1.0,'Correct.'),\n  right and good_units and not right_sign, add_credit(settings['C2'],'Wrong sign.'),\n  right and right_sign and not good_units, add_credit(settings['C2'],'Correct value, but wrong or missing units.'),\n  close and good_units, add_credit(settings['C1'],'Close.'),\n  close and not good_units, add_credit(settings['C3'],'Answer is close, but wrong or missing units.'),\n  incorrect('Wrong answer.')\n)\n"}, {"name": "interpreted_answer", "description": "A value representing the student's answer to this part.", "definition": "qty(student_scalar, student_units)\n\n"}, {"name": "correct_quantity", "description": "", "definition": "settings[\"correctAnswer\"]\n\n"}, {"name": "correct_units", "description": "", "definition": "units(correct_quantity)\n"}, {"name": "allowed_notation_styles", "description": "", "definition": "[\"plain\",\"en\"]"}, {"name": "match_student_number", "description": "", "definition": "matchnumber(studentAnswer,allowed_notation_styles)"}, {"name": "student_scalar", "description": "", "definition": "match_student_number[1]"}, {"name": "student_units", "description": "<p>Modify&nbsp;the&nbsp;unit portion of&nbsp;the student's answer by</p>\n<p>1. replacing \"ohms\" with \"ohm\" &nbsp;case insensitive</p>\n<p>2.&nbsp;replacing '-'&nbsp;with ' '&nbsp;</p>\n<p>3. replacing '&deg;' with ' deg'&nbsp;</p>\n<p>to allow answers like 10 ft-lb and 30&deg;</p>", "definition": "replace_regex('ohms','ohm',\n  replace_regex('\u00b0', ' deg',\n    replace_regex('-', ' ' ,\n      studentAnswer[len(match_student_number[0])..len(studentAnswer)])),\"i\")"}, {"name": "good_units", "description": "", "definition": "try(\ncompatible(quantity(1, student_units),correct_units),\nmsg,\nfeedback(msg);false)\n"}, {"name": "student_quantity", "description": "<p>This fixes the student answer for two common errors. &nbsp;</p>\n<p>If student_units are wrong&nbsp;&nbsp;- replace with correct units</p>\n<p>If student_scalar has the wrong sign - replace with right sign</p>\n<p>If student makes both errors, only one gets fixed.</p>", "definition": "switch(not good_units, \n       student_scalar * correct_units, \n       not right_sign,\n       -quantity(student_scalar, student_units),\n       quantity(student_scalar,student_units)\n)\n  \n"}, {"name": "percent_error", "description": "", "definition": "try(\nscalar(abs((correct_quantity - student_quantity)/correct_quantity))*100  \n,msg,\nif(student_quantity=correct_quantity,0,100))\n   "}, {"name": "right", "description": "", "definition": "percent_error <= settings['right']\n"}, {"name": "close", "description": "<p>Only marked close if the student actually has the right sign.</p>", "definition": "right_sign and percent_error <= settings['close']"}, {"name": "right_sign", "description": "", "definition": "sign(student_scalar) = sign(correct_quantity) "}], "settings": [{"name": "correctAnswer", "label": "Correct Quantity.", "help_url": "", "hint": "The correct answer given as a JME quantity.", "input_type": "code", "default_value": "", "evaluate": true}, {"name": "right", "label": "% Accuracy for right.", "help_url": "", "hint": "Question will be considered correct if the scalar part of the student's answer is within this % of correct value.", "input_type": "code", "default_value": "0.2", "evaluate": true}, {"name": "close", "label": "% Accuracy for close.", "help_url": "", "hint": "Question will be considered close if the scalar part of the student's answer is within this % of correct value.", "input_type": "code", "default_value": "1.0", "evaluate": true}, {"name": "C1", "label": "Close with units.", "help_url": "", "hint": "Partial Credit for close value with appropriate units. &nbsp;if correct answer is 100 N and close is &plusmn;1%,<br />99 &nbsp;N is accepted.", "input_type": "percent", "default_value": "75"}, {"name": "C2", "label": "No units or wrong sign", "help_url": "", "hint": "Partial credit for forgetting units or using wrong sign.<br />If the correct answer is 100 N, both 100 and -100 N are accepted.", "input_type": "percent", "default_value": "50"}, {"name": "C3", "label": "Close, no units.", "help_url": "", "hint": "Partial Credit for close value but forgotten units.<br />This value would be close&nbsp;if the expected units were provided. &nbsp;If the correct answer is 100 N, and close is &plusmn;1%,<br />99 is accepted.", "input_type": "percent", "default_value": "25"}], "public_availability": "always", "published": true, "extensions": ["quantities"]}], "resources": [], "navigation": {"allowregen": true, "showfrontpage": false, "preventleave": false, "typeendtoleave": false}, "contributors": [{"name": "William Haynes", "profile_url": "https://numbas.mathcentre.ac.uk/accounts/profile/2530/"}], "tags": ["equivalent force-couple", "Mechanics", "mechanics", "Statics", "statics"], "metadata": {"description": "<p>Replace three tangential forces with an equivalent force-couple system acting at the center of a circle.</p>", "licence": "Creative Commons Attribution-NonCommercial 4.0 International"}, "statement": "<p>{applet}</p>\n<p>Replace the three forces acting tangent to a {radius} radius circle with an equivalent force-couple system acting at the center $O$.</p>\n<div data-jme-visible=\"false\">\n<p>forceA: {precround(forceA,3)}&nbsp;ThetaA: {thetaA}</p>\n<p>forceB: {precround(ForceB,3)}&nbsp;ThetaB: {thetaB}</p>\n<p>ForceC: {precround(ForceC,3)}&nbsp;ThetaC: {thetaC}</p>\n<p>magR: {magR} &nbsp;DirR: {dirR} Moment: {moment}</p>\n</div>", "advice": "<p>$M = \\Sigma M_O = {\\color{red}{M_A}} + {\\color{blue}{M_B}} + {\\color{green}{M_C}}&nbsp;&nbsp;= \\simplify[!collectnumbers]{{scalar(FA)}r&nbsp;+{scalar(FB)}(r) +{scalar(FC)}(r) }&nbsp;= \\var{display(moment)}$</p>\n<p>$R_x&nbsp;= \\Sigma&nbsp;F_x = {\\color{red}{A_x}} + {\\color{blue}{B_x}} + {\\color{green}{C_x}}&nbsp;&nbsp;=\\simplify[!collectnumbers] { {precround(forceA[0],2)} +&nbsp;{precround(forceB[0],2)} + {precround(forceC[0],2)}} =&nbsp;&nbsp;\\var{displayV(forceR[0])}$</p>\n<p>$R_y = \\Sigma&nbsp;F_y = {\\color{red}{A_y}} + {\\color{blue}{B_y}} + {\\color{green}{C_y}}&nbsp;&nbsp;=\\simplify[!collectnumbers] { {precround(forceA[1],2)} +&nbsp;{precround(forceB[1],2)} + {precround(forceC[1],2)}} =&nbsp;&nbsp;\\var{displayV(forceR[1])}$</p>\n<p>$R = \\sqrt{R_x^2 + R_y^2} = &nbsp;&nbsp;\\var{display(magR)}$</p>\n<p>$\\theta = \\tan^{-1} \\left(\\dfrac{R_y}{R_x}\\right) =\\var{dirR}&deg;$ from the positive x-axis.</p>", "rulesets": {}, "builtin_constants": {"e": true, "pi,\u03c0": true, "i": true}, "constants": [], "variables": {"Moment": {"name": "Moment", "group": "Ungrouped variables", "definition": "(FA+FB+FC)radius", "description": "", "templateType": "anything", "can_override": false}, "forceR": {"name": "forceR", "group": "Ungrouped variables", "definition": "forceA+forceB+forceC", "description": "", "templateType": "anything", "can_override": false}, "absMoment": {"name": "absMoment", "group": "Ungrouped variables", "definition": "(abs(moment))", "description": "", "templateType": "anything", "can_override": false}, "dirR": {"name": "dirR", "group": "Ungrouped variables", "definition": "precround(degrees(atan2(forceR[1],forceR[0])),4)", "description": "", "templateType": "anything", "can_override": false}, "theta": {"name": "theta", "group": "Inputs", "definition": "random(0..360#5 except [0,90,180,270,360])", "description": "", "templateType": "anything", "can_override": false}, "FC": {"name": "FC", "group": "Inputs", "definition": "random(1,-1)random(random(0..1#0.1)+random(1..5))FA", "description": "", "templateType": "anything", "can_override": false}, "forceA": {"name": "forceA", "group": "Ungrouped variables", "definition": "vector(cos(radians(theta+90)),sin(radians(theta+90))) scalar(FA)", "description": "", "templateType": "anything", "can_override": false}, "thetaA": {"name": "thetaA", "group": "Ungrouped variables", "definition": "theta + 90", "description": "", "templateType": "anything", "can_override": false}, "thetaB": {"name": "thetaB", "group": "Ungrouped variables", "definition": "If(theta < 60, 90, If(theta < 150, 180, If(theta < 240, 0, 90)))+90", "description": "", "templateType": "anything", "can_override": false}, "magR": {"name": "magR", "group": "Ungrouped variables", "definition": "quantity(precround(abs(forceR),4),units[1])", "description": "", "templateType": "anything", "can_override": false}, "thetaC": {"name": "thetaC", "group": "Ungrouped variables", "definition": "thetaB+90", "description": "", "templateType": "anything", "can_override": false}, "radius": {"name": "radius", "group": "Inputs", "definition": "round(quantity(random(4..24),'in') in units[0],quantity(1,units[0]))", "description": "", "templateType": "anything", "can_override": false}, "forceC": {"name": "forceC", "group": "Ungrouped variables", "definition": "vector(cos(radians(thetaC)),sin(radians(thetaC))) scalar(FC)", "description": "", "templateType": "anything", "can_override": false}, "forceB": {"name": "forceB", "group": "Ungrouped variables", "definition": "vector(cos(radians(thetaB)),sin(radians(thetaB))) scalar(FB)", "description": "", "templateType": "anything", "can_override": false}, "FB": {"name": "FB", "group": "Inputs", "definition": "random(1,-1)random(random(0..1#0.1)+random(1..5))FA", "description": "", "templateType": "anything", "can_override": false}, "units": {"name": "units", "group": "Inputs", "definition": "random(['ft','lb'],['mm','N'],['in','lb'],['cm','N'])", "description": "", "templateType": "anything", "can_override": false}, "FA": {"name": "FA", "group": "Inputs", "definition": "quantity(random(1,-1)random(2,3,4,5)random(2,5,10,20),units[1])", "description": "", "templateType": "anything", "can_override": false}, "params": {"name": "params", "group": "ggb", "definition": "['\u03b8_A': radians(theta), \nFA: scalar(FA), FB: scalar(FB), FC: scalar(FC), \nunits: '\"{units[1]}\"']\n", "description": "<p>{geogebra_applet('ukcfn9fm',[['&theta;_A',theta+'&deg;'],['FA',scalar(FA)],['FB',scalar(FB)],['FC',scalar(FC)],['units','\"'+plain_units_string(FA) +'\"']])}</p>", "templateType": "anything", "can_override": false}, "applet": {"name": "applet", "group": "ggb", "definition": "geogebra_applet('ukcfn9fm',params)", "description": "", "templateType": "anything", "can_override": false}}, "variablesTest": {"condition": "abs(sign(scalar(FA))+sign(scalar(FB))+sign(scalar(FC)))<>3", "maxRuns": 100}, "ungrouped_variables": ["thetaA", "thetaB", "thetaC", "Moment", "forceA", "forceC", "forceB", "forceR", "magR", "dirR", "absMoment"], "variable_groups": [{"name": "Inputs", "variables": ["theta", "FA", "FB", "FC", "units", "radius"]}, {"name": "ggb", "variables": ["params", "applet"]}], "functions": {"displayV": {"parameters": [["n", "number"]], "type": "string", "language": "jme", "definition": "display(qty(n,units[1]))"}, "display": {"parameters": [["q", "quantity"]], "type": "string", "language": "jme", "definition": "string(precround(q,3))"}}, "preamble": {"js": "", "css": ""}, "parts": [{"type": "gapfill", "useCustomName": true, "customName": "Force", "marks": 0, "scripts": {}, "customMarkingAlgorithm": "interpreted_angle:  // a qty string corrected to standard angle\n  student_angle[2]  + student_angle[1] * student_angle[0] + student_units\n\nmagnitude:\n  studentAnswer[3]\n\nstudent_angle:\n  [mod(matchnumber(studentAnswer[0],['plain','en'])[1],360), // angle\n  [1,-1][indices(studentAnswer[1],[true])[0]],      // ccw = 1 cw = -1\n  [0,90,180,-90][indices(studentAnswer[2],[true])[0]]] // reference axis\n\nstudent_units:\n  studentAnswer[0][len(matchnumber(studentAnswer[0],['plain','en'])[0])..len(studentAnswer[0])]\n\ninterpreted_answers:\n  [interpreted_angle, studentAnswer[1], studentAnswer[2], studentAnswer[3]]\n\ngap_feedback (Feedback on each of the gaps):\n    map(\n        try(\n            let(\n                result, submit_part(gaps[gap_number][\"path\"],answer),\n                gap, gaps[gap_number],\n                name, gap[\"name\"],  \n                noFeedbackIcon, not gap[\"settings\"][\"showFeedbackIcon\"],\n                assert(name=\"\" or len(gaps)=1,feedback(translate('part.gapfill.feedback header',[\"name\": name])));\n                concat_feedback(filter(x[\"op\"]<>\"warning\",x,result[\"feedback\"]), if(marks>0,result[\"marks\"]/marks,1), noFeedbackIcon);\n                    result\n            ),\n            err,\n            fail(translate(\"part.gapfill.error marking gap\",[\"name\": gaps[gap_number][\"name\"], \"message\": err]))\n        ),\n        [gap_number,answer,index],\n        zip([3,0],[studentAnswer[3], interpreted_angle],[1,2])\n    )\n\n\n", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": true, "showFeedbackIcon": true, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "prompt": "<p>The three forces may be replaced with a single force $\\mathbf{R}$ at $O$ where</p>\n<p>$\\mathbf{R} = $&nbsp;[[3]]</p>\n<p>at an angle of &nbsp;[[0]]&nbsp; measured&nbsp;[[1]] &nbsp;from the&nbsp;[[2]].</p>", "gaps": [{"type": "angle", "useCustomName": true, "customName": "Dir R", "marks": "10", "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": true, "showFeedbackIcon": false, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "settings": {"expected_answer": "qty(dirR,'deg')", "unit_penalty": "20", "close_penalty": "20", "close_tol": "0.5", "right_tol": "0.1"}}, {"type": "1_n_2", "useCustomName": true, "customName": "sign", "marks": 0, "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": false, "showFeedbackIcon": false, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "minMarks": 0, "maxMarks": 0, "shuffleChoices": true, "displayType": "dropdownlist", "displayColumns": 0, "showCellAnswerState": true, "choices": ["CCW", "CW"], "matrix": [0, 0], "distractors": ["", ""]}, {"type": "1_n_2", "useCustomName": true, "customName": "axis", "marks": 0, "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": false, "showFeedbackIcon": false, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "minMarks": 0, "maxMarks": 0, "shuffleChoices": false, "displayType": "dropdownlist", "displayColumns": 0, "showCellAnswerState": true, "choices": ["+x axis", "+y axis", "-x axis", "-y axis"], "matrix": [0, 0, 0, 0], "distractors": ["", "", "", ""]}, {"type": "engineering-answer", "useCustomName": true, "customName": "R", "marks": "10", "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": true, "showFeedbackIcon": true, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "settings": {"correctAnswer": "MagR", "right": "0.2", "close": "1.0", "C1": "75", "C2": "50", "C3": "25"}}], "sortAnswers": false}, {"type": "gapfill", "useCustomName": true, "customName": "Couple", "marks": 0, "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": true, "showFeedbackIcon": true, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "prompt": "<p>And with couple-moment&nbsp;$M$ =&nbsp;[[0]].</p>\n<p>(Use the standard sign convention to indicate the direction of the moment.)</p>", "gaps": [{"type": "engineering-answer", "useCustomName": true, "customName": "M", "marks": "10", "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": true, "showFeedbackIcon": true, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "settings": {"correctAnswer": "moment", "right": "0.2", "close": "1.0", "C1": "75", "C2": "50", "C3": "25"}}], "sortAnswers": false}], "partsMode": "all", "maxMarks": 0, "objectives": [], "penalties": [], "objectiveVisibility": "always", "penaltyVisibility": "always", "type": "question"}, {"name": "Equivalent Force-couple system: Bracket", "extensions": ["geogebra", "quantities"], "custom_part_types": [{"source": {"pk": 12, "author": {"name": "William Haynes", "pk": 2530}, "edit_page": "/part_type/12/edit"}, "name": "Angle quantity 2020", "short_name": "angle", "description": "<p>Adjusts all angles to 0 &lt; $\\theta$ &lt; 360.</p>\n<p>Accepts '&deg;' and 'deg' as units.</p>\n<p>Penalizes if not close enough or no units.</p>\n<p>90&deg; = -270&deg; = 450&deg;</p>", "help_url": "", "input_widget": "string", "input_options": {"correctAnswer": "plain_string(settings['expected_answer']) ", "hint": {"static": true, "value": ""}, "allowEmpty": {"static": true, "value": false}}, "can_be_gap": true, "can_be_step": true, "marking_script": "original_student_scalar:\nmatchnumber(studentAnswer,['plain','en'])[1]\n\nstudent_scalar:\nmod(original_student_scalar,360)\n\n\nstudent_unit:\nstudentAnswer[len(matchnumber(studentAnswer,['plain','en'])[0])..len(studentAnswer)]\n\ninterpreted_unit:\nif(trim(student_unit)='\u00b0','deg',student_unit)\n\ninterpreted_answer:\nqty(mod(student_scalar,360),'deg')\n\nclose:\nwithintolerance(student_scalar, correct_scalar,decimal(settings['close_tol']))\n\ncorrect_scalar:\nmod(scalar(settings['expected_answer']),360)\n\nright:\nwithintolerance(student_scalar, correct_scalar, decimal(settings['right_tol']))\n\ngood_unit:\nsame(qty(1,interpreted_unit),qty(1,'deg'))\n\nmark:\nassert(close,incorrect('Incorrect.');end());\nif(right,correct('Correct angle.'), set_credit(1 - settings['close_penalty'],'Angle is close.'));\nassert(good_unit,sub_credit(settings['unit_penalty'], 'Missing or incorrect units.'))", "marking_notes": [{"name": "original_student_scalar", "description": "<p>Retuns the scalar part of students answer (which is a quantity) as a number.</p>", "definition": "matchnumber(studentAnswer,['plain','en'])[1]"}, {"name": "student_scalar", "description": "<p>Normalize angle with mod 360</p>", "definition": "mod(original_student_scalar,360)\n"}, {"name": "student_unit", "description": "<p>matchnumber(studentAnswer,['plain','en'])[0] is a string \"12.34\"</p>", "definition": "studentAnswer[len(matchnumber(studentAnswer,['plain','en'])[0])..len(studentAnswer)]"}, {"name": "interpreted_unit", "description": "<p>Allows student to use degree symbol or 'deg' for units.</p>", "definition": "if(trim(student_unit)='\u00b0','deg',student_unit)"}, {"name": "interpreted_answer", "description": "A value representing the student's answer to this part.", "definition": "qty(mod(student_scalar,360),'deg')"}, {"name": "close", "description": "", "definition": "withintolerance(student_scalar, correct_scalar,decimal(settings['close_tol']))"}, {"name": "correct_scalar", "description": "<p>Normalize expected_answer with mod 360</p>", "definition": "mod(scalar(settings['expected_answer']),360)"}, {"name": "right", "description": "", "definition": "withintolerance(student_scalar, correct_scalar, decimal(settings['right_tol']))"}, {"name": "good_unit", "description": "", "definition": "same(qty(1,interpreted_unit),qty(1,'deg'))"}, {"name": "mark", "description": "This is the main marking note. It should award credit and provide feedback based on the student's answer.", "definition": "assert(close,incorrect('Incorrect.');end());\nif(right,correct('Correct angle.'), set_credit(1 - settings['close_penalty'],'Angle is close.'));\nassert(good_unit,sub_credit(settings['unit_penalty'], 'Missing or incorrect units.'))"}], "settings": [{"name": "expected_answer", "label": "Expected Answer", "help_url": "", "hint": "Expected angle as a quantity.", "input_type": "code", "default_value": "qty(30,'deg')", "evaluate": true}, {"name": "unit_penalty", "label": "Unit penalty", "help_url": "", "hint": "Penalty for not including degree sign or 'deg'.", "input_type": "percent", "default_value": "20"}, {"name": "close_penalty", "label": "Close Penalty", "help_url": "", "hint": "Penalty for close answer.", "input_type": "percent", "default_value": "20"}, {"name": "close_tol", "label": "Close", "help_url": "", "hint": "Angle must be $\\pm$ this many degrees to be marked close. &nbsp;&nbsp;", "input_type": "code", "default_value": "0.5", "evaluate": false}, {"name": "right_tol", "label": "Right ", "help_url": "", "hint": "Angle must be $\\pm$ this many degrees to be marked correct. &nbsp;", "input_type": "code", "default_value": "0.1", "evaluate": false}], "public_availability": "restricted", "published": false, "extensions": ["quantities"]}, {"source": {"pk": 19, "author": {"name": "William Haynes", "pk": 2530}, "edit_page": "/part_type/19/edit"}, "name": "Engineering Accuracy with units", "short_name": "engineering-answer", "description": "<p>A value with units marked right if within an adjustable % error of the correct value. &nbsp;Marked close if within a wider margin of error.</p>", "help_url": "", "input_widget": "string", "input_options": {"correctAnswer": "siground(settings['correctAnswer'],4)", "hint": {"static": true, "value": ""}, "allowEmpty": {"static": true, "value": true}}, "can_be_gap": true, "can_be_step": true, "marking_script": "mark:\nswitch( \n  right and good_units and right_sign, add_credit(1.0,'Correct.'),\n  right and good_units and not right_sign, add_credit(settings['C2'],'Wrong sign.'),\n  right and right_sign and not good_units, add_credit(settings['C2'],'Correct value, but wrong or missing units.'),\n  close and good_units, add_credit(settings['C1'],'Close.'),\n  close and not good_units, add_credit(settings['C3'],'Answer is close, but wrong or missing units.'),\n  incorrect('Wrong answer.')\n)\n\n\ninterpreted_answer:\nqty(student_scalar, student_units)\n\n\n\ncorrect_quantity:\nsettings[\"correctAnswer\"]\n\n\n\ncorrect_units:\nunits(correct_quantity)\n\n\nallowed_notation_styles:\n[\"plain\",\"en\"]\n\nmatch_student_number:\nmatchnumber(studentAnswer,allowed_notation_styles)\n\nstudent_scalar:\nmatch_student_number[1]\n\nstudent_units:\nreplace_regex('ohms','ohm',\n  replace_regex('\u00b0', ' deg',\n    replace_regex('-', ' ' ,\n      studentAnswer[len(match_student_number[0])..len(studentAnswer)])),\"i\")\n\ngood_units:\ntry(\ncompatible(quantity(1, student_units),correct_units),\nmsg,\nfeedback(msg);false)\n\n\nstudent_quantity:\nswitch(not good_units, \n       student_scalar * correct_units, \n       not right_sign,\n       -quantity(student_scalar, student_units),\n       quantity(student_scalar,student_units)\n)\n  \n\n\npercent_error:\ntry(\nscalar(abs((correct_quantity - student_quantity)/correct_quantity))*100  \n,msg,\nif(student_quantity=correct_quantity,0,100))\n   \n\nright:\npercent_error <= settings['right']\n\n\nclose:\nright_sign and percent_error <= settings['close']\n\nright_sign:\nsign(student_scalar) = sign(correct_quantity)", "marking_notes": [{"name": "mark", "description": "This is the main marking note. It should award credit and provide feedback based on the student's answer.", "definition": "switch( \n  right and good_units and right_sign, add_credit(1.0,'Correct.'),\n  right and good_units and not right_sign, add_credit(settings['C2'],'Wrong sign.'),\n  right and right_sign and not good_units, add_credit(settings['C2'],'Correct value, but wrong or missing units.'),\n  close and good_units, add_credit(settings['C1'],'Close.'),\n  close and not good_units, add_credit(settings['C3'],'Answer is close, but wrong or missing units.'),\n  incorrect('Wrong answer.')\n)\n"}, {"name": "interpreted_answer", "description": "A value representing the student's answer to this part.", "definition": "qty(student_scalar, student_units)\n\n"}, {"name": "correct_quantity", "description": "", "definition": "settings[\"correctAnswer\"]\n\n"}, {"name": "correct_units", "description": "", "definition": "units(correct_quantity)\n"}, {"name": "allowed_notation_styles", "description": "", "definition": "[\"plain\",\"en\"]"}, {"name": "match_student_number", "description": "", "definition": "matchnumber(studentAnswer,allowed_notation_styles)"}, {"name": "student_scalar", "description": "", "definition": "match_student_number[1]"}, {"name": "student_units", "description": "<p>Modify&nbsp;the&nbsp;unit portion of&nbsp;the student's answer by</p>\n<p>1. replacing \"ohms\" with \"ohm\" &nbsp;case insensitive</p>\n<p>2.&nbsp;replacing '-'&nbsp;with ' '&nbsp;</p>\n<p>3. replacing '&deg;' with ' deg'&nbsp;</p>\n<p>to allow answers like 10 ft-lb and 30&deg;</p>", "definition": "replace_regex('ohms','ohm',\n  replace_regex('\u00b0', ' deg',\n    replace_regex('-', ' ' ,\n      studentAnswer[len(match_student_number[0])..len(studentAnswer)])),\"i\")"}, {"name": "good_units", "description": "", "definition": "try(\ncompatible(quantity(1, student_units),correct_units),\nmsg,\nfeedback(msg);false)\n"}, {"name": "student_quantity", "description": "<p>This fixes the student answer for two common errors. &nbsp;</p>\n<p>If student_units are wrong&nbsp;&nbsp;- replace with correct units</p>\n<p>If student_scalar has the wrong sign - replace with right sign</p>\n<p>If student makes both errors, only one gets fixed.</p>", "definition": "switch(not good_units, \n       student_scalar * correct_units, \n       not right_sign,\n       -quantity(student_scalar, student_units),\n       quantity(student_scalar,student_units)\n)\n  \n"}, {"name": "percent_error", "description": "", "definition": "try(\nscalar(abs((correct_quantity - student_quantity)/correct_quantity))*100  \n,msg,\nif(student_quantity=correct_quantity,0,100))\n   "}, {"name": "right", "description": "", "definition": "percent_error <= settings['right']\n"}, {"name": "close", "description": "<p>Only marked close if the student actually has the right sign.</p>", "definition": "right_sign and percent_error <= settings['close']"}, {"name": "right_sign", "description": "", "definition": "sign(student_scalar) = sign(correct_quantity) "}], "settings": [{"name": "correctAnswer", "label": "Correct Quantity.", "help_url": "", "hint": "The correct answer given as a JME quantity.", "input_type": "code", "default_value": "", "evaluate": true}, {"name": "right", "label": "% Accuracy for right.", "help_url": "", "hint": "Question will be considered correct if the scalar part of the student's answer is within this % of correct value.", "input_type": "code", "default_value": "0.2", "evaluate": true}, {"name": "close", "label": "% Accuracy for close.", "help_url": "", "hint": "Question will be considered close if the scalar part of the student's answer is within this % of correct value.", "input_type": "code", "default_value": "1.0", "evaluate": true}, {"name": "C1", "label": "Close with units.", "help_url": "", "hint": "Partial Credit for close value with appropriate units. &nbsp;if correct answer is 100 N and close is &plusmn;1%,<br />99 &nbsp;N is accepted.", "input_type": "percent", "default_value": "75"}, {"name": "C2", "label": "No units or wrong sign", "help_url": "", "hint": "Partial credit for forgetting units or using wrong sign.<br />If the correct answer is 100 N, both 100 and -100 N are accepted.", "input_type": "percent", "default_value": "50"}, {"name": "C3", "label": "Close, no units.", "help_url": "", "hint": "Partial Credit for close value but forgotten units.<br />This value would be close&nbsp;if the expected units were provided. &nbsp;If the correct answer is 100 N, and close is &plusmn;1%,<br />99 is accepted.", "input_type": "percent", "default_value": "25"}], "public_availability": "always", "published": true, "extensions": ["quantities"]}], "resources": [], "navigation": {"allowregen": true, "showfrontpage": false, "preventleave": false, "typeendtoleave": false}, "contributors": [{"name": "William Haynes", "profile_url": "https://numbas.mathcentre.ac.uk/accounts/profile/2530/"}], "tags": ["equivalent force-couple system", "Mechanics", "mechanics", "Statics", "statics"], "metadata": {"description": "<p>Replace two forces with a equivalent force-couple system at a specified point.</p>", "licence": "Creative Commons Attribution-NonCommercial 4.0 International"}, "statement": "<p>&nbsp;{applet}</p>", "advice": "<p>1. &nbsp;Replace forces $A$ and $D$ with a single equivalent force $\\mathbf{B} = \\mathbf{A} + \\mathbf{D}$ acting at point $B$. &nbsp;</p>\n<p>This force will have the same translational effect as the original systems, therefore:&nbsp;</p>\n<p style=\"padding-left: 40px;\">$B_x = A_x + D_x = + \\var{A} \\cos \\var{abs(theta)}&deg; &nbsp;+ 0 &nbsp;= \\var{ea(B[0])}$ {units}</p>\n<p style=\"padding-left: 40px;\">$B_y = A_y + D_y =\\var{latex( if(theta &gt;=0, \"+\", \"-\"))} \\var{A} \\sin \\var{abs(theta)}&deg; &nbsp;- D &nbsp;= \\var{ea(B[1])}$ {units}</p>\n<p style=\"padding-left: 40px;\">$B = \\sqrt{B_x^2 + B_y^2} = \\var{ea(abs(B))}$ {units}</p>\n<p style=\"padding-left: 40px;\">$\\beta =\\tan^{-1}\\left( \\left \\vert\\frac{ \\var{ea(B[1])}} {\\var{ea(B[0])}}\\right \\vert \\right) = \\var{ea(abs(beta))}&deg; $</p>\n<p>2. Force $\\mathbf{B}$ acting at point $B$ produces no moment about that point, so a concentrated moment $\\mathbf{M}$ must be included to maintain equivalence.</p>\n<p>The magnitude and direction of this moment is equal to the moment produced by the original forces $A$ and $D$ about point $B$.</p>\n<p style=\"padding-left: 40px;\">$\\begin{align}M &amp;= \\pm A_x(\\var{yB}) \\pm A_y(\\var{xA}) \\pm D_x(\\var{yb}) \\pm D_y (0)&nbsp;<br/>\\\\&amp;= + (\\var{ea(vecA[0])} \\text{ lb})&nbsp;( \\var{yb}\\text{ in}) \\var{latex( if(theta &gt;=0, \"+\", \"-\"))} (\\var{abs(ea(vecA[1]))}\\text{ lb}) (\\var{xA} \\text{ in}) + (0)(\\var{yb} \\text{ in}) + (\\var{D}\\text{ lb})( 0)<br/>\\\\&amp;= \\var{latex( if(M &gt;=0, \"+\", \"-\"))} \\var{ea(abs(M))} \\text{ in-lb} <br/>\\\\&amp;= \\var{abs(ea(M))} &nbsp;\\text{ in-lb } \\var{if(M&gt;=0,\" CCW\",\" CW\")} \\end{align}$</p>", "rulesets": {}, "builtin_constants": {"e": true, "pi,\u03c0": true, "i": true}, "constants": [], "variables": {"applet": {"name": "applet", "group": "Ungrouped variables", "definition": "geogebra_applet('vgcucds9',params)", "description": "", "templateType": "anything", "can_override": false}, "xa": {"name": "xa", "group": "Unnamed group", "definition": "random(2.5..5#0.25)", "description": "<p>x coord of point A &nbsp;(origin at D)</p>", "templateType": "anything", "can_override": false}, "yb": {"name": "yb", "group": "Unnamed group", "definition": "random(4..7#0.5)", "description": "<p>y coordinate of point B (origin at D)</p>", "templateType": "anything", "can_override": false}, "yc": {"name": "yc", "group": "Unnamed group", "definition": "yb - random(2..3#0.25)", "description": "<p>y coordinate of point X (origin at D)</p>", "templateType": "anything", "can_override": false}, "theta": {"name": "theta", "group": "Unnamed group", "definition": "random(-70..70#10)", "description": "<p>direction of force at A</p>", "templateType": "anything", "can_override": false}, "params": {"name": "params", "group": "Ungrouped variables", "definition": "[xa: xa, yb: yb, yc: yc, theta: radians(theta), magA: A, magD: D, show: 'false']", "description": "<p>show changed to true when advice is displayed</p>", "templateType": "anything", "can_override": false}, "units": {"name": "units", "group": "Unnamed group", "definition": "\"lb\"", "description": "<p>force units, &nbsp;length unit assumed are assumed inches.</p>", "templateType": "anything", "can_override": false}, "A": {"name": "A", "group": "Unnamed group", "definition": "random(100..200#10)", "description": "<p>magnitude of force at A</p>", "templateType": "anything", "can_override": false}, "D": {"name": "D", "group": "Unnamed group", "definition": "random(A/2..150#10)", "description": "<p>magnitude of force a D, always straigt down.</p>", "templateType": "anything", "can_override": false}, "B": {"name": "B", "group": "solution", "definition": "vector(A cos(radians(theta)), A sin(radians(theta)) - D)", "description": "<p>Resultant of A + D</p>", "templateType": "anything", "can_override": false}, "M": {"name": "M", "group": "solution", "definition": "cross(vector(xa, -yb, 0),vector(A cos(radians(theta)), A sin(radians(theta)), 0))[2]", "description": "<p>moment of A about B</p>", "templateType": "anything", "can_override": false}, "beta": {"name": "beta", "group": "solution", "definition": "degrees(atan2(B[1],B[0]))", "description": "<p>direction of force B, standard angle</p>", "templateType": "anything", "can_override": false}, "vecA": {"name": "vecA", "group": "solution", "definition": "A vector(cos(radians(theta)), sin(radians(theta)))", "description": "<p>force A, as vector</p>", "templateType": "anything", "can_override": false}, "debug": {"name": "debug", "group": "Ungrouped variables", "definition": "false", "description": "", "templateType": "anything", "can_override": false}}, "variablesTest": {"condition": "", "maxRuns": 100}, "ungrouped_variables": ["applet", "params", "debug"], "variable_groups": [{"name": "Unnamed group", "variables": ["xa", "yb", "yc", "theta", "units", "A", "D"]}, {"name": "solution", "variables": ["B", "M", "beta", "vecA"]}], "functions": {"EA": {"parameters": [["n", "number"]], "type": "anything", "language": "jme", "definition": "if(abs(N) < 10^(-10), precround(n,2) , siground(n,3))"}}, "preamble": {"js": "question.signals.on('adviceDisplayed',function() {\n  try{\n    var app = question.scope.variables.applet.app;  \n    app.setValue(\"show\", true);\n  }\n  catch(err){}  \n})\n", "css": ""}, "parts": [{"type": "information", "useCustomName": false, "customName": "", "marks": 0, "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": true, "showFeedbackIcon": true, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "prompt": "<p>Replace the forces acting at $A$ and $D$ with an equivalent force-couple system acting at point $B$.</p>"}, {"type": "gapfill", "useCustomName": true, "customName": "Force", "marks": 0, "scripts": {}, "customMarkingAlgorithm": "interpreted_angle:  // a qty string corrected to standard angle\n  student_angle[2]  + student_angle[1] * student_angle[0] + student_units\n\nmagnitude:\n  studentAnswer[3]\n\nstudent_angle:\n  [mod(matchnumber(studentAnswer[0],['plain','en'])[1],360), // angle\n  [1,-1][indices(studentAnswer[1],[true])[0]],      // ccw = 1 cw = -1\n  [0,90,180,-90][indices(studentAnswer[2],[true])[0]]] // reference axis\n\nstudent_units:\n  studentAnswer[0][len(matchnumber(studentAnswer[0],['plain','en'])[0])..len(studentAnswer[0])]\n\ninterpreted_answers:\n  [interpreted_angle, studentAnswer[1], studentAnswer[2], studentAnswer[3]]\n\ngap_feedback (Feedback on each of the gaps):\n    map(\n        try(\n            let(\n                result, submit_part(gaps[gap_number][\"path\"],answer),\n                gap, gaps[gap_number],\n                name, gap[\"name\"],  \n                noFeedbackIcon, not gap[\"settings\"][\"showFeedbackIcon\"],\n                assert(name=\"\" or len(gaps)=1,feedback(translate('part.gapfill.feedback header',[\"name\": name])));\n                concat_feedback(filter(x[\"op\"]<>\"warning\",x,result[\"feedback\"]), if(marks>0,result[\"marks\"]/marks,1), noFeedbackIcon);\n                    result\n            ),\n            err,\n            fail(translate(\"part.gapfill.error marking gap\",[\"name\": gaps[gap_number][\"name\"], \"message\": err]))\n        ),\n        [gap_number,answer,index],\n        zip([3,0],[studentAnswer[3], interpreted_angle],[1,2])\n    )\n\n", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": true, "showFeedbackIcon": true, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "prompt": "<p>$\\mathbf{B}$ = [[3]]acting at a&nbsp;[[0]]&nbsp;angle measured&nbsp;[[1]] from the&nbsp;[[2]].</p>\n<p><span data-jme-visible=\"debug\" style=\"background-color: aliceblue;\">{ea(abs(B))} lb, {ea(beta)}&deg;</span></p>", "gaps": [{"type": "angle", "useCustomName": true, "customName": "angle", "marks": "10", "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": true, "showFeedbackIcon": false, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "settings": {"expected_answer": "qty(ea(beta),'deg')", "unit_penalty": "20", "close_penalty": "20", "close_tol": "0.5", "right_tol": "0.1"}}, {"type": "1_n_2", "useCustomName": true, "customName": "dir", "marks": 0, "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": true, "showFeedbackIcon": true, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "minMarks": 0, "maxMarks": 0, "shuffleChoices": false, "displayType": "dropdownlist", "displayColumns": 0, "showCellAnswerState": true, "choices": ["CCW", "CW"], "matrix": [0, 0], "distractors": ["", ""]}, {"type": "1_n_2", "useCustomName": true, "customName": "ref", "marks": 0, "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": true, "showFeedbackIcon": true, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "minMarks": 0, "maxMarks": 0, "shuffleChoices": false, "displayType": "dropdownlist", "displayColumns": 0, "showCellAnswerState": true, "choices": ["Positive x axis", "Positive y axis", "Negative x axis", "Negative y axis"], "matrix": [0, 0, 0, 0], "distractors": ["", "", "", ""]}, {"type": "engineering-answer", "useCustomName": true, "customName": "Magnitude", "marks": "10", "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": true, "showFeedbackIcon": true, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "settings": {"correctAnswer": "qty(abs(B), units)", "right": "0.2", "close": "1.0", "C1": "75", "C2": "50", "C3": "25"}}], "sortAnswers": false}, {"type": "gapfill", "useCustomName": true, "customName": "Couple", "marks": 0, "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": true, "showFeedbackIcon": true, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "prompt": "<p>$\\mathbf{M}$=&nbsp;[[0]]in the [[1]]&nbsp;direction.</p>\n<p>&nbsp;<span data-jme-visible=\"debug\">{qty(ea(abs(M)),'in*lb')}</span></p>", "gaps": [{"type": "engineering-answer", "useCustomName": true, "customName": "Magnitude", "marks": "10", "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": true, "showFeedbackIcon": true, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "settings": {"correctAnswer": "qty(ea(abs(M)),'in lb')", "right": "0.2", "close": "1.0", "C1": "75", "C2": "50", "C3": "25"}}, {"type": "1_n_2", "useCustomName": true, "customName": "Direction", "marks": 0, "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": true, "showFeedbackIcon": true, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "minMarks": 0, "maxMarks": 0, "shuffleChoices": true, "displayType": "dropdownlist", "displayColumns": 0, "showCellAnswerState": true, "choices": ["CW", "CCW"], "matrix": ["if(m<=0,5,0)", "if(M>=0,5,0)"], "distractors": ["", ""]}], "sortAnswers": false}], "partsMode": "all", "maxMarks": 0, "objectives": [], "penalties": [], "objectiveVisibility": "always", "penaltyVisibility": "always", "type": "question"}, {"name": "Resultant of a force-couple system", "extensions": ["geogebra", "quantities"], "custom_part_types": [{"source": {"pk": 12, "author": {"name": "William Haynes", "pk": 2530}, "edit_page": "/part_type/12/edit"}, "name": "Angle quantity 2020", "short_name": "angle", "description": "<p>Adjusts all angles to 0 &lt; $\\theta$ &lt; 360.</p>\n<p>Accepts '&deg;' and 'deg' as units.</p>\n<p>Penalizes if not close enough or no units.</p>\n<p>90&deg; = -270&deg; = 450&deg;</p>", "help_url": "", "input_widget": "string", "input_options": {"correctAnswer": "plain_string(settings['expected_answer']) ", "hint": {"static": true, "value": ""}, "allowEmpty": {"static": true, "value": false}}, "can_be_gap": true, "can_be_step": true, "marking_script": "original_student_scalar:\nmatchnumber(studentAnswer,['plain','en'])[1]\n\nstudent_scalar:\nmod(original_student_scalar,360)\n\n\nstudent_unit:\nstudentAnswer[len(matchnumber(studentAnswer,['plain','en'])[0])..len(studentAnswer)]\n\ninterpreted_unit:\nif(trim(student_unit)='\u00b0','deg',student_unit)\n\ninterpreted_answer:\nqty(mod(student_scalar,360),'deg')\n\nclose:\nwithintolerance(student_scalar, correct_scalar,decimal(settings['close_tol']))\n\ncorrect_scalar:\nmod(scalar(settings['expected_answer']),360)\n\nright:\nwithintolerance(student_scalar, correct_scalar, decimal(settings['right_tol']))\n\ngood_unit:\nsame(qty(1,interpreted_unit),qty(1,'deg'))\n\nmark:\nassert(close,incorrect('Incorrect.');end());\nif(right,correct('Correct angle.'), set_credit(1 - settings['close_penalty'],'Angle is close.'));\nassert(good_unit,sub_credit(settings['unit_penalty'], 'Missing or incorrect units.'))", "marking_notes": [{"name": "original_student_scalar", "description": "<p>Retuns the scalar part of students answer (which is a quantity) as a number.</p>", "definition": "matchnumber(studentAnswer,['plain','en'])[1]"}, {"name": "student_scalar", "description": "<p>Normalize angle with mod 360</p>", "definition": "mod(original_student_scalar,360)\n"}, {"name": "student_unit", "description": "<p>matchnumber(studentAnswer,['plain','en'])[0] is a string \"12.34\"</p>", "definition": "studentAnswer[len(matchnumber(studentAnswer,['plain','en'])[0])..len(studentAnswer)]"}, {"name": "interpreted_unit", "description": "<p>Allows student to use degree symbol or 'deg' for units.</p>", "definition": "if(trim(student_unit)='\u00b0','deg',student_unit)"}, {"name": "interpreted_answer", "description": "A value representing the student's answer to this part.", "definition": "qty(mod(student_scalar,360),'deg')"}, {"name": "close", "description": "", "definition": "withintolerance(student_scalar, correct_scalar,decimal(settings['close_tol']))"}, {"name": "correct_scalar", "description": "<p>Normalize expected_answer with mod 360</p>", "definition": "mod(scalar(settings['expected_answer']),360)"}, {"name": "right", "description": "", "definition": "withintolerance(student_scalar, correct_scalar, decimal(settings['right_tol']))"}, {"name": "good_unit", "description": "", "definition": "same(qty(1,interpreted_unit),qty(1,'deg'))"}, {"name": "mark", "description": "This is the main marking note. It should award credit and provide feedback based on the student's answer.", "definition": "assert(close,incorrect('Incorrect.');end());\nif(right,correct('Correct angle.'), set_credit(1 - settings['close_penalty'],'Angle is close.'));\nassert(good_unit,sub_credit(settings['unit_penalty'], 'Missing or incorrect units.'))"}], "settings": [{"name": "expected_answer", "label": "Expected Answer", "help_url": "", "hint": "Expected angle as a quantity.", "input_type": "code", "default_value": "qty(30,'deg')", "evaluate": true}, {"name": "unit_penalty", "label": "Unit penalty", "help_url": "", "hint": "Penalty for not including degree sign or 'deg'.", "input_type": "percent", "default_value": "20"}, {"name": "close_penalty", "label": "Close Penalty", "help_url": "", "hint": "Penalty for close answer.", "input_type": "percent", "default_value": "20"}, {"name": "close_tol", "label": "Close", "help_url": "", "hint": "Angle must be $\\pm$ this many degrees to be marked close. &nbsp;&nbsp;", "input_type": "code", "default_value": "0.5", "evaluate": false}, {"name": "right_tol", "label": "Right ", "help_url": "", "hint": "Angle must be $\\pm$ this many degrees to be marked correct. &nbsp;", "input_type": "code", "default_value": "0.1", "evaluate": false}], "public_availability": "restricted", "published": false, "extensions": ["quantities"]}, {"source": {"pk": 19, "author": {"name": "William Haynes", "pk": 2530}, "edit_page": "/part_type/19/edit"}, "name": "Engineering Accuracy with units", "short_name": "engineering-answer", "description": "<p>A value with units marked right if within an adjustable % error of the correct value. &nbsp;Marked close if within a wider margin of error.</p>", "help_url": "", "input_widget": "string", "input_options": {"correctAnswer": "siground(settings['correctAnswer'],4)", "hint": {"static": true, "value": ""}, "allowEmpty": {"static": true, "value": true}}, "can_be_gap": true, "can_be_step": true, "marking_script": "mark:\nswitch( \n  right and good_units and right_sign, add_credit(1.0,'Correct.'),\n  right and good_units and not right_sign, add_credit(settings['C2'],'Wrong sign.'),\n  right and right_sign and not good_units, add_credit(settings['C2'],'Correct value, but wrong or missing units.'),\n  close and good_units, add_credit(settings['C1'],'Close.'),\n  close and not good_units, add_credit(settings['C3'],'Answer is close, but wrong or missing units.'),\n  incorrect('Wrong answer.')\n)\n\n\ninterpreted_answer:\nqty(student_scalar, student_units)\n\n\n\ncorrect_quantity:\nsettings[\"correctAnswer\"]\n\n\n\ncorrect_units:\nunits(correct_quantity)\n\n\nallowed_notation_styles:\n[\"plain\",\"en\"]\n\nmatch_student_number:\nmatchnumber(studentAnswer,allowed_notation_styles)\n\nstudent_scalar:\nmatch_student_number[1]\n\nstudent_units:\nreplace_regex('ohms','ohm',\n  replace_regex('\u00b0', ' deg',\n    replace_regex('-', ' ' ,\n      studentAnswer[len(match_student_number[0])..len(studentAnswer)])),\"i\")\n\ngood_units:\ntry(\ncompatible(quantity(1, student_units),correct_units),\nmsg,\nfeedback(msg);false)\n\n\nstudent_quantity:\nswitch(not good_units, \n       student_scalar * correct_units, \n       not right_sign,\n       -quantity(student_scalar, student_units),\n       quantity(student_scalar,student_units)\n)\n  \n\n\npercent_error:\ntry(\nscalar(abs((correct_quantity - student_quantity)/correct_quantity))*100  \n,msg,\nif(student_quantity=correct_quantity,0,100))\n   \n\nright:\npercent_error <= settings['right']\n\n\nclose:\nright_sign and percent_error <= settings['close']\n\nright_sign:\nsign(student_scalar) = sign(correct_quantity)", "marking_notes": [{"name": "mark", "description": "This is the main marking note. It should award credit and provide feedback based on the student's answer.", "definition": "switch( \n  right and good_units and right_sign, add_credit(1.0,'Correct.'),\n  right and good_units and not right_sign, add_credit(settings['C2'],'Wrong sign.'),\n  right and right_sign and not good_units, add_credit(settings['C2'],'Correct value, but wrong or missing units.'),\n  close and good_units, add_credit(settings['C1'],'Close.'),\n  close and not good_units, add_credit(settings['C3'],'Answer is close, but wrong or missing units.'),\n  incorrect('Wrong answer.')\n)\n"}, {"name": "interpreted_answer", "description": "A value representing the student's answer to this part.", "definition": "qty(student_scalar, student_units)\n\n"}, {"name": "correct_quantity", "description": "", "definition": "settings[\"correctAnswer\"]\n\n"}, {"name": "correct_units", "description": "", "definition": "units(correct_quantity)\n"}, {"name": "allowed_notation_styles", "description": "", "definition": "[\"plain\",\"en\"]"}, {"name": "match_student_number", "description": "", "definition": "matchnumber(studentAnswer,allowed_notation_styles)"}, {"name": "student_scalar", "description": "", "definition": "match_student_number[1]"}, {"name": "student_units", "description": "<p>Modify&nbsp;the&nbsp;unit portion of&nbsp;the student's answer by</p>\n<p>1. replacing \"ohms\" with \"ohm\" &nbsp;case insensitive</p>\n<p>2.&nbsp;replacing '-'&nbsp;with ' '&nbsp;</p>\n<p>3. replacing '&deg;' with ' deg'&nbsp;</p>\n<p>to allow answers like 10 ft-lb and 30&deg;</p>", "definition": "replace_regex('ohms','ohm',\n  replace_regex('\u00b0', ' deg',\n    replace_regex('-', ' ' ,\n      studentAnswer[len(match_student_number[0])..len(studentAnswer)])),\"i\")"}, {"name": "good_units", "description": "", "definition": "try(\ncompatible(quantity(1, student_units),correct_units),\nmsg,\nfeedback(msg);false)\n"}, {"name": "student_quantity", "description": "<p>This fixes the student answer for two common errors. &nbsp;</p>\n<p>If student_units are wrong&nbsp;&nbsp;- replace with correct units</p>\n<p>If student_scalar has the wrong sign - replace with right sign</p>\n<p>If student makes both errors, only one gets fixed.</p>", "definition": "switch(not good_units, \n       student_scalar * correct_units, \n       not right_sign,\n       -quantity(student_scalar, student_units),\n       quantity(student_scalar,student_units)\n)\n  \n"}, {"name": "percent_error", "description": "", "definition": "try(\nscalar(abs((correct_quantity - student_quantity)/correct_quantity))*100  \n,msg,\nif(student_quantity=correct_quantity,0,100))\n   "}, {"name": "right", "description": "", "definition": "percent_error <= settings['right']\n"}, {"name": "close", "description": "<p>Only marked close if the student actually has the right sign.</p>", "definition": "right_sign and percent_error <= settings['close']"}, {"name": "right_sign", "description": "", "definition": "sign(student_scalar) = sign(correct_quantity) "}], "settings": [{"name": "correctAnswer", "label": "Correct Quantity.", "help_url": "", "hint": "The correct answer given as a JME quantity.", "input_type": "code", "default_value": "", "evaluate": true}, {"name": "right", "label": "% Accuracy for right.", "help_url": "", "hint": "Question will be considered correct if the scalar part of the student's answer is within this % of correct value.", "input_type": "code", "default_value": "0.2", "evaluate": true}, {"name": "close", "label": "% Accuracy for close.", "help_url": "", "hint": "Question will be considered close if the scalar part of the student's answer is within this % of correct value.", "input_type": "code", "default_value": "1.0", "evaluate": true}, {"name": "C1", "label": "Close with units.", "help_url": "", "hint": "Partial Credit for close value with appropriate units. &nbsp;if correct answer is 100 N and close is &plusmn;1%,<br />99 &nbsp;N is accepted.", "input_type": "percent", "default_value": "75"}, {"name": "C2", "label": "No units or wrong sign", "help_url": "", "hint": "Partial credit for forgetting units or using wrong sign.<br />If the correct answer is 100 N, both 100 and -100 N are accepted.", "input_type": "percent", "default_value": "50"}, {"name": "C3", "label": "Close, no units.", "help_url": "", "hint": "Partial Credit for close value but forgotten units.<br />This value would be close&nbsp;if the expected units were provided. &nbsp;If the correct answer is 100 N, and close is &plusmn;1%,<br />99 is accepted.", "input_type": "percent", "default_value": "25"}], "public_availability": "always", "published": true, "extensions": ["quantities"]}], "resources": [], "navigation": {"allowregen": true, "showfrontpage": false, "preventleave": false, "typeendtoleave": false}, "contributors": [{"name": "William Haynes", "profile_url": "https://numbas.mathcentre.ac.uk/accounts/profile/2530/"}], "tags": ["angle from reference", "force-couple", "Mechanics", "mechanics", "Resultant", "Statics", "statics"], "metadata": {"description": "<p>Determine the single force which is equivalent to a force and a couple.</p>", "licence": "Creative Commons Attribution-NonCommercial 4.0 International"}, "statement": "<p style=\"text-align: left;\">Replace the force-couple system acting at the origin with a single force which has the same effect. &nbsp;Specify the magnitude and direction of the resultant force and the coordinate <span data-jme-visible=\"version=0\">$x_A$</span> <span data-jme-visible=\"version=1\">$y_A$</span> of the point on the <span data-jme-visible=\"version=0\">$x$-axis</span> <span data-jme-visible=\"version=1\">$y$-axis</span> through which the line of action of this force passes.</p>\n<p style=\"text-align: left;\">{applet}</p>\n<div data-jme-visible=\"debug\">\n<p>F: {F} Fx: {Fx} Fy: {Fy}</p>\n<p>M: &nbsp;{M} $x_A$: {dx} $y_A$: {dy}</p>\n</div>", "advice": "<p>The equivalent force has the same magnitude and direction as the original force, but its line of action must be changed in such a way as to produce the same moment about <em>A</em> with the same direction as&nbsp;the original moment <em>M</em>. &nbsp;You may move the force horizontally to $x_A$ where $F_y x_A = M$ or vertically to&nbsp;$y_A$ where $F_y y_A = M$.</p>", "rulesets": {}, "builtin_constants": {"e": true, "pi,\u03c0": true, "i": true}, "constants": [], "variables": {"dy": {"name": "dy", "group": "Ungrouped variables", "definition": "siground(-1*M/Fx,3)", "description": "", "templateType": "anything", "can_override": false}, "version": {"name": "version", "group": "Ungrouped variables", "definition": "random(0..1)", "description": "", "templateType": "anything", "can_override": false}, "dx": {"name": "dx", "group": "Ungrouped variables", "definition": "siground(M/Fy,3)", "description": "", "templateType": "anything", "can_override": false}, "F": {"name": "F", "group": "Ungrouped variables", "definition": "quantity(random(1,2,3,4,5)*random(10,20,30,50),units[0])", "description": "", "templateType": "anything", "can_override": false}, "M": {"name": "M", "group": "Ungrouped variables", "definition": "Quantity(scalar(F)random(-1,1)random(1..6#0.1),units[0]+ \" \" +units[1])", "description": "<p>The moment. &nbsp;Counterclockwise is positive</p>", "templateType": "anything", "can_override": false}, "Fx": {"name": "Fx", "group": "Ungrouped variables", "definition": "F * cos(radians(alpha))", "description": "", "templateType": "anything", "can_override": false}, "Fy": {"name": "Fy", "group": "Ungrouped variables", "definition": "F * sin(radians(alpha))", "description": "", "templateType": "anything", "can_override": false}, "units": {"name": "units", "group": "Ungrouped variables", "definition": "random(['N','m'],['lb','in'],['lb','ft'])", "description": "", "templateType": "anything", "can_override": false}, "debug": {"name": "debug", "group": "Ungrouped variables", "definition": "false", "description": "", "templateType": "anything", "can_override": false}, "alpha": {"name": "alpha", "group": "Ungrouped variables", "definition": "random(0..360#10 except[0,90,180,270,360])", "description": "<p>the direction of the force</p>", "templateType": "anything", "can_override": false}, "applet": {"name": "applet", "group": "Unnamed group", "definition": "geogebra_applet('xfrg2ewr',params)", "description": "", "templateType": "anything", "can_override": false}, "params": {"name": "params", "group": "Unnamed group", "definition": "[\nF: scalar(F), M: scalar(M), \n'\u03b1': radians(alpha), \nunitsF: '\"{units[0]}\"', \nunitsD: '\"{units[1]}\"'\n]", "description": "", "templateType": "anything", "can_override": false}}, "variablesTest": {"condition": "", "maxRuns": 100}, "ungrouped_variables": ["F", "M", "alpha", "units", "Fx", "Fy", "dx", "dy", "version", "debug"], "variable_groups": [{"name": "Unnamed group", "variables": ["applet", "params"]}], "functions": {}, "preamble": {"js": "", "css": ""}, "parts": [{"type": "gapfill", "useCustomName": true, "customName": "Solution", "marks": 0, "scripts": {}, "customMarkingAlgorithm": "interpreted_angle:  // a qty string corrected to standard angle\n  student_angle[2]  + student_angle[1] * student_angle[0] + student_units\n\nmagnitude:\n  studentAnswer[3]\n\nstudent_angle:\n  [mod(matchnumber(studentAnswer[0],['plain','en'])[1],360), // angle\n  [1,-1][indices(studentAnswer[1],[true])[0]],      // ccw = 1 cw = -1\n  [0,90,180,-90][indices(studentAnswer[2],[true])[0]]] // reference axis\n\nstudent_units:\n  studentAnswer[0][len(matchnumber(studentAnswer[0],['plain','en'])[0])..len(studentAnswer[0])]\n\ninterpreted_answers:\n  [interpreted_angle, studentAnswer[1], studentAnswer[2], studentAnswer[3]]\n\ngap_feedback (Feedback on each of the gaps):\n    map(\n        try(\n            let(\n                result, submit_part(gaps[gap_number][\"path\"],answer),\n                gap, gaps[gap_number],\n                name, gap[\"name\"],  \n                noFeedbackIcon, not gap[\"settings\"][\"showFeedbackIcon\"],\n                assert(name=\"\" or len(gaps)=1,feedback(translate('part.gapfill.feedback header',[\"name\": name])));\n                concat_feedback(filter(x[\"op\"]<>\"warning\",x,result[\"feedback\"]), if(marks>0,result[\"marks\"]/marks,1), noFeedbackIcon);\n                    result\n            ),\n            err,\n            fail(translate(\"part.gapfill.error marking gap\",[\"name\": gaps[gap_number][\"name\"], \"message\": err]))\n        ),\n        [gap_number,answer,index],\n        zip([3,0,4],[studentAnswer[3], interpreted_angle, studentAnswer[4]],[1,2,3])\n    )", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": true, "showFeedbackIcon": true, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "prompt": "<p>The force and couple above can be replace with a single force with mangntude</p>\n<p>$F$ =&nbsp;[[3]]&nbsp;</p>\n<p>acting at an angle of&nbsp;[[0]]&nbsp;measured [[1]]&nbsp;from the [[2]], &nbsp;</p>\n<p>and passing through the <span data-jme-visible=\"version=0\">$x$-axis</span> <span data-jme-visible=\"version=1\">$y$-axis</span> at <span data-jme-visible=\"version=0\">$x_A$ </span>&nbsp;<span data-jme-visible=\"version=1\">$y_A$ </span> =&nbsp;[[4]].</p>", "gaps": [{"type": "angle", "useCustomName": true, "customName": "Angle", "marks": "10", "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": true, "showFeedbackIcon": false, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "settings": {"expected_answer": "qty(alpha,'deg')", "unit_penalty": "20", "close_penalty": "20", "close_tol": "0.5", "right_tol": "0.2"}}, {"type": "1_n_2", "useCustomName": true, "customName": "sign", "marks": 0, "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": false, "showFeedbackIcon": false, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "minMarks": 0, "maxMarks": 0, "shuffleChoices": false, "displayType": "dropdownlist", "displayColumns": 0, "showCellAnswerState": true, "choices": ["CCW", "CW"], "matrix": [0, 0], "distractors": ["", ""]}, {"type": "1_n_2", "useCustomName": true, "customName": "ref", "marks": 0, "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": false, "showFeedbackIcon": false, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "minMarks": 0, "maxMarks": 0, "shuffleChoices": false, "displayType": "dropdownlist", "displayColumns": 0, "showCellAnswerState": true, "choices": ["+x axis", "+y axis", "-x axis", "-y axis"], "matrix": [0, 0, 0, 0], "distractors": ["", "", "", ""]}, {"type": "engineering-answer", "useCustomName": true, "customName": "F", "marks": "10", "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": true, "showFeedbackIcon": true, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "settings": {"correctAnswer": "F", "right": "0.001", "close": "1.0", "C1": "75", "C2": "50", "C3": "25"}}, {"type": "engineering-answer", "useCustomName": true, "customName": "Intercept", "marks": "10", "scripts": {}, "customMarkingAlgorithm": "", "extendBaseMarkingAlgorithm": true, "unitTests": [], "showCorrectAnswer": true, "showFeedbackIcon": true, "variableReplacements": [], "variableReplacementStrategy": "originalfirst", "nextParts": [], "suggestGoingBack": false, "adaptiveMarkingPenalty": 0, "exploreObjective": null, "settings": {"correctAnswer": "if(version=0,dx,dy)", "right": "0.1", "close": "1.0", "C1": "75", "C2": "50", "C3": "25"}}], "sortAnswers": false}], "partsMode": "all", "maxMarks": 0, "objectives": [], "penalties": [], "objectiveVisibility": "always", "penaltyVisibility": "always", "type": "question"}]}], "allowPrinting": true, "navigation": {"allowregen": true, "reverse": true, "browse": true, "allowsteps": true, "showfrontpage": false, "navigatemode": "menu", "onleave": {"action": "none", "message": ""}, "preventleave": true, "typeendtoleave": false, "startpassword": "", "autoSubmit": true, "allowAttemptDownload": false, "downloadEncryptionKey": "", "showresultspage": "oncompletion"}, "timing": {"allowPause": true, "timeout": {"action": "none", "message": ""}, "timedwarning": {"action": "none", "message": ""}}, "feedback": {"enterreviewmodeimmediately": true, "showactualmarkwhen": "always", "showtotalmarkwhen": "always", "showanswerstatewhen": "always", "showpartfeedbackmessageswhen": "always", "showexpectedanswerswhen": "inreview", "showadvicewhen": "inreview", "allowrevealanswer": true, "intro": "", "end_message": "", "results_options": {"printquestions": true, "printadvice": true}, "feedbackmessages": [], "reviewshowexpectedanswer": true, "showanswerstate": true, "reviewshowfeedback": true, "showactualmark": true, "showtotalmark": true, "reviewshowscore": true, "reviewshowadvice": true}, "diagnostic": {"knowledge_graph": {"topics": [], "learning_objectives": []}, "script": "diagnosys", "customScript": ""}, "contributors": [{"name": "William Haynes", "profile_url": "https://numbas.mathcentre.ac.uk/accounts/profile/2530/"}], "extensions": ["geogebra", "quantities"], "custom_part_types": [{"source": {"pk": 24, "author": {"name": "William Haynes", "pk": 2530}, "edit_page": "/part_type/24/edit"}, "name": "Angle quantity", "short_name": "angle-quantity-from-reference", "description": "<p>Angle&nbsp;as a quantity in degrees.</p>", "help_url": "", "input_widget": "string", "input_options": {"correctAnswer": "plain_string(settings['correct_quantity'])", "hint": {"static": true, "value": ""}, "allowEmpty": {"static": true, "value": false}}, "can_be_gap": true, "can_be_step": true, "marking_script": "mark:\nswitch( \nright and good_units and right_sign and angle_in_range, add_credit(1.0,'Correct.'),\nright and good_units and not right_sign, add_credit(settings['C2'],'Wrong sign.'),\nright and right_sign and not good_units, add_credit(settings['C2'],'Correct angle, but missing degree symbol.'),\nright and good_units and right_sign and not angle_in_range,add_credit(settings['C1'],'Angle is out of range.'),\nclose and good_units, add_credit(settings['C1'],'Close.'),\nclose and not good_units, add_credit(settings['C3'],'Answer is close, but missing degree symbol.'),\nincorrect('Wrong answer.')\n)\n\ninterpreted_answer:\nqty(student_scalar, student_units)\n\ncorrect_scalar:\nscalar(correct_quantity)\n  \n\ncorrect_quantity:\nsettings['correct_quantity']\n\ncorrect_units:\nunits(correct_quantity)\n\nallowed_notation_styles:\n[\"plain\",\"en\"]\n\nmatch_student_number:\nmatchnumber(studentAnswer,allowed_notation_styles)\n\nstudent_scalar:\nmatch_student_number[1]\n\nstudent_units:\njoin(\nsplit(studentAnswer[len(match_student_number[0])..len(studentAnswer)]\n,\"\u00b0\"),\" deg\")\n\n\n\ngood_units:\ntry(\nkind(quantity(1, student_units))= kind(correct_quantity),\nmsg,\nfeedback(msg);false)\n\nstudent_quantity:\nswitch(not good_units, \nstudent_scalar * correct_units, \nnot right_sign,\n-quantity(student_scalar, student_units),\nquantity(student_scalar,student_units)\n)\n\nright_sign:\nsign(student_scalar) = sign(correct_quantity)\n\nangle_in_range:\nif(settings['restrict_angle'], abs(student_scalar) <= 90, true)\n\nright:\nwithinTolerance(abs(student_scalar), abs(correct_scalar), settings['right'])\n\nclose:\nwithinTolerance(student_scalar, correct_scalar, settings['close'])", "marking_notes": [{"name": "mark", "description": "This is the main marking note. It should award credit and provide feedback based on the student's answer.", "definition": "switch( \nright and good_units and right_sign and angle_in_range, add_credit(1.0,'Correct.'),\nright and good_units and not right_sign, add_credit(settings['C2'],'Wrong sign.'),\nright and right_sign and not good_units, add_credit(settings['C2'],'Correct angle, but missing degree symbol.'),\nright and good_units and right_sign and not angle_in_range,add_credit(settings['C1'],'Angle is out of range.'),\nclose and good_units, add_credit(settings['C1'],'Close.'),\nclose and not good_units, add_credit(settings['C3'],'Answer is close, but missing degree symbol.'),\nincorrect('Wrong answer.')\n)"}, {"name": "interpreted_answer", "description": "A value representing the student's answer to this part.", "definition": "qty(student_scalar, student_units)"}, {"name": "correct_scalar", "description": "", "definition": "scalar(correct_quantity)\n  "}, {"name": "correct_quantity", "description": "", "definition": "settings['correct_quantity']"}, {"name": "correct_units", "description": "", "definition": "units(correct_quantity)"}, {"name": "allowed_notation_styles", "description": "", "definition": "[\"plain\",\"en\"]"}, {"name": "match_student_number", "description": "", "definition": "matchnumber(studentAnswer,allowed_notation_styles)"}, {"name": "student_scalar", "description": "", "definition": "match_student_number[1]"}, {"name": "student_units", "description": "", "definition": "join(\nsplit(studentAnswer[len(match_student_number[0])..len(studentAnswer)]\n,\"\u00b0\"),\" deg\")\n\n"}, {"name": "good_units", "description": "", "definition": "try(\nkind(quantity(1, student_units))= kind(correct_quantity),\nmsg,\nfeedback(msg);false)"}, {"name": "student_quantity", "description": "", "definition": "switch(not good_units, \nstudent_scalar * correct_units, \nnot right_sign,\n-quantity(student_scalar, student_units),\nquantity(student_scalar,student_units)\n)"}, {"name": "right_sign", "description": "", "definition": "sign(student_scalar) = sign(correct_quantity)"}, {"name": "angle_in_range", "description": "", "definition": "if(settings['restrict_angle'], abs(student_scalar) <= 90, true)"}, {"name": "right", "description": "<p>Will check for correct sign elswhere.</p>", "definition": "withinTolerance(abs(student_scalar), abs(correct_scalar), settings['right'])"}, {"name": "close", "description": "<p>Must have correct sign to be close.</p>", "definition": "withinTolerance(student_scalar, correct_scalar, settings['close'])\n"}], "settings": [{"name": "correct_quantity", "label": "Correct Angle as quantity ", "help_url": "", "hint": "", "input_type": "code", "default_value": "qty(45,'deg')", "evaluate": true}, {"name": "right", "label": "Accuracy for right.", "help_url": "", "hint": "Question will be considered correct if the scalar part of the student's answer is within &plusmn; this amount from the correct value.", "input_type": "code", "default_value": "0.1", "evaluate": true}, {"name": "restrict_angle", "label": "Less than 90\u00b0", "help_url": "", "hint": "When checked, angle must be between -90&deg; and +90&deg;.", "input_type": "checkbox", "default_value": true}, {"name": "C1", "label": "Close with units.", "help_url": "", "hint": "Partial Credit for close value with appropriate units.", "input_type": "percent", "default_value": "75"}, {"name": "close", "label": " Accuracy for close.", "help_url": "", "hint": "Question will be considered close if the scalar part of the student's answer is within &plusmn; this amount from the correct value.", "input_type": "code", "default_value": "0.5", "evaluate": true}, {"name": "C2", "label": "No units or wrong sign", "help_url": "", "hint": "Partial credit for forgetting units or using wrong sign.", "input_type": "percent", "default_value": "50"}, {"name": "C3", "label": "Close, no units.", "help_url": "", "hint": "Partial Credit for close value without units.", "input_type": "percent", "default_value": "25"}], "public_availability": "restricted", "published": false, "extensions": ["quantities"]}, {"source": {"pk": 12, "author": {"name": "William Haynes", "pk": 2530}, "edit_page": "/part_type/12/edit"}, "name": "Angle quantity 2020", "short_name": "angle", "description": "<p>Adjusts all angles to 0 &lt; $\\theta$ &lt; 360.</p>\n<p>Accepts '&deg;' and 'deg' as units.</p>\n<p>Penalizes if not close enough or no units.</p>\n<p>90&deg; = -270&deg; = 450&deg;</p>", "help_url": "", "input_widget": "string", "input_options": {"correctAnswer": "plain_string(settings['expected_answer']) ", "hint": {"static": true, "value": ""}, "allowEmpty": {"static": true, "value": false}}, "can_be_gap": true, "can_be_step": true, "marking_script": "original_student_scalar:\nmatchnumber(studentAnswer,['plain','en'])[1]\n\nstudent_scalar:\nmod(original_student_scalar,360)\n\n\nstudent_unit:\nstudentAnswer[len(matchnumber(studentAnswer,['plain','en'])[0])..len(studentAnswer)]\n\ninterpreted_unit:\nif(trim(student_unit)='\u00b0','deg',student_unit)\n\ninterpreted_answer:\nqty(mod(student_scalar,360),'deg')\n\nclose:\nwithintolerance(student_scalar, correct_scalar,decimal(settings['close_tol']))\n\ncorrect_scalar:\nmod(scalar(settings['expected_answer']),360)\n\nright:\nwithintolerance(student_scalar, correct_scalar, decimal(settings['right_tol']))\n\ngood_unit:\nsame(qty(1,interpreted_unit),qty(1,'deg'))\n\nmark:\nassert(close,incorrect('Incorrect.');end());\nif(right,correct('Correct angle.'), set_credit(1 - settings['close_penalty'],'Angle is close.'));\nassert(good_unit,sub_credit(settings['unit_penalty'], 'Missing or incorrect units.'))", "marking_notes": [{"name": "original_student_scalar", "description": "<p>Retuns the scalar part of students answer (which is a quantity) as a number.</p>", "definition": "matchnumber(studentAnswer,['plain','en'])[1]"}, {"name": "student_scalar", "description": "<p>Normalize angle with mod 360</p>", "definition": "mod(original_student_scalar,360)\n"}, {"name": "student_unit", "description": "<p>matchnumber(studentAnswer,['plain','en'])[0] is a string \"12.34\"</p>", "definition": "studentAnswer[len(matchnumber(studentAnswer,['plain','en'])[0])..len(studentAnswer)]"}, {"name": "interpreted_unit", "description": "<p>Allows student to use degree symbol or 'deg' for units.</p>", "definition": "if(trim(student_unit)='\u00b0','deg',student_unit)"}, {"name": "interpreted_answer", "description": "A value representing the student's answer to this part.", "definition": "qty(mod(student_scalar,360),'deg')"}, {"name": "close", "description": "", "definition": "withintolerance(student_scalar, correct_scalar,decimal(settings['close_tol']))"}, {"name": "correct_scalar", "description": "<p>Normalize expected_answer with mod 360</p>", "definition": "mod(scalar(settings['expected_answer']),360)"}, {"name": "right", "description": "", "definition": "withintolerance(student_scalar, correct_scalar, decimal(settings['right_tol']))"}, {"name": "good_unit", "description": "", "definition": "same(qty(1,interpreted_unit),qty(1,'deg'))"}, {"name": "mark", "description": "This is the main marking note. It should award credit and provide feedback based on the student's answer.", "definition": "assert(close,incorrect('Incorrect.');end());\nif(right,correct('Correct angle.'), set_credit(1 - settings['close_penalty'],'Angle is close.'));\nassert(good_unit,sub_credit(settings['unit_penalty'], 'Missing or incorrect units.'))"}], "settings": [{"name": "expected_answer", "label": "Expected Answer", "help_url": "", "hint": "Expected angle as a quantity.", "input_type": "code", "default_value": "qty(30,'deg')", "evaluate": true}, {"name": "unit_penalty", "label": "Unit penalty", "help_url": "", "hint": "Penalty for not including degree sign or 'deg'.", "input_type": "percent", "default_value": "20"}, {"name": "close_penalty", "label": "Close Penalty", "help_url": "", "hint": "Penalty for close answer.", "input_type": "percent", "default_value": "20"}, {"name": "close_tol", "label": "Close", "help_url": "", "hint": "Angle must be $\\pm$ this many degrees to be marked close. &nbsp;&nbsp;", "input_type": "code", "default_value": "0.5", "evaluate": false}, {"name": "right_tol", "label": "Right ", "help_url": "", "hint": "Angle must be $\\pm$ this many degrees to be marked correct. &nbsp;", "input_type": "code", "default_value": "0.1", "evaluate": false}], "public_availability": "restricted", "published": false, "extensions": ["quantities"]}, {"source": {"pk": 19, "author": {"name": "William Haynes", "pk": 2530}, "edit_page": "/part_type/19/edit"}, "name": "Engineering Accuracy with units", "short_name": "engineering-answer", "description": "<p>A value with units marked right if within an adjustable % error of the correct value. &nbsp;Marked close if within a wider margin of error.</p>", "help_url": "", "input_widget": "string", "input_options": {"correctAnswer": "siground(settings['correctAnswer'],4)", "hint": {"static": true, "value": ""}, "allowEmpty": {"static": true, "value": true}}, "can_be_gap": true, "can_be_step": true, "marking_script": "mark:\nswitch( \n  right and good_units and right_sign, add_credit(1.0,'Correct.'),\n  right and good_units and not right_sign, add_credit(settings['C2'],'Wrong sign.'),\n  right and right_sign and not good_units, add_credit(settings['C2'],'Correct value, but wrong or missing units.'),\n  close and good_units, add_credit(settings['C1'],'Close.'),\n  close and not good_units, add_credit(settings['C3'],'Answer is close, but wrong or missing units.'),\n  incorrect('Wrong answer.')\n)\n\n\ninterpreted_answer:\nqty(student_scalar, student_units)\n\n\n\ncorrect_quantity:\nsettings[\"correctAnswer\"]\n\n\n\ncorrect_units:\nunits(correct_quantity)\n\n\nallowed_notation_styles:\n[\"plain\",\"en\"]\n\nmatch_student_number:\nmatchnumber(studentAnswer,allowed_notation_styles)\n\nstudent_scalar:\nmatch_student_number[1]\n\nstudent_units:\nreplace_regex('ohms','ohm',\n  replace_regex('\u00b0', ' deg',\n    replace_regex('-', ' ' ,\n      studentAnswer[len(match_student_number[0])..len(studentAnswer)])),\"i\")\n\ngood_units:\ntry(\ncompatible(quantity(1, student_units),correct_units),\nmsg,\nfeedback(msg);false)\n\n\nstudent_quantity:\nswitch(not good_units, \n       student_scalar * correct_units, \n       not right_sign,\n       -quantity(student_scalar, student_units),\n       quantity(student_scalar,student_units)\n)\n  \n\n\npercent_error:\ntry(\nscalar(abs((correct_quantity - student_quantity)/correct_quantity))*100  \n,msg,\nif(student_quantity=correct_quantity,0,100))\n   \n\nright:\npercent_error <= settings['right']\n\n\nclose:\nright_sign and percent_error <= settings['close']\n\nright_sign:\nsign(student_scalar) = sign(correct_quantity)", "marking_notes": [{"name": "mark", "description": "This is the main marking note. It should award credit and provide feedback based on the student's answer.", "definition": "switch( \n  right and good_units and right_sign, add_credit(1.0,'Correct.'),\n  right and good_units and not right_sign, add_credit(settings['C2'],'Wrong sign.'),\n  right and right_sign and not good_units, add_credit(settings['C2'],'Correct value, but wrong or missing units.'),\n  close and good_units, add_credit(settings['C1'],'Close.'),\n  close and not good_units, add_credit(settings['C3'],'Answer is close, but wrong or missing units.'),\n  incorrect('Wrong answer.')\n)\n"}, {"name": "interpreted_answer", "description": "A value representing the student's answer to this part.", "definition": "qty(student_scalar, student_units)\n\n"}, {"name": "correct_quantity", "description": "", "definition": "settings[\"correctAnswer\"]\n\n"}, {"name": "correct_units", "description": "", "definition": "units(correct_quantity)\n"}, {"name": "allowed_notation_styles", "description": "", "definition": "[\"plain\",\"en\"]"}, {"name": "match_student_number", "description": "", "definition": "matchnumber(studentAnswer,allowed_notation_styles)"}, {"name": "student_scalar", "description": "", "definition": "match_student_number[1]"}, {"name": "student_units", "description": "<p>Modify&nbsp;the&nbsp;unit portion of&nbsp;the student's answer by</p>\n<p>1. replacing \"ohms\" with \"ohm\" &nbsp;case insensitive</p>\n<p>2.&nbsp;replacing '-'&nbsp;with ' '&nbsp;</p>\n<p>3. replacing '&deg;' with ' deg'&nbsp;</p>\n<p>to allow answers like 10 ft-lb and 30&deg;</p>", "definition": "replace_regex('ohms','ohm',\n  replace_regex('\u00b0', ' deg',\n    replace_regex('-', ' ' ,\n      studentAnswer[len(match_student_number[0])..len(studentAnswer)])),\"i\")"}, {"name": "good_units", "description": "", "definition": "try(\ncompatible(quantity(1, student_units),correct_units),\nmsg,\nfeedback(msg);false)\n"}, {"name": "student_quantity", "description": "<p>This fixes the student answer for two common errors. &nbsp;</p>\n<p>If student_units are wrong&nbsp;&nbsp;- replace with correct units</p>\n<p>If student_scalar has the wrong sign - replace with right sign</p>\n<p>If student makes both errors, only one gets fixed.</p>", "definition": "switch(not good_units, \n       student_scalar * correct_units, \n       not right_sign,\n       -quantity(student_scalar, student_units),\n       quantity(student_scalar,student_units)\n)\n  \n"}, {"name": "percent_error", "description": "", "definition": "try(\nscalar(abs((correct_quantity - student_quantity)/correct_quantity))*100  \n,msg,\nif(student_quantity=correct_quantity,0,100))\n   "}, {"name": "right", "description": "", "definition": "percent_error <= settings['right']\n"}, {"name": "close", "description": "<p>Only marked close if the student actually has the right sign.</p>", "definition": "right_sign and percent_error <= settings['close']"}, {"name": "right_sign", "description": "", "definition": "sign(student_scalar) = sign(correct_quantity) "}], "settings": [{"name": "correctAnswer", "label": "Correct Quantity.", "help_url": "", "hint": "The correct answer given as a JME quantity.", "input_type": "code", "default_value": "", "evaluate": true}, {"name": "right", "label": "% Accuracy for right.", "help_url": "", "hint": "Question will be considered correct if the scalar part of the student's answer is within this % of correct value.", "input_type": "code", "default_value": "0.2", "evaluate": true}, {"name": "close", "label": "% Accuracy for close.", "help_url": "", "hint": "Question will be considered close if the scalar part of the student's answer is within this % of correct value.", "input_type": "code", "default_value": "1.0", "evaluate": true}, {"name": "C1", "label": "Close with units.", "help_url": "", "hint": "Partial Credit for close value with appropriate units. &nbsp;if correct answer is 100 N and close is &plusmn;1%,<br />99 &nbsp;N is accepted.", "input_type": "percent", "default_value": "75"}, {"name": "C2", "label": "No units or wrong sign", "help_url": "", "hint": "Partial credit for forgetting units or using wrong sign.<br />If the correct answer is 100 N, both 100 and -100 N are accepted.", "input_type": "percent", "default_value": "50"}, {"name": "C3", "label": "Close, no units.", "help_url": "", "hint": "Partial Credit for close value but forgotten units.<br />This value would be close&nbsp;if the expected units were provided. &nbsp;If the correct answer is 100 N, and close is &plusmn;1%,<br />99 is accepted.", "input_type": "percent", "default_value": "25"}], "public_availability": "always", "published": true, "extensions": ["quantities"]}], "resources": []}</script>
                <script type="application/json" slot="extension-data">{"geogebra": {"root": "extensions/geogebra", "stylesheets": [], "javascripts": ["geogebra.js"]}, "quantities": {"root": "extensions/quantities", "stylesheets": [], "javascripts": ["quantities.js"]}}</script>
            </numbas-exam>
            
        </div>
	</body>
</html>